<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Scrollable Square Color Palette</title>
        <!-- Include html2canvas library -->
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
            integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        ></script>
        <style>
            :root {
                --cell-size-min: 30px; /* Minimum cell size */
                --cell-size-max: 60px; /* Maximum cell size */
                /* Responsive cell size: Scales between min/max based on viewport width */
                /* Adjust the 2.5vw value to control scaling speed */
                --cell-size: max(var(--cell-size-min), min(var(--cell-size-max), 2.5vw));
                --cell-spacing: 8px;
                --cell-padding-y: 16px;  /* Vertical padding */
                --cell-padding-x: 8px;  /* Horizontal padding */
                --border-radius: 16px; /* Updated border radius */
                /* Refined Theme Colors */
                --bg-color: #0f0f0f; /* Slightly darker bg */
                --surface-color-1: #1a1a1a; /* Container, Modal */
                --surface-color-2: #2a2a2a; /* Cells, Inputs */
                --accent-color: #4a90e2; /* Accent for focus/hover highlights */
                --button-color: #3f3f3f; /* Darker button */
                --button-text-color: #e0e0e0; /* Lighter button text */
                --button-hover-color: #555555;
                --text-color: #f0f0f0; /* Slightly brighter text */
                --text-color-muted: #aaaaaa;
                --border-color: #404040; /* Slightly lighter border */
            }

            body {
                background-color: var(--bg-color);
                color: var(--text-color);
                font-family:
                    system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    Helvetica, Arial, sans-serif, "Apple Color Emoji",
                    "Segoe UI Emoji", "Segoe UI Symbol"; /* Modern font stack */
                margin: 0;
                padding: 20px; /* Increased padding */
                min-height: 100vh;
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            /* --- Controls Area --- */
            #controls-area { /* New wrapper for all controls */
                width: 100%;
                max-width: 800px; /* Allow slightly wider controls */
                margin-bottom: 25px;
                background-color: var(--surface-color-1);
                padding: 15px 20px;
                border-radius: var(--border-radius);
                display: flex;
                flex-direction: column; /* Stack control groups */
                gap: 8px; /* Updated gap */
            }

            .control-group { /* Wrapper for logical groups of controls */
                display: flex;
                flex-wrap: wrap; /* Allow wrapping */
                align-items: center;
                gap: 8px; /* Updated gap */
                padding-bottom: 10px;
                border-bottom: 1px solid var(--border-color); /* Separator */
            }
            .control-group:last-child {
                border-bottom: none; /* No border for the last group */
                padding-bottom: 0;
            }

            .control-group h3 { /* Optional headings for groups */
                margin: 0 0 5px 0;
                font-size: 14px;
                font-weight: 600;
                color: var(--text-color-muted);
                width: 100%; /* Make heading span full width */
                flex-basis: 100%;
            }

            /* Shared button styles */
            .control-button {
                background-color: var(--button-color);
                color: var(--button-text-color);
                border: 1px solid transparent; /* Add border for focus */
                padding: 9px 16px;
                border-radius: var(--border-radius);
                cursor: pointer;
                font-size: 13px;
                font-weight: 500;
                transition: all 0.2s ease;
                white-space: nowrap;
            }
            .control-button:hover {
                background-color: var(--button-hover-color);
                border-color: var(--accent-color);
            }
            .control-button:focus-visible { /* Better focus */
                 outline: none;
                 border-color: var(--accent-color);
            }
            .control-button:disabled {
                background-color: #333;
                color: #777;
                cursor: not-allowed;
                border-color: transparent;
            }

            /* Specific Control Styling */
            #interpolation-controls label,
            #saturation-controls label {
                cursor: pointer;
                user-select: none;
                margin-right: 5px;
                font-size: 13px;
                color: var(--text-color-muted);
            }
            #interpolation-controls input[type="checkbox"] {
                margin-right: 10px;
                vertical-align: middle;
                accent-color: var(--accent-color); /* Style checkbox */
            }

            /* Slider/Number Input Groups */
            .slider-group {
                display: flex;
                align-items: center;
                gap: 8px; /* Updated gap */
            }
            #interpolation-steps-group {
                 display: none; /* Hidden by default */
            }
            #interpolation-controls input[type="checkbox"]:checked ~ #interpolation-steps-group {
                 display: flex; /* Show when checkbox is checked */
            }

            input[type="range"] { /* Style sliders */
                 width: 120px;
                 height: 5px;
                 cursor: pointer;
                 accent-color: var(--accent-color);
                 vertical-align: middle;
            }
            input[type="number"] { /* Style number inputs */
                 width: 50px;
                 background-color: var(--surface-color-2);
                 color: var(--text-color);
                 border: 1px solid var(--border-color);
                 border-radius: 4px;
                 padding: 4px 6px;
                 font-size: 12px;
                 text-align: center;
                 -moz-appearance: textfield; /* Firefox */
            }
            input[type="number"]::-webkit-outer-spin-button,
            input[type="number"]::-webkit-inner-spin-button {
                 -webkit-appearance: none;
                 margin: 0;
            }
             input[type="number"]:focus-visible {
                 outline: none;
                 border-color: var(--accent-color);
             }

            /* --- Palette Area --- */
            #palette-container {
                width: 100%;
                max-width: calc(100% - 40px); /* Max width respecting body padding */
                overflow-x: auto;
                overflow-y: hidden;
                padding-bottom: 10px;
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius);
                background-color: var(--surface-color-1);
                padding: var(--cell-spacing);
            }

            table {
                border-collapse: separate;
                border-spacing: var(--cell-spacing);
                width: auto;
                min-width: 100%;
                table-layout: fixed;
                background-color: var(--surface-color-1);
            }

            td {
                width: var(--cell-size);
                padding: var(--cell-padding-y) var(--cell-padding-x); /* Use separate padding vars */
                text-align: center;
                vertical-align: middle;
                border-radius: var(--border-radius);
                font-size: clamp(8px, 1.2vw, 10px);
                font-weight: 500;
                position: relative;
                overflow: hidden;
                box-sizing: border-box;
                background-color: var(--surface-color-2);
                color: var(--text-color-muted);
                transition:
                    transform 0.1s ease-out,
                    box-shadow 0.2s ease-out,
                    font-weight 0.1s ease-out,
                    background-color 0.2s ease,
                    border-radius 0.2s ease; /* Added border-radius to transition */
                word-wrap: break-word;
            }

            td:hover {
                font-weight: 600; /* Slightly bolder */
            }

            td.swatch {
                cursor: pointer;
            }
            td.swatch:hover {
                border-radius: 50%; /* Transform to circle */
                z-index: 10; /* Bring to front */
            }
            td.interpolated {
                /* opacity: 0.95; */ /* Keep subtle */
            }
            td.label.interpolated-label {
                color: var(--text-color-muted);
                font-style: italic;
                font-size: smaller;
                background-color: transparent; /* Make placeholder labels less prominent */
                border: 1px dashed var(--border-color);
            }

            td.copied::after {
                content: "Copied!";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.75); /* Darker overlay */
                color: var(--text-color);
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 10px; /* Slightly larger text */
                font-weight: bold;
                border-radius: inherit;
                animation: fadeOut 1s forwards;
                z-index: 5; /* Ensure it's above cell content */
            }
            @keyframes fadeOut {
                0% { opacity: 1; }
                80% { opacity: 1; }
                100% { opacity: 0; }
            }

            /* --- Modal Styles --- */
            .modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
                padding: 40px 20px; /* Add padding for scroll */
                backdrop-filter: blur(3px); /* Optional: blur background */
            }
            .modal-content {
                background-color: var(--surface-color-1);
                color: var(--text-color);
                margin: 2% auto; /* Adjust vertical margin */
                padding: 30px; /* Increased padding */
                border: none; /* Remove border, use shadow */
                border-radius: var(--border-radius);
                width: 85%;
                max-width: 750px;
                position: relative;
            }
            .modal-header { /* Add a header section */
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 15px;
                border-bottom: 1px solid var(--border-color);
            }
            .modal-header h2 {
                 margin: 0;
                 font-size: 18px;
                 font-weight: 600;
            }
            .close-button {
                color: var(--text-color-muted);
                font-size: 26px;
                font-weight: bold;
                line-height: 1;
                background: none;
                border: none;
                padding: 0 5px;
                cursor: pointer;
                transition: color 0.2s ease;
            }
            .close-button:hover,
            .close-button:focus {
                color: var(--text-color);
                outline: none;
            }
            #palette-input {
                width: 100%;
                min-height: 280px; /* Taller */
                background-color: var(--surface-color-2);
                color: var(--text-color); /* Use main text color */
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius);
                padding: 12px;
                font-family:
                    "SF Mono", Monaco, Consolas, "Ubuntu Mono", monospace; /* Better mono stack */
                font-size: 13px;
                box-sizing: border-box;
                resize: vertical;
                margin-bottom: 20px; /* More space */
                white-space: pre;
                overflow-wrap: normal;
                overflow-x: auto;
            }
             #palette-input:focus-visible {
                  outline: none;
                  border-color: var(--accent-color);
                  box-shadow: 0 0 0 1px var(--accent-color);
             }

            #update-button { /* Style modal button like others */
                background-color: var(--accent-color); /* Use accent color */
                color: #ffffff;
                border: 1px solid transparent;
                padding: 10px 22px;
                border-radius: var(--border-radius);
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: all 0.2s ease;
                display: block; /* Keep as block */
                width: fit-content; /* Size to content */
                margin: 0 auto; /* Center */
            }
            #update-button:hover {
                background-color: #3a80d2; /* Darker accent */
                border-color: transparent;
            }
             #update-button:focus-visible { /* Better focus */
                 outline: none;
                 border-color: #ffffff;
             }

            /* --- Responsive Adjustments --- */
            @media (max-width: 768px) {
                :root {
                    --cell-spacing: 2px;
                    --cell-padding-y: 4px;
                    --cell-padding-x: 6px;
                    --border-radius: 16px; /* Adjusted responsive radius */
                }
                body { padding: 15px; }
                #controls-area { padding: 12px 15px; gap: 8px; margin-bottom: 20px;} /* Updated gap */
                .control-group { gap: 8px; padding-bottom: 8px; } /* Updated gap */
                .control-button { padding: 8px 14px; font-size: 12px; }
                 input[type="range"] { width: 100px; }
                 input[type="number"] { width: 45px; font-size: 11px; }
                td { font-size: 8px; }
                td.copied::after { font-size: 9px; }
                .modal-content { width: 92%; padding: 20px; }
                #palette-input { min-height: 220px; font-size: 12px; }
                #update-button { padding: 9px 18px; font-size: 13px; }
                .modal-header h2 { font-size: 16px; }
            }

            @media (max-width: 480px) {
                :root {
                    --cell-spacing: 2px;
                    --cell-padding-y: 3px;
                    --cell-padding-x: 5px;
                    --border-radius: 12px; /* Adjusted responsive radius */
                }
                 body { padding: 10px; }
                 #controls-area { padding: 10px; gap: 8px; margin-bottom: 15px;} /* Updated gap */
                 .control-group { flex-direction: column; align-items: stretch; gap: 8px;} /* Stack group items, updated gap */
                 .control-group h3 { margin-bottom: 8px; }
                 .control-button { width: 100%; text-align: center; padding: 10px 12px; } /* Full width buttons */
                 #interpolation-controls, #saturation-controls { /* Improve alignment when stacked */
                     display: flex;
                     flex-direction: column;
                     align-items: flex-start;
                     gap: 8px;
                 }
                 .slider-group { width: 100%; justify-content: space-between;} /* Space out slider/number */
                 input[type="range"] { width: calc(100% - 70px); } /* Adjust slider width */
                 input[type="number"] { width: 50px; }
                td { font-size: 7px; }
                td.copied::after { font-size: 8px; }
                .modal { padding: 20px 10px; }
                .modal-content { width: 95%; padding: 15px; }
                .modal-header { padding-bottom: 10px; margin-bottom: 15px; }
                #palette-input { min-height: 180px; }
                #update-button { width: 100%; } /* Full width modal button */
            }
        </style>
    </head>
    <body>
        <div id="controls-area"> <!-- Renamed and restructured -->
             <div class="control-group"> <!-- Group for Palette Actions -->
                 <!-- <h3>Palette Actions</h3> Optional Heading -->
                 <button id="edit-palette-button" class="control-button">
                     Edit Palette Data
                 </button>
                 <button id="export-png-button" class="control-button">
                     Export as PNG
                 </button>
             </div>
             <div class="control-group"> <!-- Group for Appearance Adjustments -->
                 <!-- <h3>Adjustments</h3> Optional Heading -->
                 <div id="interpolation-controls"> <!-- Keep IDs for JS -->
                     <label for="interpolation-toggle">
                         Distribute Shades (Vertical):
                     </label>
                     <input type="checkbox" id="interpolation-toggle" />
                     <div id="interpolation-steps-group" class="slider-group">
                         <label for="interpolation-steps-slider">Steps:</label>
                         <input
                             type="range"
                             id="interpolation-steps-slider"
                             min="1" max="10" value="1" step="1"
                         />
                         <input
                             type="number"
                             id="interpolation-steps-number"
                             min="1" max="10" value="1"
                         />
                     </div>
                 </div>
             </div>
             <div class="control-group">
                  <div id="saturation-controls"> <!-- Keep IDs for JS -->
                     <label for="saturation-offset-slider">Saturation Offset:</label>
                     <div id="saturation-offset-group" class="slider-group">
                         <input
                             type="range"
                             id="saturation-offset-slider"
                             min="-100" max="100" value="0" step="1"
                         />
                         <input
                             type="number"
                             id="saturation-offset-number"
                             min="-100" max="100" value="0"
                         />
                         <span>%</span>
                     </div>
                  </div>
             </div>
        </div>

        <div id="palette-container">
            <table id="palette-table">
                <tbody>
                    <!-- Table rows will be generated by JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- The Modal -->
        <div id="edit-modal" class="modal">
            <div class="modal-content">
                 <div class="modal-header"> <!-- Added Modal Header -->
                     <h2>Edit Palette Data</h2>
                     <button class="close-button" id="close-modal-button" aria-label="Close modal">&times;</button> <!-- Use button for accessibility -->
                 </div>
                <label
                    for="palette-input"
                    style="display: block; margin-bottom: 10px; font-weight: 500; font-size: 14px;"
                >
                    Palette Data (Space-Delimited rows, #Hex for colors):
                </label>
                <textarea
                    id="palette-input"
                    spellcheck="false"
                    placeholder="Example Row:&#10;Label1 #ff0000 #00ff00 Label2 #0000ff ..."
                ></textarea>
                <button id="update-button">Update Palette from Text</button>
            </div>
        </div>

        <script>
            // --- Initial Data (Minimal Format: Strings for labels, #Hex for colors) ---
            let sourceGridData = [
                // Freeze to prevent accidental modification
                [
                    "100x",
                    "#FFFFFF",
                    "Red",
                    "Vermilion",
                    "Orange",
                    "Amber",
                    "Yellow",
                    "Lime",
                    "Chartreuse",
                    "Ddahai",
                    "Green",
                    "Erin",
                    "Spring",
                    "Gashtanta",
                    "Cyan",
                    "Capri",
                    "Azure",
                    "Cerulean",
                    "Blue",
                    "Volta",
                    "Violet",
                    "Llew",
                    "Magenta",
                    "Cerise",
                    "Rose",
                    "Crimson",
                    "100x",
                ],
                [
                    "96x",
                    "#F4F4F4",
                    "#FFEBEB",
                    "#FFF0EB",
                    "#FFF5EB",
                    "#FFFAEB",
                    "#FFFFEB",
                    "#FAFFEB",
                    "#F5FFEB",
                    "#F0FFEB",
                    "#EBFFEB",
                    "#EBFFF0",
                    "#EBFFF5",
                    "#EBFFFA",
                    "#EBFFFF",
                    "#EBFAFF",
                    "#EBF5FF",
                    "#EBF0FF",
                    "#EBEBFF",
                    "#F0EBFF",
                    "#F5EBFF",
                    "#FAEBFF",
                    "#FFEBFF",
                    "#FFEBFA",
                    "#FFEBF5",
                    "#FFEBF0",
                    "96x",
                ],
                [
                    "88x",
                    "#E0E0E0",
                    "#FFC2C2",
                    "#FFD1C2",
                    "#FFE0C2",
                    "#FFF0C2",
                    "#FFFFC2",
                    "#F0FFC2",
                    "#E0FFC2",
                    "#D1FFC2",
                    "#C2FFC2",
                    "#C2FFD1",
                    "#C2FFE0",
                    "#C2FFF0",
                    "#C2FFFF",
                    "#C2F0FF",
                    "#C2E0FF",
                    "#C2D1FF",
                    "#C2C2FF",
                    "#D1C2FF",
                    "#E0C2FF",
                    "#F0C2FF",
                    "#FFC2FF",
                    "#FFC2F0",
                    "#FFC2E0",
                    "#FFC2D1",
                    "88x",
                ],
                [
                    "80x",
                    "#CCCCCC",
                    "#FF9999",
                    "#FFB399",
                    "#FFCC99",
                    "#FFE599",
                    "#FFFF99",
                    "#E5FF99",
                    "#CCFF99",
                    "#B2FF99",
                    "#99FF99",
                    "#99FFB3",
                    "#99FFCC",
                    "#99FFE5",
                    "#99FFFF",
                    "#99E5FF",
                    "#99CCFF",
                    "#99B2FF",
                    "#9999FF",
                    "#B399FF",
                    "#CC99FF",
                    "#E599FF",
                    "#FF99FF",
                    "#FF99E5",
                    "#FF99CC",
                    "#FF99B2",
                    "80x",
                ],
                [
                    "64x",
                    "#A3A3A3",
                    "#FF4747",
                    "#FF7547",
                    "#FFA347",
                    "#FFD147",
                    "#FFFF47",
                    "#D1FF47",
                    "#A3FF47",
                    "#75FF47",
                    "#47FF47",
                    "#47FF75",
                    "#47FFA3",
                    "#47FFD1",
                    "#47FFFF",
                    "#47D1FF",
                    "#47A3FF",
                    "#4775FF",
                    "#4747FF",
                    "#7547FF",
                    "#A347FF",
                    "#D147FF",
                    "#FF47FF",
                    "#FF47D1",
                    "#FF47A3",
                    "#FF4775",
                    "64x",
                ],
                [
                    "48x",
                    "#7A7A7A",
                    "#B54040",
                    "#B55D40",
                    "#B57A40",
                    "#B59840",
                    "#B5B540",
                    "#98B540",
                    "#7AB540",
                    "#5DB540",
                    "#40B540",
                    "#40B55D",
                    "#40B57A",
                    "#40B598",
                    "#40B5B5",
                    "#4098B5",
                    "#407AB5",
                    "#405DB5",
                    "#4040B5",
                    "#5D40B5",
                    "#7A40B5",
                    "#9840B5",
                    "#B540B5",
                    "#B54098",
                    "#B5407A",
                    "#B5405D",
                    "48x",
                ],
                [
                    "32x",
                    "#525252",
                    "#792A2A",
                    "#793E2A",
                    "#79522A",
                    "#79652A",
                    "#79792A",
                    "#65792A",
                    "#52792A",
                    "#3E792A",
                    "#2A792A",
                    "#2A793E",
                    "#2A7952",
                    "#2A7965",
                    "#2A7979",
                    "#2A6579",
                    "#2A5279",
                    "#2A3E79",
                    "#2A2A79",
                    "#3E2A79",
                    "#522A79",
                    "#652A79",
                    "#792A79",
                    "#792A65",
                    "#792A52",
                    "#792A3E",
                    "32x",
                ],
                [
                    "24x",
                    "#3D3D3D",
                    "#5B2020",
                    "#5B2F20",
                    "#5B3D20",
                    "#5B4C20",
                    "#5B5B20",
                    "#4C5B20",
                    "#3D5B20",
                    "#2F5B20",
                    "#205B20",
                    "#205B2F",
                    "#205B3D",
                    "#205B4C",
                    "#205B5B",
                    "#204C5B",
                    "#203D5B",
                    "#202F5B",
                    "#20205B",
                    "#2F205B",
                    "#3D205B",
                    "#4C205B",
                    "#5B205B",
                    "#5B204C",
                    "#5B203D",
                    "#5B202F",
                    "24x",
                ],
                [
                    "16x",
                    "#292929",
                    "#3C1515",
                    "#3C1F15",
                    "#3C2915",
                    "#3C3315",
                    "#3C3C15",
                    "#333C15",
                    "#293C15",
                    "#1F3C15",
                    "#153C15",
                    "#153C1F",
                    "#153C29",
                    "#153C33",
                    "#153C3C",
                    "#15333C",
                    "#15293C",
                    "#151F3C",
                    "#15153C",
                    "#1F153C",
                    "#29153C",
                    "#33153C",
                    "#3C153C",
                    "#3C1533",
                    "#3C1529",
                    "#3C151F",
                    "16x",
                ],
                [
                    "12x",
                    "#1F1F1F",
                    "#2D1010",
                    "#2D1710",
                    "#2D1F10",
                    "#2D2610",
                    "#2D2D10",
                    "#262D10",
                    "#1F2D10",
                    "#172D10",
                    "#102D10",
                    "#102D17",
                    "#102D1F",
                    "#102D26",
                    "#102D2D",
                    "#10262D",
                    "#101F2D",
                    "#10172D",
                    "#10102D",
                    "#17102D",
                    "#1F102D",
                    "#26102D",
                    "#2D102D",
                    "#2D1026",
                    "#2D101F",
                    "#2D1017",
                    "12x",
                ],
                [
                    "8x",
                    "#141414",
                    "#1E0B0B",
                    "#1E100B",
                    "#1E140B",
                    "#1E190B",
                    "#1E1E0B",
                    "#191E0B",
                    "#141E0B",
                    "#101E0B",
                    "#0B1E0B",
                    "#0B1E10",
                    "#0B1E14",
                    "#0B1E19",
                    "#0B1E1E",
                    "#0B191E",
                    "#0B141E",
                    "#0B101E",
                    "#0B0B1E",
                    "#100B1E",
                    "#140B1E",
                    "#190B1E",
                    "#1E0B1E",
                    "#1E0B19",
                    "#1E0B14",
                    "#1E0B10",
                    "8x",
                ],
                [
                    "0x",
                    "#000000",
                    "0",
                    "15",
                    "30",
                    "45",
                    "60",
                    "75",
                    "90",
                    "105",
                    "120",
                    "135",
                    "150",
                    "165",
                    "180",
                    "195",
                    "210",
                    "225",
                    "240",
                    "255",
                    "270",
                    "285",
                    "300",
                    "315",
                    "330",
                    "345",
                    "0x",
                ],
            ];

            // --- State Variables ---
            let currentGridData = [...sourceGridData.map((row) => [...row])]; // Holds data being displayed (start with a copy)
            let isInterpolationEnabled = false;
            let interpolationSteps = 1;
            let saturationOffset = 0; // NEW: Saturation offset state (-100 to 100)

            // --- DOM Elements ---
            const paletteInput = document.getElementById("palette-input");
            const updateButton = document.getElementById("update-button");
            const paletteTable = document.getElementById("palette-table");
            const tableBody = paletteTable.getElementsByTagName("tbody")[0];
            const modal = document.getElementById("edit-modal");
            const openModalButton = document.getElementById(
                "edit-palette-button",
            );
            const closeModalButton =
                document.getElementById("close-modal-button");
            const exportPngButton =
                document.getElementById("export-png-button");
            // Interpolation Controls
            const interpolationToggle = document.getElementById(
                "interpolation-toggle",
            );
            const interpolationStepsGroup = document.getElementById(
                "interpolation-steps-group",
            );
            const stepsSlider = document.getElementById(
                "interpolation-steps-slider",
            );
            const stepsNumber = document.getElementById(
                "interpolation-steps-number",
            );
            // NEW: Saturation Controls
            const saturationOffsetSlider = document.getElementById(
                "saturation-offset-slider",
            );
            const saturationOffsetNumber = document.getElementById(
                "saturation-offset-number",
            );

            // --- Helper Functions ---

            function isValidHex(str) {
                return (
                    typeof str === "string" &&
                    str.startsWith("#") &&
                    (str.length === 4 || str.length === 7) &&
                    /^#[0-9A-Fa-f]+$/.test(str)
                );
            }
            function hexToRgb(hex) {
                let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(
                    shorthandRegex,
                    (m, r, g, b) => r + r + g + g + b + b,
                );
                let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                    hex,
                );
                return result
                    ? {
                          r: parseInt(result[1], 16),
                          g: parseInt(result[2], 16),
                          b: parseInt(result[3], 16),
                      }
                    : null;
            }
            function componentToHex(c) {
                let hex = c.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            }
            function rgbToHex(r, g, b) {
                return (
                    "#" +
                    componentToHex(r) +
                    componentToHex(g) +
                    componentToHex(b)
                );
            }
            function interpolateHexColor(hex1, hex2, steps) {
                const rgb1 = hexToRgb(hex1);
                const rgb2 = hexToRgb(hex2);
                if (!rgb1 || !rgb2) return []; // Invalid input

                const interpolatedColors = [];
                const totalIntervals = steps + 1;

                for (let i = 1; i <= steps; i++) {
                    const r = Math.round(
                        rgb1.r + (rgb2.r - rgb1.r) * (i / totalIntervals),
                    );
                    const g = Math.round(
                        rgb1.g + (rgb2.g - rgb1.g) * (i / totalIntervals),
                    );
                    const b = Math.round(
                        rgb1.b + (rgb2.b - rgb1.b) * (i / totalIntervals),
                    );
                    interpolatedColors.push(rgbToHex(r, g, b));
                }
                return interpolatedColors;
            }

            // --- NEW: HSL Conversion and Adjustment ---
            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b),
                    min = Math.min(r, g, b);
                let h,
                    s,
                    l = (max + min) / 2;

                if (max == min) {
                    h = s = 0; // achromatic
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return { h, s, l }; // h, s, l are in [0, 1] range
            }

            function hslToRgb(h, s, l) {
                let r, g, b;

                if (s == 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255),
                };
            }

            function adjustSaturation(hexColor, offsetPercent) {
                const rgb = hexToRgb(hexColor);
                if (!rgb) return hexColor; // Return original if invalid

                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);

                // --- NEW: Check if the color is neutral (very low saturation) ---
                const saturationThreshold = 0.01; // Adjust as needed
                if (hsl.s < saturationThreshold) {
                    return hexColor; // Return original color if it's neutral
                }
                // --- END NEW ---

                // Adjust saturation: offset is -100 to 100, convert to -1.0 to 1.0
                const offset = offsetPercent / 100;
                hsl.s = Math.max(0, Math.min(1, hsl.s + offset)); // Clamp between 0 and 1

                const newRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                return rgbToHex(newRgb.r, newRgb.g, newRgb.b);
            }
            // --- END NEW HSL ---

            // --- Core Logic ---

            // Generate a new grid with vertically interpolated colors (inserts rows)
            function generateInterpolatedPalette(originalData, steps) {
                if (steps <= 0) return originalData.map((row) => [...row]); // Return a copy

                const newGridData = [];
                if (!originalData || originalData.length === 0)
                    return newGridData;

                const numCols = originalData[0].length;

                // Add the top header row (Row 0)
                newGridData.push([...originalData[0]]);

                // Iterate through original rows, checking pairs for interpolation
                // Skip first (header) and last (footer) rows for starting interpolation
                for (let i = 1; i < originalData.length - 2; i++) {
                    const currentRow = originalData[i];
                    const nextRow = originalData[i + 1];

                    // Add the current original row to the new grid
                    newGridData.push([...currentRow]);

                    // Prepare arrays to hold interpolated colors for each step (new row)
                    const interpolatedRowsData = Array.from(
                        { length: steps },
                        () => new Array(numCols).fill(""),
                    );

                    let canInterpolateRowPair = false; // Can we interpolate between row i and i+1?

                    // Iterate through columns (excluding first and last label columns)
                    for (let j = 1; j < numCols - 1; j++) {
                        const cell1 = currentRow[j];
                        const cell2 = nextRow[j];

                        // Check if BOTH cells in the column are valid hex colors
                        if (isValidHex(cell1) && isValidHex(cell2)) {
                            canInterpolateRowPair = true; // Found a column to interpolate
                            const interpolatedColors = interpolateHexColor(
                                cell1,
                                cell2,
                                steps,
                            );

                            // Place interpolated colors into the corresponding step's row data
                            for (let s = 0; s < steps; s++) {
                                interpolatedRowsData[s][j] =
                                    interpolatedColors[s];
                            }
                        } else {
                            // If not interpolating this column, fill placeholder rows with empty strings
                            for (let s = 0; s < steps; s++) {
                                interpolatedRowsData[s][j] = ""; // Keep empty or copy label? Empty is simpler.
                            }
                        }
                    }

                    // If interpolation was possible between these rows, add the new rows
                    if (canInterpolateRowPair) {
                        interpolatedRowsData.forEach((newRowData) => {
                            // Add placeholders for first/last column labels in the new rows
                            newRowData[0] = "-"; // Placeholder for left label
                            newRowData[newRowData.length - 1] = "-"; // Placeholder for right label
                            newGridData.push(newRowData);
                        });
                    }
                }

                // Add the second to last original row (which was skipped in the loop)
                if (originalData.length > 2) {
                    newGridData.push([
                        ...originalData[originalData.length - 2],
                    ]);
                }
                // Add the last original row (bottom labels/colors)
                if (originalData.length > 1) {
                    newGridData.push([
                        ...originalData[originalData.length - 1],
                    ]);
                }

                return newGridData;
            }

            function convertToSimpleFormat(gridData) {
                return gridData.map((row) => row.join(" ")).join("\n");
            }
            function parseSimpleFormat(textData) {
                const lines = textData.trim().split("\n");
                return lines.map((line) => {
                    return line
                        .trim()
                        .split(" ")
                        .filter((cell) => cell !== "");
                });
            }
            function getTextColor(hexBgColor) {
                if (!hexBgColor || typeof hexBgColor !== "string")
                    return "#000000"; // Default to black
                const rgb = hexToRgb(hexBgColor);
                if (!rgb) return "#000000"; // Default to black on error
                // Calculate luminance (per WCAG)
                const lum = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255;
                // Return pure white or black for maximum contrast
                return lum > 0.5 ? "#000000" : "#FFFFFF";
            }
            async function copyToClipboard(text, element) {
                if (!navigator.clipboard) {
                    try {
                        const textArea = document.createElement("textarea");
                        textArea.value = text;
                        textArea.style.position = "fixed";
                        textArea.style.opacity = "0";
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        document.execCommand("copy");
                        document.body.removeChild(textArea);
                        showCopiedFeedback(element);
                    } catch (err) {
                        console.error("Fallback copy failed: ", err);
                        alert("Failed to copy.");
                    }
                    return;
                }
                try {
                    await navigator.clipboard.writeText(text);
                    showCopiedFeedback(element);
                } catch (err) {
                    console.error("Failed to copy text: ", err);
                    alert("Failed to copy.");
                }
            }
            function showCopiedFeedback(element) {
                element.classList.add("copied");
                setTimeout(() => element.classList.remove("copied"), 1000);
            }

            // Render the palette table from grid data
            // Render the palette table from grid data
            function renderPalette(gridData) {
                tableBody.innerHTML = ""; // Clear previous content
                if (!Array.isArray(gridData)) {
                    console.error("Invalid grid data: not an array");
                    return;
                }

                gridData.forEach((rowData, rowIndex) => {
                    if (!Array.isArray(rowData)) {
                        console.warn(`Skipping invalid row ${rowIndex}`);
                        return;
                    }
                    const row = tableBody.insertRow();

                    rowData.forEach((cellData, cellIndex) => {
                        const cell = row.insertCell();
                        const isInterpolatedLabelPlaceholder = cellData === "-";

                        if (isValidHex(cellData)) {
                            // It's a color swatch
                            const originalHexColor = cellData; // Store original hex

                            // --- Apply Saturation Adjustment ---
                            const adjustedHexColor = adjustSaturation(
                                originalHexColor,
                                saturationOffset,
                            );
                            // --- End Saturation Adjustment ---

                            // --- Calculate text content based on ADJUSTED color ---
                            const adjustedHexText = adjustedHexColor
                                .substring(1)
                                .toUpperCase();

                            cell.style.backgroundColor = adjustedHexColor; // Use adjusted color for background
                            cell.textContent = adjustedHexText; // << UPDATED: Display adjusted hex text
                            cell.style.color = getTextColor(adjustedHexColor); // Calculate text color based on adjusted background
                            cell.classList.add("swatch");
                            // Optional: Store original hex in data attribute if needed for other purposes
                            cell.dataset.originalHex = originalHexColor
                                .substring(1)
                                .toUpperCase();
                            cell.dataset.adjustedHex = adjustedHexText; // Store adjusted hex too

                            cell.addEventListener("click", () => {
                                // << UPDATED: Copy the ADJUSTED hex text
                                copyToClipboard(adjustedHexText, cell);
                            });

                            // Check if the cell is supposed to be marked as interpolated based on its position and state
                            // This logic might need refinement depending on how interpolated status is tracked for rows/cols
                            // This logic might need refinement depending on how interpolated status is tracked for rows/cols
                            if (isInterpolationEnabled && /* Add condition based on rowIndex if needed */ cellData !== '-') {
                                // Example: Check if the row index corresponds to an interpolated row
                                // if (currentGridData[rowIndex] && currentGridData[rowIndex].isInterpolated) { ... }
                                // For now, adding class if interpolation is globally enabled
                                // cell.classList.add("interpolated");
                                // Note: Interpolated status is currently mainly visual via placeholder '-'
                            }
                        } else if (typeof cellData === "string") {
                            // It's a label or placeholder
                            cell.textContent = cellData;
                            cell.classList.add("label");
                            if (isInterpolatedLabelPlaceholder) {
                                cell.classList.add("interpolated-label"); // Use class for styling
                            } else {
                                // Regular label styling - USE getTextColor for contrast
                                cell.style.color = getTextColor('#2a2a2a'); // Set contrast color vs standard cell bg
                            }
                        } else {
                            // Invalid data
                            console.warn(
                                `Invalid cell data type at row ${rowIndex}, cell ${cellIndex}:`,
                                typeof cellData,
                                cellData,
                            );
                            cell.textContent = "?";
                            cell.style.backgroundColor = "#555";
                            cell.style.color = "var(--text-color)";
                        }
                    });
                });
            }

            // Update the view based on interpolation state
            function updatePaletteView() {
                if (isInterpolationEnabled) {
                    currentGridData = generateInterpolatedPalette(
                        sourceGridData,
                        interpolationSteps,
                    );
                } else {
                    // Reset to a fresh copy of the source data
                    currentGridData = sourceGridData.map((row) => [...row]);
                }
                // Render the potentially interpolated grid.
                // Saturation is applied *during* renderPalette.
                renderPalette(currentGridData);
            }

            // --- Event Listeners ---

            // Modal Events
            openModalButton.addEventListener("click", () => {
                paletteInput.value = convertToSimpleFormat(sourceGridData);
                modal.style.display = "block";
            });
            closeModalButton.addEventListener("click", () => {
                modal.style.display = "none";
            });
            window.addEventListener("click", (event) => {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            });

            // Update Button (Modal)
            updateButton.addEventListener("click", () => {
                const textData = paletteInput.value;
                try {
                    const newDataParsed = parseSimpleFormat(textData);
                    if (
                        !Array.isArray(newDataParsed) ||
                        newDataParsed.length === 0 ||
                        !Array.isArray(newDataParsed[0])
                    ) {
                        throw new Error("Parsed data is not a valid grid.");
                    }

                    sourceGridData = newDataParsed; // Update the source

                    // Reset view to show the new source data without interpolation
                    isInterpolationEnabled = false;
                    interpolationToggle.checked = false;
                    // Keep current saturation offset
                    currentGridData = sourceGridData.map((row) => [...row]); // Update current view to new source copy
                    renderPalette(currentGridData); // Render with current saturation offset
                    modal.style.display = "none";
                    alert(
                        "Palette source updated. Shade distribution disabled.",
                    );
                } catch (error) {
                    console.error(
                        "Error parsing or processing text input:",
                        error,
                    );
                    alert(
                        `Failed to update palette:\n${error.message}\n\nPlease check the format.`,
                    );
                }
            });

            // Export PNG Event Listener
            exportPngButton.addEventListener("click", () => {
                exportPngButton.disabled = true; // Disable button during export
                exportPngButton.textContent = "Exporting...";

                setTimeout(() => {
                    html2canvas(paletteTable, {
                        backgroundColor:
                            getComputedStyle(paletteTable).backgroundColor,
                        useCORS: true,
                        logging: false,
                    })
                        .then((canvas) => {
                            const pngUrl = canvas.toDataURL("image/png");
                            const downloadLink = document.createElement("a");
                            downloadLink.href = pngUrl;
                            downloadLink.download = "palette.png";
                            document.body.appendChild(downloadLink);
                            downloadLink.click();
                            document.body.removeChild(downloadLink);
                            exportPngButton.disabled = false;
                            exportPngButton.textContent = "Export as PNG";
                        })
                        .catch((err) => {
                            console.error("Error exporting PNG:", err);
                            alert(
                                "Error exporting palette as PNG. See console for details.",
                            );
                            exportPngButton.disabled = false;
                            exportPngButton.textContent = "Export as PNG";
                        });
                }, 150);
            });

            // Interpolation Toggle Listener
            interpolationToggle.addEventListener("change", (event) => {
                isInterpolationEnabled = event.target.checked;
                updatePaletteView(); // Regenerates grid if needed and re-renders
            });

            // Interpolation Steps Slider Listener
            stepsSlider.addEventListener("input", (event) => {
                interpolationSteps = parseInt(event.target.value, 10);
                stepsNumber.value = interpolationSteps; // Sync number input
                if (isInterpolationEnabled) {
                    updatePaletteView(); // Regenerates grid and re-renders
                }
            });

            // Interpolation Steps Number Input Listener
            stepsNumber.addEventListener("input", (event) => {
                let value = parseInt(event.target.value, 10);
                const min = parseInt(stepsNumber.min, 10);
                const max = parseInt(stepsNumber.max, 10);
                if (isNaN(value)) {
                    value = min;
                } else if (value < min) {
                    value = min;
                } else if (value > max) {
                    value = max;
                }
                stepsNumber.value = value;
                interpolationSteps = value;
                stepsSlider.value = interpolationSteps; // Sync slider
                if (isInterpolationEnabled) {
                    updatePaletteView(); // Regenerates grid and re-renders
                }
            });

            // --- NEW: Saturation Event Listeners ---
            saturationOffsetSlider.addEventListener("input", (event) => {
                saturationOffset = parseInt(event.target.value, 10);
                saturationOffsetNumber.value = saturationOffset; // Sync number input
                // No need to regenerate the grid, just re-render with the new offset
                renderPalette(currentGridData);
            });

            saturationOffsetNumber.addEventListener("input", (event) => {
                let value = parseInt(event.target.value, 10);
                const min = parseInt(saturationOffsetNumber.min, 10);
                const max = parseInt(saturationOffsetNumber.max, 10);
                if (isNaN(value)) {
                    value = 0; // Default to 0 if invalid
                } else if (value < min) {
                    value = min;
                } else if (value > max) {
                    value = max;
                }
                saturationOffsetNumber.value = value; // Update input field
                saturationOffset = value;
                saturationOffsetSlider.value = saturationOffset; // Sync slider
                // No need to regenerate the grid, just re-render with the new offset
                renderPalette(currentGridData);
            });
            // --- END NEW Saturation Listeners ---

            // --- Initial Load ---
            stepsSlider.value = interpolationSteps; // Set initial slider value
            stepsNumber.value = interpolationSteps; // Set initial number value
            saturationOffsetSlider.value = saturationOffset; // Set initial saturation slider
            saturationOffsetNumber.value = saturationOffset; // Set initial saturation number
            renderPalette(currentGridData); // Render the initial data (copy of source)
        </script>
    </body>
</html>
