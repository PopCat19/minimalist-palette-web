<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Scrollable Square Color Palette</title>
        <!-- Include html2canvas library -->
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
            integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        ></script>
        <style>
            :root {
                --cell-size-min: 30px; /* Minimum cell size */
                --cell-size-max: 60px; /* Maximum cell size */
                /* Responsive cell size: Scales between min/max based on viewport width */
                /* Adjust the 2.5vw value to control scaling speed */
                --cell-size: max(var(--cell-size-min), min(var(--cell-size-max), 2.5vw));
                --cell-spacing: 8px;
                --cell-padding-y: 16px;  /* Vertical padding */
                --cell-padding-x: 8px;  /* Horizontal padding */
                --border-radius: 16px; /* Updated border radius */
                /* Refined Theme Colors */
                --bg-color: #0f0f0f; /* Slightly darker bg */
                --surface-color-1: #1a1a1a; /* Container, Modal */
                --surface-color-2: #2a2a2a; /* Cells, Inputs */
                --accent-color: #4a90e2; /* Accent for focus/hover highlights */
                --button-color: #3f3f3f; /* Darker button */
                --button-text-color: #e0e0e0; /* Lighter button text */
                --button-hover-color: #555555;
                --text-color: #f0f0f0; /* Slightly brighter text */
                --text-color-muted: #aaaaaa;
                --border-color: #404040; /* Slightly lighter border */
            }

            body {
                background-color: var(--bg-color);
                color: var(--text-color);
                font-family:
                    system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    Helvetica, Arial, sans-serif, "Apple Color Emoji",
                    "Segoe UI Emoji", "Segoe UI Symbol"; /* Modern font stack */
                margin: 0;
                padding: 0;
                overflow: hidden;
                min-height: 100vh;
                width: 100vw; /* Ensure body takes full width */
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            /* --- Canvas Viewport (Pannable Area) --- */
            #canvas-viewport {
                width: 100%;
                height: 100vh;
                overflow: hidden; /* Crucial for JS panning */
                position: relative; /* Context for absolute positioning of palette */
                cursor: grab;
                background-color: var(--bg-color); /* Match body */
            }
            #canvas-viewport.grabbing {
                cursor: grabbing;
            }

            /* --- Palette Container (Moved by JS) --- */
            #palette-container {
                position: absolute;
                top: 50px; /* Initial offset */
                left: 50px; /* Initial offset */
                background-color: var(--surface-color-1);
                border-radius: var(--border-radius);
                padding: var(--cell-spacing); /* Space around table */
                border: 1px solid var(--border-color);
                /* Remove width/max-width, let content size it */
                /* No overflow handling needed here */
                /* box-shadow removed */
            }

            table {
                border-collapse: separate;
                border-spacing: var(--cell-spacing);
                width: auto; /* Let content determine width */
                table-layout: fixed;
                background-color: var(--surface-color-1);
            }

            td {
                width: var(--cell-size);
                padding: var(--cell-padding-y) var(--cell-padding-x);
                text-align: center;
                vertical-align: middle;
                border-radius: var(--border-radius);
                font-size: clamp(8px, 1.2vw, 10px);
                font-weight: 500;
                position: relative;
                overflow: hidden;
                box-sizing: border-box;
                background-color: var(--surface-color-2);
                color: var(--text-color-muted);
                transition:
                    transform 0.1s ease-out,
                    box-shadow 0.2s ease-out,
                    font-weight 0.1s ease-out,
                    background-color 0.2s ease,
                    border-radius 0.2s ease;
                word-wrap: break-word;
            }
            td:hover { font-weight: 600; }
            td.swatch { cursor: pointer; }
            td.swatch:hover { border-radius: 50%; z-index: 10; }
            td.interpolated { /* opacity: 0.95; */ }
            td.label.interpolated-label {
                color: var(--text-color-muted);
                font-style: italic;
                font-size: smaller;
                background-color: transparent;
                border: 1px dashed var(--border-color);
            }
            td.copied::after {
                content: "Copied!";
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.75); color: var(--text-color);
                display: flex; justify-content: center; align-items: center;
                font-size: 10px; font-weight: bold; border-radius: inherit;
                animation: fadeOut 1s forwards; z-index: 5;
            }
            @keyframes fadeOut { 0% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }

            /* --- Config Toggle Button --- */
            #config-toggle-button {
                position: fixed;
                top: 15px;
                right: 15px;
                z-index: 1100;
                background-color: var(--surface-color-1);
                color: var(--text-color-muted);
                border: 1px solid var(--border-color);
                border-radius: 50%; /* Circle */
                width: 40px;
                height: 40px;
                font-size: 20px;
                line-height: 38px; /* Center icon vertically */
                text-align: center;
                cursor: pointer;
                transition: all 0.2s ease;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }
            #config-toggle-button:hover {
                color: var(--text-color);
                background-color: var(--surface-color-2);
                border-color: var(--accent-color);
            }

            /* --- Config Modal --- */
            #config-modal {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.95);
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0.2s;
                z-index: 1050;
                background-color: var(--surface-color-1);
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius);
                padding: 25px;
                width: 90%;
                max-width: 550px;
                max-height: 80vh;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 20px; /* Gap between sections in modal */
            }
            #config-modal.visible {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
                visibility: visible;
                transition: opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0s;
            }

            /* Close button for modal */
            .modal-close-button {
                position: absolute;
                top: 10px;
                right: 10px;
                background: none;
                border: none;
                font-size: 24px;
                line-height: 1;
                color: var(--text-color-muted);
                cursor: pointer;
            }
            .modal-close-button:hover { color: var(--text-color); }

            /* Sections within modal */
            .config-section {
                padding-bottom: 15px;
                border-bottom: 1px solid var(--border-color);
            }
            .config-section:last-child { border-bottom: none; padding-bottom: 0; }

            .config-section h3 {
                margin: 0 0 15px 0;
                font-size: 16px;
                font-weight: 600;
                color: var(--text-color);
            }

            /* Controls moved into modal */
            .control-group { /* Re-style for modal context */
                display: flex;
                flex-wrap: wrap;
                align-items: center;
                gap: 10px; /* Adjust gap for modal */
                padding-bottom: 0; /* Remove padding */
                border-bottom: none; /* Remove border */
            }

            .control-button { /* Base styles remain */
                /* Adjust padding/size if needed for modal */
            }

            #interpolation-controls,
            #saturation-controls {
                 width: 100%; /* Take full width in modal */
                 display: flex;
                 flex-wrap: wrap;
                 align-items: center;
                 gap: 10px;
            }
            #interpolation-controls label,
            #saturation-controls label { /* Styles remain */ }
            input[type="checkbox"] { /* Styles remain */ }
            .slider-group { /* Styles remain */ }
            input[type="range"] { /* Styles remain, maybe adjust width */ width: 150px; }
            input[type="number"] { /* Styles remain */ }

            /* Palette Editor section in modal */
            #palette-editor-section {
                display: none; /* Hidden by default */
            }
            #config-modal.editor-visible #palette-editor-section {
                display: block;
            }

            #palette-input {
                width: 100%;
                min-height: 200px; /* Adjust height for modal */
                background-color: var(--surface-color-2);
                color: var(--text-color);
                border: 1px solid var(--border-color);
                border-radius: 8px; /* Smaller radius for input */
                padding: 10px;
                font-family: "SF Mono", Monaco, Consolas, "Ubuntu Mono", monospace;
                font-size: 13px;
                box-sizing: border-box;
                resize: vertical;
                margin-bottom: 15px;
                white-space: pre; overflow-wrap: normal; overflow-x: auto;
            }
            #palette-input:focus-visible { outline: none; border-color: var(--accent-color); }

            #update-button {
                background-color: var(--accent-color);
                color: #ffffff; border: none;
                padding: 9px 18px;
                border-radius: 8px;
                cursor: pointer; font-size: 14px; font-weight: 500;
                transition: all 0.2s ease;
                display: block; width: fit-content; margin: 0 auto;
            }
            #update-button:hover { background-color: #3a80d2; }
            #update-button:focus-visible { outline: none; border-color: #ffffff; }

            /* --- Responsive Adjustments --- */
            @media (max-width: 768px) {
                :root {
                    --cell-spacing: 2px;
                    --cell-padding-y: 4px;
                    --cell-padding-x: 6px;
                    --border-radius: 16px;
                }
                #config-modal { width: 95%; padding: 20px; gap: 15px; }
                .config-section h3 { font-size: 15px; margin-bottom: 12px; }
                 input[type="range"] { width: 120px; }
                 input[type="number"] { width: 45px; font-size: 11px; }
                td { font-size: 8px; }
                td.copied::after { font-size: 9px; }
                #palette-input { min-height: 180px; font-size: 12px; }
            }

            @media (max-width: 480px) {
                :root {
                    --cell-spacing: 2px;
                    --cell-padding-y: 3px;
                    --cell-padding-x: 5px;
                    --border-radius: 12px;
                }
                #config-toggle-button { width: 36px; height: 36px; font-size: 18px; line-height: 34px; }
                #config-modal {
                     padding: 15px;
                     gap: 12px;
                }
                 .control-group { /* Stack controls vertically */
                     flex-direction: column;
                     align-items: stretch;
                     gap: 8px;
                 }
                 .control-button { width: 100%; text-align: center; padding: 10px 12px; } /* Full width buttons */
                 #interpolation-controls, #saturation-controls {
                     flex-direction: column; align-items: flex-start; gap: 8px;
                 }
                 .slider-group { width: 100%; justify-content: space-between;}
                 input[type="range"] { width: calc(100% - 70px); }
                 input[type="number"] { width: 50px; }
                td { font-size: 7px; }
                td.copied::after { font-size: 8px; }
                #palette-input { min-height: 150px; }
                #update-button { width: 100%; } /* Full width modal button */
            }
        </style>
    </head>
    <body>
        <!-- Config Toggle Button -->
        <button id="config-toggle-button" aria-label="Open Configuration">⚙️</button>

        <!-- Pannable Viewport -->
        <div id="canvas-viewport">
            <!-- Palette Container (moved by JS) -->
            <div id="palette-container">
                <table id="palette-table">
                    <tbody>
                        <!-- Table rows will be generated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Configuration Modal -->
        <div id="config-modal">
            <button class="modal-close-button" aria-label="Close Configuration">&times;</button>

            <div class="config-section">
                <h3>Palette Actions</h3>
                <div class="control-group">
                     <button id="edit-palette-button" class="control-button">
                         Edit Palette Data
                     </button>
                     <button id="export-png-button" class="control-button">
                         Export as PNG
                     </button>
                 </div>
            </div>

             <div class="config-section" id="palette-editor-section">
                 <!-- <h3>Edit Palette</h3> -->
                 <label
                    for="palette-input"
                    style="display: block; margin-bottom: 10px; font-weight: 500; font-size: 14px;"
                >
                    Palette Data (Space-Delimited rows, #Hex for colors):
                </label>
                <textarea
                    id="palette-input"
                    spellcheck="false"
                    placeholder="Example Row:&#10;Label1 #ff0000 #00ff00 Label2 #0000ff ..."
                ></textarea>
                <button id="update-button">Update Palette from Text</button>
            </div>

            <div class="config-section">
                <h3>Adjustments</h3>
                 <div id="interpolation-controls" class="control-group">
                     <label for="interpolation-toggle">
                         Distribute Shades (Vertical):
                     </label>
                     <input type="checkbox" id="interpolation-toggle" />
                     <div id="interpolation-steps-group" class="slider-group">
                         <label for="interpolation-steps-slider">Steps:</label>
                         <input
                             type="range"
                             id="interpolation-steps-slider"
                             min="1" max="10" value="1" step="1"
                         />
                         <input
                             type="number"
                             id="interpolation-steps-number"
                             min="1" max="10" value="1"
                         />
                     </div>
                 </div>
                  <div id="saturation-controls" class="control-group">
                     <label for="saturation-offset-slider">Saturation Offset:</label>
                     <div id="saturation-offset-group" class="slider-group">
                         <input
                             type="range"
                             id="saturation-offset-slider"
                             min="-100" max="100" value="0" step="1"
                         />
                         <input
                             type="number"
                             id="saturation-offset-number"
                             min="-100" max="100" value="0"
                         />
                         <span>%</span>
                     </div>
                  </div>
             </div>
        </div>

        <script>
            // --- Initial Data (Minimal Format: Strings for labels, #Hex for colors) ---
            let sourceGridData = [
                // Freeze to prevent accidental modification
                [
                    "100x",
                    "#FFFFFF",
                    "Red",
                    "Vermilion",
                    "Orange",
                    "Amber",
                    "Yellow",
                    "Lime",
                    "Chartreuse",
                    "Ddahai",
                    "Green",
                    "Erin",
                    "Spring",
                    "Gashtanta",
                    "Cyan",
                    "Capri",
                    "Azure",
                    "Cerulean",
                    "Blue",
                    "Volta",
                    "Violet",
                    "Llew",
                    "Magenta",
                    "Cerise",
                    "Rose",
                    "Crimson",
                    "100x",
                ],
                [
                    "96x",
                    "#F4F4F4",
                    "#FFEBEB",
                    "#FFF0EB",
                    "#FFF5EB",
                    "#FFFAEB",
                    "#FFFFEB",
                    "#FAFFEB",
                    "#F5FFEB",
                    "#F0FFEB",
                    "#EBFFEB",
                    "#EBFFF0",
                    "#EBFFF5",
                    "#EBFFFA",
                    "#EBFFFF",
                    "#EBFAFF",
                    "#EBF5FF",
                    "#EBF0FF",
                    "#EBEBFF",
                    "#F0EBFF",
                    "#F5EBFF",
                    "#FAEBFF",
                    "#FFEBFF",
                    "#FFEBFA",
                    "#FFEBF5",
                    "#FFEBF0",
                    "96x",
                ],
                [
                    "88x",
                    "#E0E0E0",
                    "#FFC2C2",
                    "#FFD1C2",
                    "#FFE0C2",
                    "#FFF0C2",
                    "#FFFFC2",
                    "#F0FFC2",
                    "#E0FFC2",
                    "#D1FFC2",
                    "#C2FFC2",
                    "#C2FFD1",
                    "#C2FFE0",
                    "#C2FFF0",
                    "#C2FFFF",
                    "#C2F0FF",
                    "#C2E0FF",
                    "#C2D1FF",
                    "#C2C2FF",
                    "#D1C2FF",
                    "#E0C2FF",
                    "#F0C2FF",
                    "#FFC2FF",
                    "#FFC2F0",
                    "#FFC2E0",
                    "#FFC2D1",
                    "88x",
                ],
                [
                    "80x",
                    "#CCCCCC",
                    "#FF9999",
                    "#FFB399",
                    "#FFCC99",
                    "#FFE599",
                    "#FFFF99",
                    "#E5FF99",
                    "#CCFF99",
                    "#B2FF99",
                    "#99FF99",
                    "#99FFB3",
                    "#99FFCC",
                    "#99FFE5",
                    "#99FFFF",
                    "#99E5FF",
                    "#99CCFF",
                    "#99B2FF",
                    "#9999FF",
                    "#B399FF",
                    "#CC99FF",
                    "#E599FF",
                    "#FF99FF",
                    "#FF99E5",
                    "#FF99CC",
                    "#FF99B2",
                    "80x",
                ],
                [
                    "64x",
                    "#A3A3A3",
                    "#FF4747",
                    "#FF7547",
                    "#FFA347",
                    "#FFD147",
                    "#FFFF47",
                    "#D1FF47",
                    "#A3FF47",
                    "#75FF47",
                    "#47FF47",
                    "#47FF75",
                    "#47FFA3",
                    "#47FFD1",
                    "#47FFFF",
                    "#47D1FF",
                    "#47A3FF",
                    "#4775FF",
                    "#4747FF",
                    "#7547FF",
                    "#A347FF",
                    "#D147FF",
                    "#FF47FF",
                    "#FF47D1",
                    "#FF47A3",
                    "#FF4775",
                    "64x",
                ],
                [
                    "48x",
                    "#7A7A7A",
                    "#B54040",
                    "#B55D40",
                    "#B57A40",
                    "#B59840",
                    "#B5B540",
                    "#98B540",
                    "#7AB540",
                    "#5DB540",
                    "#40B540",
                    "#40B55D",
                    "#40B57A",
                    "#40B598",
                    "#40B5B5",
                    "#4098B5",
                    "#407AB5",
                    "#405DB5",
                    "#4040B5",
                    "#5D40B5",
                    "#7A40B5",
                    "#9840B5",
                    "#B540B5",
                    "#B54098",
                    "#B5407A",
                    "#B5405D",
                    "48x",
                ],
                [
                    "32x",
                    "#525252",
                    "#792A2A",
                    "#793E2A",
                    "#79522A",
                    "#79652A",
                    "#79792A",
                    "#65792A",
                    "#52792A",
                    "#3E792A",
                    "#2A792A",
                    "#2A793E",
                    "#2A7952",
                    "#2A7965",
                    "#2A7979",
                    "#2A6579",
                    "#2A5279",
                    "#2A3E79",
                    "#2A2A79",
                    "#3E2A79",
                    "#522A79",
                    "#652A79",
                    "#792A79",
                    "#792A65",
                    "#792A52",
                    "#792A3E",
                    "32x",
                ],
                [
                    "24x",
                    "#3D3D3D",
                    "#5B2020",
                    "#5B2F20",
                    "#5B3D20",
                    "#5B4C20",
                    "#5B5B20",
                    "#4C5B20",
                    "#3D5B20",
                    "#2F5B20",
                    "#205B20",
                    "#205B2F",
                    "#205B3D",
                    "#205B4C",
                    "#205B5B",
                    "#204C5B",
                    "#203D5B",
                    "#202F5B",
                    "#20205B",
                    "#2F205B",
                    "#3D205B",
                    "#4C205B",
                    "#5B205B",
                    "#5B204C",
                    "#5B203D",
                    "#5B202F",
                    "24x",
                ],
                [
                    "16x",
                    "#292929",
                    "#3C1515",
                    "#3C1F15",
                    "#3C2915",
                    "#3C3315",
                    "#3C3C15",
                    "#333C15",
                    "#293C15",
                    "#1F3C15",
                    "#153C15",
                    "#153C1F",
                    "#153C29",
                    "#153C33",
                    "#153C3C",
                    "#15333C",
                    "#15293C",
                    "#151F3C",
                    "#15153C",
                    "#1F153C",
                    "#29153C",
                    "#33153C",
                    "#3C153C",
                    "#3C1533",
                    "#3C1529",
                    "#3C151F",
                    "16x",
                ],
                [
                    "12x",
                    "#1F1F1F",
                    "#2D1010",
                    "#2D1710",
                    "#2D1F10",
                    "#2D2610",
                    "#2D2D10",
                    "#262D10",
                    "#1F2D10",
                    "#172D10",
                    "#102D10",
                    "#102D17",
                    "#102D1F",
                    "#102D26",
                    "#102D2D",
                    "#10262D",
                    "#101F2D",
                    "#10172D",
                    "#10102D",
                    "#17102D",
                    "#1F102D",
                    "#26102D",
                    "#2D102D",
                    "#2D1026",
                    "#2D101F",
                    "#2D1017",
                    "12x",
                ],
                [
                    "8x",
                    "#141414",
                    "#1E0B0B",
                    "#1E100B",
                    "#1E140B",
                    "#1E190B",
                    "#1E1E0B",
                    "#191E0B",
                    "#141E0B",
                    "#101E0B",
                    "#0B1E0B",
                    "#0B1E10",
                    "#0B1E14",
                    "#0B1E19",
                    "#0B1E1E",
                    "#0B191E",
                    "#0B141E",
                    "#0B101E",
                    "#0B0B1E",
                    "#100B1E",
                    "#140B1E",
                    "#190B1E",
                    "#1E0B1E",
                    "#1E0B19",
                    "#1E0B14",
                    "#1E0B10",
                    "8x",
                ],
                [
                    "0x",
                    "#000000",
                    "0",
                    "15",
                    "30",
                    "45",
                    "60",
                    "75",
                    "90",
                    "105",
                    "120",
                    "135",
                    "150",
                    "165",
                    "180",
                    "195",
                    "210",
                    "225",
                    "240",
                    "255",
                    "270",
                    "285",
                    "300",
                    "315",
                    "330",
                    "345",
                    "0x",
                ],
            ];

            // --- State Variables ---
            let currentGridData = [...sourceGridData.map((row) => [...row])];
            let isInterpolationEnabled = false;
            let interpolationSteps = 1;
            let saturationOffset = 0;
            // --- NEW: Panning State ---
            let isPanning = false;
            let startX, startY, currentX, currentY;
            let paletteOffsetX = 50; // Initial offset matches CSS
            let paletteOffsetY = 50;

            // --- DOM Elements ---
            // Palette display elements
            const canvasViewport = document.getElementById('canvas-viewport');
            const paletteContainer = document.getElementById('palette-container');
            const paletteTable = document.getElementById('palette-table');
            const tableBody = paletteTable.getElementsByTagName('tbody')[0];

            // Config Modal elements
            const configToggleButton = document.getElementById('config-toggle-button');
            const configModal = document.getElementById('config-modal');
            const closeModalButton = configModal.querySelector('.modal-close-button'); // Find close button inside modal
            const editPaletteButton = document.getElementById('edit-palette-button');
            const paletteEditorSection = document.getElementById('palette-editor-section');
            const paletteInput = document.getElementById('palette-input');
            const updateButton = document.getElementById('update-button');
            const exportPngButton = document.getElementById('export-png-button');

            // Adjustment controls (now inside modal)
            const interpolationToggle = document.getElementById('interpolation-toggle');
            const interpolationStepsGroup = document.getElementById('interpolation-steps-group');
            const stepsSlider = document.getElementById('interpolation-steps-slider');
            const stepsNumber = document.getElementById('interpolation-steps-number');
            const saturationOffsetSlider = document.getElementById('saturation-offset-slider');
            const saturationOffsetNumber = document.getElementById('saturation-offset-number');

            // --- Helper Functions ---
            function isValidHex(str) {
                return (
                    typeof str === "string" &&
                    str.startsWith("#") &&
                    (str.length === 4 || str.length === 7) &&
                    /^#[0-9A-Fa-f]+$/.test(str)
                );
            }
            function hexToRgb(hex) {
                let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(
                    shorthandRegex,
                    (m, r, g, b) => r + r + g + g + b + b,
                );
                let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                    hex,
                );
                return result
                    ? {
                          r: parseInt(result[1], 16),
                          g: parseInt(result[2], 16),
                          b: parseInt(result[3], 16),
                      }
                    : null;
            }
            function componentToHex(c) {
                let hex = c.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            }
            function rgbToHex(r, g, b) {
                return (
                    "#" +
                    componentToHex(r) +
                    componentToHex(g) +
                    componentToHex(b)
                );
            }
            function interpolateHexColor(hex1, hex2, steps) {
                const rgb1 = hexToRgb(hex1);
                const rgb2 = hexToRgb(hex2);
                if (!rgb1 || !rgb2) return []; // Invalid input

                const interpolatedColors = [];
                const totalIntervals = steps + 1;

                for (let i = 1; i <= steps; i++) {
                    const r = Math.round(
                        rgb1.r + (rgb2.r - rgb1.r) * (i / totalIntervals),
                    );
                    const g = Math.round(
                        rgb1.g + (rgb2.g - rgb1.g) * (i / totalIntervals),
                    );
                    const b = Math.round(
                        rgb1.b + (rgb2.b - rgb1.b) * (i / totalIntervals),
                    );
                    interpolatedColors.push(rgbToHex(r, g, b));
                }
                return interpolatedColors;
            }

            // --- NEW: HSL Conversion and Adjustment ---
            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b),
                    min = Math.min(r, g, b);
                let h,
                    s,
                    l = (max + min) / 2;

                if (max == min) {
                    h = s = 0; // achromatic
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return { h, s, l }; // h, s, l are in [0, 1] range
            }

            function hslToRgb(h, s, l) {
                let r, g, b;

                if (s == 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255),
                };
            }

            function adjustSaturation(hexColor, offsetPercent) {
                const rgb = hexToRgb(hexColor);
                if (!rgb) return hexColor; // Return original if invalid

                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);

                // --- NEW: Check if the color is neutral (very low saturation) ---
                const saturationThreshold = 0.01; // Adjust as needed
                if (hsl.s < saturationThreshold) {
                    return hexColor; // Return original color if it's neutral
                }
                // --- END NEW ---

                // Adjust saturation: offset is -100 to 100, convert to -1.0 to 1.0
                const offset = offsetPercent / 100;
                hsl.s = Math.max(0, Math.min(1, hsl.s + offset)); // Clamp between 0 and 1

                const newRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                return rgbToHex(newRgb.r, newRgb.g, newRgb.b);
            }
            // --- END NEW HSL ---

            // --- Core Logic ---

            // Generate a new grid with vertically interpolated colors (inserts rows)
            function generateInterpolatedPalette(originalData, steps) {
                if (steps <= 0) return originalData.map((row) => [...row]); // Return a copy

                const newGridData = [];
                if (!originalData || originalData.length === 0)
                    return newGridData;

                const numCols = originalData[0].length;

                // Add the top header row (Row 0)
                newGridData.push([...originalData[0]]);

                // Iterate through original rows, checking pairs for interpolation
                // Skip first (header) and last (footer) rows for starting interpolation
                for (let i = 1; i < originalData.length - 2; i++) {
                    const currentRow = originalData[i];
                    const nextRow = originalData[i + 1];

                    // Add the current original row to the new grid
                    newGridData.push([...currentRow]);

                    // Prepare arrays to hold interpolated colors for each step (new row)
                    const interpolatedRowsData = Array.from(
                        { length: steps },
                        () => new Array(numCols).fill(""),
                    );

                    let canInterpolateRowPair = false; // Can we interpolate between row i and i+1?

                    // Iterate through columns (excluding first and last label columns)
                    for (let j = 1; j < numCols - 1; j++) {
                        const cell1 = currentRow[j];
                        const cell2 = nextRow[j];

                        // Check if BOTH cells in the column are valid hex colors
                        if (isValidHex(cell1) && isValidHex(cell2)) {
                            canInterpolateRowPair = true; // Found a column to interpolate
                            const interpolatedColors = interpolateHexColor(
                                cell1,
                                cell2,
                                steps,
                            );

                            // Place interpolated colors into the corresponding step's row data
                            for (let s = 0; s < steps; s++) {
                                interpolatedRowsData[s][j] =
                                    interpolatedColors[s];
                            }
                        } else {
                            // If not interpolating this column, fill placeholder rows with empty strings
                            for (let s = 0; s < steps; s++) {
                                interpolatedRowsData[s][j] = ""; // Keep empty or copy label? Empty is simpler.
                            }
                        }
                    }

                    // If interpolation was possible between these rows, add the new rows
                    if (canInterpolateRowPair) {
                        interpolatedRowsData.forEach((newRowData) => {
                            // Add placeholders for first/last column labels in the new rows
                            newRowData[0] = "-"; // Placeholder for left label
                            newRowData[newRowData.length - 1] = "-"; // Placeholder for right label
                            newGridData.push(newRowData);
                        });
                    }
                }

                // Add the second to last original row (which was skipped in the loop)
                if (originalData.length > 2) {
                    newGridData.push([
                        ...originalData[originalData.length - 2],
                    ]);
                }
                // Add the last original row (bottom labels/colors)
                if (originalData.length > 1) {
                    newGridData.push([
                        ...originalData[originalData.length - 1],
                    ]);
                }

                return newGridData;
            }

            function convertToSimpleFormat(gridData) {
                return gridData.map((row) => row.join(" ")).join("\n");
            }
            function parseSimpleFormat(textData) {
                const lines = textData.trim().split("\n");
                return lines.map((line) => {
                    return line
                        .trim()
                        .split(" ")
                        .filter((cell) => cell !== "");
                });
            }
            function getTextColor(hexBgColor) {
                if (!hexBgColor || typeof hexBgColor !== "string")
                    return "#000000"; // Default to black
                const rgb = hexToRgb(hexBgColor);
                if (!rgb) return "#000000"; // Default to black on error
                // Calculate luminance (per WCAG)
                const lum = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255;
                // Return pure white or black for maximum contrast
                return lum > 0.5 ? "#000000" : "#FFFFFF";
            }
            async function copyToClipboard(text, element) {
                if (!navigator.clipboard) {
                    try {
                        const textArea = document.createElement("textarea");
                        textArea.value = text;
                        textArea.style.position = "fixed";
                        textArea.style.opacity = "0";
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        document.execCommand("copy");
                        document.body.removeChild(textArea);
                        showCopiedFeedback(element);
                    } catch (err) {
                        console.error("Fallback copy failed: ", err);
                        alert("Failed to copy.");
                    }
                    return;
                }
                try {
                    await navigator.clipboard.writeText(text);
                    showCopiedFeedback(element);
                } catch (err) {
                    console.error("Failed to copy text: ", err);
                    alert("Failed to copy.");
                }
            }
            function showCopiedFeedback(element) {
                element.classList.add("copied");
                setTimeout(() => element.classList.remove("copied"), 1000);
            }

            // Render the palette table from grid data
            function renderPalette(gridData) {
                tableBody.innerHTML = ""; // Clear previous content
                if (!Array.isArray(gridData)) {
                    console.error("Invalid grid data: not an array");
                    return;
                }

                gridData.forEach((rowData, rowIndex) => {
                    if (!Array.isArray(rowData)) {
                        console.warn(`Skipping invalid row ${rowIndex}`);
                        return;
                    }
                    const row = tableBody.insertRow();

                    rowData.forEach((cellData, cellIndex) => {
                        const cell = row.insertCell();
                        const isInterpolatedLabelPlaceholder = cellData === "-";

                        if (isValidHex(cellData)) {
                            // It's a color swatch
                            const originalHexColor = cellData; // Store original hex

                            // --- Apply Saturation Adjustment ---
                            const adjustedHexColor = adjustSaturation(
                                originalHexColor,
                                saturationOffset,
                            );
                            // --- End Saturation Adjustment ---

                            // --- Calculate text content based on ADJUSTED color ---
                            const adjustedHexText = adjustedHexColor
                                .substring(1)
                                .toUpperCase();

                            cell.style.backgroundColor = adjustedHexColor; // Use adjusted color for background
                            cell.textContent = adjustedHexText; // << UPDATED: Display adjusted hex text
                            cell.style.color = getTextColor(adjustedHexColor); // Calculate text color based on adjusted background
                            cell.classList.add("swatch");
                            // Optional: Store original hex in data attribute if needed for other purposes
                            cell.dataset.originalHex = originalHexColor
                                .substring(1)
                                .toUpperCase();
                            cell.dataset.adjustedHex = adjustedHexText; // Store adjusted hex too

                            cell.addEventListener("click", () => {
                                // << UPDATED: Copy the ADJUSTED hex text
                                copyToClipboard(adjustedHexText, cell);
                            });

                            // Check if the cell is supposed to be marked as interpolated based on its position and state
                            // This logic might need refinement depending on how interpolated status is tracked for rows/cols
                            // This logic might need refinement depending on how interpolated status is tracked for rows/cols
                            if (isInterpolationEnabled && /* Add condition based on rowIndex if needed */ cellData !== '-') {
                                // Example: Check if the row index corresponds to an interpolated row
                                // if (currentGridData[rowIndex] && currentGridData[rowIndex].isInterpolated) { ... }
                                // For now, adding class if interpolation is globally enabled
                                // cell.classList.add("interpolated");
                                // Note: Interpolated status is currently mainly visual via placeholder '-'
                            }
                        } else if (typeof cellData === "string") {
                            // It's a label or placeholder
                            cell.textContent = cellData;
                            cell.classList.add("label");
                            if (isInterpolatedLabelPlaceholder) {
                                cell.classList.add("interpolated-label"); // Use class for styling
                            } else {
                                // Regular label styling - USE getTextColor for contrast
                                cell.style.color = getTextColor('#2a2a2a'); // Set contrast color vs standard cell bg
                            }
                        } else {
                            // Invalid data
                            console.warn(
                                `Invalid cell data type at row ${rowIndex}, cell ${cellIndex}:`,
                                typeof cellData,
                                cellData,
                            );
                            cell.textContent = "?";
                            cell.style.backgroundColor = "#555";
                            cell.style.color = "var(--text-color)";
                        }
                    });
                });
            }

            // Update the view based on interpolation state
            function updatePaletteView() {
                if (isInterpolationEnabled) {
                    currentGridData = generateInterpolatedPalette(
                        sourceGridData,
                        interpolationSteps,
                    );
                } else {
                    // Reset to a fresh copy of the source data
                    currentGridData = sourceGridData.map((row) => [...row]);
                }
                // Render the potentially interpolated grid.
                // Saturation is applied *during* renderPalette.
                renderPalette(currentGridData);
            }

            // --- NEW: Panning Logic ---
            function startPan(event) {
                isPanning = true;
                startX = event.clientX || event.touches[0].clientX;
                startY = event.clientY || event.touches[0].clientY;
                canvasViewport.classList.add('grabbing');
                // Prevent text selection during drag
                event.preventDefault();
            }

            function panMove(event) {
                if (!isPanning) return;
                event.preventDefault();
                currentX = event.clientX || event.touches[0].clientX;
                currentY = event.clientY || event.touches[0].clientY;

                const dx = currentX - startX;
                const dy = currentY - startY;

                paletteOffsetX += dx;
                paletteOffsetY += dy;

                paletteContainer.style.transform = `translate(${paletteOffsetX}px, ${paletteOffsetY}px)`;

                // Update start for next move delta
                startX = currentX;
                startY = currentY;
            }

            function endPan() {
                if (isPanning) {
                     isPanning = false;
                     canvasViewport.classList.remove('grabbing');
                }
            }

            // --- Event Listeners ---

            // Panning Listeners
            canvasViewport.addEventListener('mousedown', startPan);
            canvasViewport.addEventListener('mousemove', panMove);
            canvasViewport.addEventListener('mouseup', endPan);
            canvasViewport.addEventListener('mouseleave', endPan); // Stop panning if mouse leaves viewport
            // Touch Events for mobile
            canvasViewport.addEventListener('touchstart', startPan, { passive: false }); // passive: false to allow preventDefault
            canvasViewport.addEventListener('touchmove', panMove, { passive: false });
            canvasViewport.addEventListener('touchend', endPan);
            canvasViewport.addEventListener('touchcancel', endPan);

            // Config Modal Toggle Listeners
            configToggleButton.addEventListener('click', () => {
                configModal.classList.toggle('visible');
                // Hide editor when opening modal initially
                if (configModal.classList.contains('visible')) {
                    configModal.classList.remove('editor-visible');
                }
            });
            closeModalButton.addEventListener('click', () => {
                configModal.classList.remove('visible');
            });
            // Optional: Close modal on background click
            // configModal.addEventListener('click', (event) => {
            //     if (event.target === configModal) { // Click was directly on the modal background
            //         configModal.classList.remove('visible');
            //     }
            // });

            // Show/Hide Palette Editor within Modal
            editPaletteButton.addEventListener('click', () => {
                paletteInput.value = convertToSimpleFormat(sourceGridData); // Load current source data
                configModal.classList.add('editor-visible'); // Show the editor section
            });

            // Update Button (now inside config modal)
            updateButton.addEventListener('click', () => {
                const textData = paletteInput.value;
                try {
                    const newDataParsed = parseSimpleFormat(textData);
                    if (!Array.isArray(newDataParsed) || newDataParsed.length === 0 || !Array.isArray(newDataParsed[0])) {
                        throw new Error("Parsed data is not a valid grid.");
                    }
                    sourceGridData = newDataParsed;
                    isInterpolationEnabled = false; // Reset interpolation
                    interpolationToggle.checked = false;
                    currentGridData = sourceGridData.map(row => [...row]);
                    renderPalette(currentGridData); // Re-render main palette
                    configModal.classList.remove('editor-visible'); // Hide editor section
                    configModal.classList.remove('visible'); // Close modal after update
                    alert('Palette source updated. Shade distribution disabled.');
                } catch (error) {
                    console.error("Error parsing or processing text input:", error);
                    alert(`Failed to update palette:\n${error.message}\n\nPlease check the format.`);
                }
            });

            // Export PNG Event Listener (Target remains paletteTable)
            exportPngButton.addEventListener('click', () => {
                // Disable button temporarily
                exportPngButton.disabled = true;
                exportPngButton.textContent = 'Exporting...';

                 // Ensure the modal is closed or doesn't interfere (optional, usually fine)
                 // configModal.classList.remove('visible');

                // Slight delay to allow UI to settle if needed
                setTimeout(() => {
                    // Determine the background color to use
                    const tableBgColor = getComputedStyle(paletteContainer).backgroundColor;

                    html2canvas(paletteTable, {
                        backgroundColor: tableBgColor, // Use container BG for capture
                        useCORS: true,
                        logging: false,
                        // Position/offset adjustments might be needed if transform interferes
                        // x: paletteContainer.offsetLeft, // Experiment if capture is off
                        // y: paletteContainer.offsetTop,
                    })
                    .then(canvas => {
                        const pngUrl = canvas.toDataURL('image/png');
                        const downloadLink = document.createElement('a');
                        downloadLink.href = pngUrl;
                        downloadLink.download = 'palette.png';
                        document.body.appendChild(downloadLink);
                        downloadLink.click();
                        document.body.removeChild(downloadLink);
                    })
                    .catch(err => {
                        console.error('Error exporting PNG:', err);
                        alert('Error exporting palette as PNG. See console for details.');
                    })
                    .finally(() => {
                        // Re-enable button
                        exportPngButton.disabled = false;
                        exportPngButton.textContent = 'Export as PNG';
                    });
                }, 150); // Delay
            });

            // Interpolation/Saturation Listeners (No changes needed, IDs are the same)
            interpolationToggle.addEventListener('change', (event) => {
                isInterpolationEnabled = event.target.checked;
                updatePaletteView();
            });
            stepsSlider.addEventListener('input', (event) => {
                interpolationSteps = parseInt(event.target.value, 10);
                stepsNumber.value = interpolationSteps;
                if (isInterpolationEnabled) { updatePaletteView(); }
            });
            stepsNumber.addEventListener('input', (event) => {
                let value = parseInt(event.target.value, 10);
                const min = parseInt(stepsNumber.min, 10);
                const max = parseInt(stepsNumber.max, 10);
                if (isNaN(value)) { value = min; }
                else if (value < min) { value = min; }
                else if (value > max) { value = max; }
                stepsNumber.value = value;
                interpolationSteps = value;
                stepsSlider.value = interpolationSteps;
                if (isInterpolationEnabled) { updatePaletteView(); }
            });
            saturationOffsetSlider.addEventListener('input', (event) => {
                saturationOffset = parseInt(event.target.value, 10);
                saturationOffsetNumber.value = saturationOffset;
                renderPalette(currentGridData); // Just re-render
            });
            saturationOffsetNumber.addEventListener('input', (event) => {
                let value = parseInt(event.target.value, 10);
                const min = parseInt(saturationOffsetNumber.min, 10);
                const max = parseInt(saturationOffsetNumber.max, 10);
                if (isNaN(value)) { value = 0; }
                else if (value < min) { value = min; }
                else if (value > max) { value = max; }
                saturationOffsetNumber.value = value;
                saturationOffset = value;
                saturationOffsetSlider.value = saturationOffset;
                renderPalette(currentGridData); // Just re-render
            });

            // --- Initial Load ---
            function initializeApp() {
                // Set initial control values (if needed, should match defaults)
                stepsSlider.value = interpolationSteps;
                stepsNumber.value = interpolationSteps;
                saturationOffsetSlider.value = saturationOffset;
                saturationOffsetNumber.value = saturationOffset;

                // Set initial palette position
                paletteContainer.style.transform = `translate(${paletteOffsetX}px, ${paletteOffsetY}px)`;

                // Render the initial palette
                renderPalette(currentGridData);
            }

            initializeApp(); // Run initial setup

        </script>
    </body>
</html>
