<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Scrollable Square Color Palette</title>
        <!-- Include html2canvas library -->
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"
            integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        ></script>
        <style>
            :root {
                --cell-size: 45px; /* Base size for cells */
                --cell-spacing: 3px;
                --cell-padding: 5px;
                --border-radius: 5px;
                /* Theme Colors */
                --bg-color: #000000;
                --surface-color-1: #141414; /* Container, Modal */
                --surface-color-2: #1f1f1f; /* Cells, Inputs */
                --button-color: #cccccc;
                --button-text-color: #141414;
                --text-color: #ffffff;
                --text-color-muted: #cccccc;
                --border-color: #333333;
            }

            body {
                background-color: var(--bg-color);
                color: var(--text-color); /* Default text color */
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    Helvetica, Arial, sans-serif, "Apple Color Emoji",
                    "Segoe UI Emoji", "Segoe UI Symbol";
                margin: 0;
                padding: 10px;
                min-height: 100vh;
                box-sizing: border-box;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            #controls-container {
                /* Renamed for clarity */
                width: 100%;
                max-width: 600px;
                margin-bottom: 15px;
                display: flex;
                flex-direction: column; /* Stack control groups */
                align-items: center;
                gap: 10px;
            }

            #main-controls,
            #interpolation-controls,
            #saturation-controls {
                /* Added saturation-controls */
                display: flex;
                flex-wrap: wrap; /* Allow wrapping on small screens */
                justify-content: center;
                align-items: center;
                gap: 10px;
            }

            /* Shared button styles */
            .control-button {
                background-color: var(--button-color);
                color: var(--button-text-color);
                border: none;
                padding: 10px 15px; /* Slightly smaller padding */
                border-radius: var(--border-radius);
                cursor: pointer;
                font-size: 13px; /* Slightly smaller font */
                font-weight: 500;
                transition: background-color 0.2s ease;
                white-space: nowrap; /* Prevent button text wrapping */
            }
            .control-button:hover {
                background-color: #aaaaaa;
            } /* Darker hover */
            .control-button:disabled {
                /* Style for disabled state */
                background-color: #555;
                color: #999;
                cursor: not-allowed;
            }

            /* Interpolation & Saturation specific styles */
            #interpolation-controls,
            #saturation-controls {
                /* Grouped styles */
                background-color: var(--surface-color-2);
                padding: 8px 12px;
                border-radius: var(--border-radius);
                font-size: 13px;
            }
            #interpolation-controls label,
            #saturation-controls label {
                /* Grouped styles */
                cursor: pointer;
                user-select: none;
                margin-right: 5px;
            }
            #interpolation-controls input[type="checkbox"] {
                margin-right: 10px;
                vertical-align: middle;
            }
            #interpolation-steps-group,
            #saturation-offset-group {
                /* Grouped styles */
                display: flex; /* Show saturation group by default */
                align-items: center;
                gap: 8px;
            }
            #interpolation-steps-group {
                display: none; /* Hidden by default */
            }
            #interpolation-controls
                input[type="checkbox"]:checked
                ~ #interpolation-steps-group {
                display: flex; /* Show when checkbox is checked */
            }
            #interpolation-steps-slider,
            #saturation-offset-slider {
                /* Grouped styles */
                width: 100px; /* Adjust width as needed */
                vertical-align: middle;
            }
            #interpolation-steps-number,
            #saturation-offset-number {
                /* Grouped styles */
                width: 45px; /* Adjust width */
                background-color: var(--surface-color-1);
                color: var(--text-color);
                border: 1px solid var(--border-color);
                border-radius: 3px;
                padding: 3px 5px;
                font-size: 12px;
                text-align: center;
            }
            /* Hide spinner buttons on number input */
            #interpolation-steps-number::-webkit-outer-spin-button,
            #interpolation-steps-number::-webkit-inner-spin-button,
            #saturation-offset-number::-webkit-outer-spin-button,
            #saturation-offset-number::-webkit-inner-spin-button {
                /* Grouped styles */
                -webkit-appearance: none;
                margin: 0;
            }
            #interpolation-steps-number,
            #saturation-offset-number {
                /* Grouped styles */
                -moz-appearance: textfield; /* Firefox */
            }

            #palette-container {
                width: 100%;
                overflow-x: auto;
                overflow-y: hidden; /* Keep horizontal scroll, vertical handled by page */
                padding-bottom: 10px; /* Ensure space below table for capture */
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius);
                background-color: var(
                    --surface-color-1
                ); /* Ensure container bg is captured */
                padding: var(--cell-spacing); /* Match table margin */
            }

            table {
                border-collapse: separate;
                border-spacing: var(--cell-spacing);
                width: auto; /* Let table size itself based on content */
                min-width: 100%;
                table-layout: fixed; /* Keep fixed for consistent column widths */
                background-color: var(--surface-color-1);
            }

            td {
                width: var(--cell-size);
                height: var(--cell-size);
                padding: var(--cell-padding);
                text-align: center;
                vertical-align: middle;
                border-radius: var(--border-radius);
                font-size: clamp(8px, 1.2vw, 10px);
                font-weight: 500; /* Base font weight */
                position: relative;
                overflow: hidden;
                box-sizing: border-box;
                background-color: var(--surface-color-2);
                color: var(--text-color-muted);
                transition:
                    transform 0.1s ease-out,
                    box-shadow 0.2s ease-out,
                    font-weight 0.1s ease-out,
                    background-color 0.2s ease; /* Added background transition */
                word-wrap: break-word;
            }

            td:hover {
                font-weight: bold; /* Bold text on hover */
            }

            td.swatch {
                cursor: pointer;
            }
            td.swatch:hover {
                transform: scale(1.05);
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.25);
            }
            td.interpolated {
                /* Style for interpolated cells */
                /* Optional: subtle visual difference */
                /* opacity: 0.95; */
            }
            td.label.interpolated-label {
                /* Style for placeholder labels */
                color: var(--text-color-muted);
                font-style: italic;
                font-size: smaller;
            }

            td.copied::after {
                content: "Copied!";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                color: var(--text-color);
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 9px;
                font-weight: bold; /* Keep copied text bold */
                border-radius: inherit;
                animation: fadeOut 1s forwards;
            }
            @keyframes fadeOut {
                0% {
                    opacity: 1;
                }
                80% {
                    opacity: 1;
                }
                100% {
                    opacity: 0;
                }
            }

            /* --- Modal Styles --- */
            .modal {
                display: none;
                position: fixed;
                z-index: 1000;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0, 0, 0, 0.7); /* Darker overlay */
                padding-top: 60px;
            }
            .modal-content {
                background-color: var(--surface-color-1);
                color: var(--text-color); /* Ensure modal text is white */
                margin: 5% auto;
                padding: 25px;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                width: 85%;
                max-width: 750px;
                position: relative;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            }
            .close-button {
                color: #aaa;
                position: absolute;
                top: 10px;
                right: 20px;
                font-size: 28px;
                font-weight: bold;
                line-height: 1;
            }
            .close-button:hover,
            .close-button:focus {
                color: var(--text-color);
                text-decoration: none;
                cursor: pointer;
            }
            #palette-input {
                /* Style for textarea inside modal */
                width: 100%;
                min-height: 250px;
                background-color: var(--surface-color-2);
                color: var(--text-color-muted);
                border: 1px solid var(--border-color);
                border-radius: 4px;
                padding: 10px;
                font-family:
                    Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
                font-size: 13px;
                box-sizing: border-box;
                resize: vertical;
                margin-bottom: 15px;
                white-space: pre;
                overflow-wrap: normal;
                overflow-x: auto;
            }
            #update-button {
                /* Style for button inside modal */
                background-color: var(--button-color);
                color: var(--button-text-color);
                border: none;
                padding: 10px 20px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 500;
                transition: background-color 0.2s ease;
                display: block;
                margin: 0 auto;
            }
            #update-button:hover {
                background-color: #aaaaaa;
            } /* Darker hover */

            /* --- Responsive Adjustments --- */
            @media (max-width: 768px) {
                :root {
                    --cell-size: 38px;
                    --cell-spacing: 2px;
                    --cell-padding: 4px;
                    --border-radius: 4px;
                }
                td {
                    font-size: 8px;
                }
                td.copied::after {
                    font-size: 8px;
                }
                .modal-content {
                    width: 90%;
                    margin-top: 10%;
                }
                #palette-input {
                    min-height: 200px;
                    font-size: 12px;
                }
                #interpolation-controls,
                #saturation-controls {
                    /* Grouped */
                    font-size: 12px;
                }
                #interpolation-steps-slider,
                #saturation-offset-slider {
                    /* Grouped */
                    width: 80px;
                }
                #interpolation-steps-number,
                #saturation-offset-number {
                    /* Grouped */
                    width: 40px;
                    font-size: 11px;
                }
            }
            @media (max-width: 480px) {
                :root {
                    --cell-size: 32px;
                    --cell-spacing: 2px;
                    --cell-padding: 3px;
                    --border-radius: 3px;
                }
                td {
                    font-size: 7px;
                }
                #controls-container {
                    gap: 8px;
                }
                #main-controls,
                #interpolation-controls,
                #saturation-controls {
                    /* Grouped */
                    gap: 8px;
                }
                .control-button {
                    padding: 8px 10px;
                    font-size: 12px;
                }
                #interpolation-controls,
                #saturation-controls {
                    /* Grouped */
                    padding: 6px 10px;
                    font-size: 11px;
                }
                #interpolation-steps-group,
                #saturation-offset-group {
                    /* Grouped */
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 5px;
                }
                #interpolation-steps-slider,
                #saturation-offset-slider {
                    /* Grouped */
                    width: 120px;
                } /* Wider on small screens when stacked */
                #interpolation-steps-number,
                #saturation-offset-number {
                    /* Grouped */
                    width: 45px;
                }

                .modal-content {
                    width: 95%;
                    margin-top: 15%;
                    padding: 15px;
                }
                .close-button {
                    top: 5px;
                    right: 10px;
                    font-size: 24px;
                }
                #palette-input {
                    min-height: 180px;
                }
                #update-button {
                    padding: 8px 15px;
                    font-size: 13px;
                }
            }
        </style>
    </head>
    <body>
        <div id="controls-container">
            <div id="main-controls">
                <button id="edit-palette-button" class="control-button">
                    Edit Palette Data
                </button>
                <button id="export-png-button" class="control-button">
                    Export as PNG
                </button>
            </div>
            <div id="interpolation-controls">
                <label for="interpolation-toggle"
                    >Distribute Shades (Vertical):</label
                >
                <input type="checkbox" id="interpolation-toggle" />
                <div id="interpolation-steps-group">
                    <label for="interpolation-steps-slider">Steps:</label>
                    <input
                        type="range"
                        id="interpolation-steps-slider"
                        min="1"
                        max="10"
                        value="1"
                        step="1"
                    />
                    <input
                        type="number"
                        id="interpolation-steps-number"
                        min="1"
                        max="10"
                        value="1"
                    />
                </div>
            </div>
            <!-- NEW: Saturation Controls -->
            <div id="saturation-controls">
                <label for="saturation-offset-slider">Saturation Offset:</label>
                <div id="saturation-offset-group">
                    <input
                        type="range"
                        id="saturation-offset-slider"
                        min="-100"
                        max="100"
                        value="0"
                        step="1"
                    />
                    <input
                        type="number"
                        id="saturation-offset-number"
                        min="-100"
                        max="100"
                        value="0"
                    />
                    <span>%</span>
                </div>
            </div>
            <!-- END NEW -->
        </div>

        <div id="palette-container">
            <table id="palette-table">
                <tbody>
                    <!-- Table rows will be generated by JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- The Modal -->
        <div id="edit-modal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="close-modal-button"
                    >&times;</span
                >
                <label
                    for="palette-input"
                    style="display: block; margin-bottom: 8px; font-weight: 500"
                >
                    Palette Data (Space-Delimited, #Hex for colors):
                </label>
                <textarea
                    id="palette-input"
                    spellcheck="false"
                    placeholder="Paste palette data here..."
                ></textarea>
                <button id="update-button">Update Palette from Text</button>
            </div>
        </div>

        <script>
            // --- Initial Data (Minimal Format: Strings for labels, #Hex for colors) ---
            let sourceGridData = [
                // Freeze to prevent accidental modification
                [
                    "100x",
                    "#FFFFFF",
                    "Red",
                    "Vermilion",
                    "Orange",
                    "Amber",
                    "Yellow",
                    "Lime",
                    "Chartreuse",
                    "Ddahai",
                    "Green",
                    "Erin",
                    "Spring",
                    "Gashtanta",
                    "Cyan",
                    "Capri",
                    "Azure",
                    "Cerulean",
                    "Blue",
                    "Volta",
                    "Violet",
                    "Llew",
                    "Magenta",
                    "Cerise",
                    "Rose",
                    "Crimson",
                    "100x",
                ],
                [
                    "96x",
                    "#F4F4F4",
                    "#FFEBEB",
                    "#FFF0EB",
                    "#FFF5EB",
                    "#FFFAEB",
                    "#FFFFEB",
                    "#FAFFEB",
                    "#F5FFEB",
                    "#F0FFEB",
                    "#EBFFEB",
                    "#EBFFF0",
                    "#EBFFF5",
                    "#EBFFFA",
                    "#EBFFFF",
                    "#EBFAFF",
                    "#EBF5FF",
                    "#EBF0FF",
                    "#EBEBFF",
                    "#F0EBFF",
                    "#F5EBFF",
                    "#FAEBFF",
                    "#FFEBFF",
                    "#FFEBFA",
                    "#FFEBF5",
                    "#FFEBF0",
                    "96x",
                ],
                [
                    "88x",
                    "#E0E0E0",
                    "#FFC2C2",
                    "#FFD1C2",
                    "#FFE0C2",
                    "#FFF0C2",
                    "#FFFFC2",
                    "#F0FFC2",
                    "#E0FFC2",
                    "#D1FFC2",
                    "#C2FFC2",
                    "#C2FFD1",
                    "#C2FFE0",
                    "#C2FFF0",
                    "#C2FFFF",
                    "#C2F0FF",
                    "#C2E0FF",
                    "#C2D1FF",
                    "#C2C2FF",
                    "#D1C2FF",
                    "#E0C2FF",
                    "#F0C2FF",
                    "#FFC2FF",
                    "#FFC2F0",
                    "#FFC2E0",
                    "#FFC2D1",
                    "88x",
                ],
                [
                    "80x",
                    "#CCCCCC",
                    "#FF9999",
                    "#FFB399",
                    "#FFCC99",
                    "#FFE599",
                    "#FFFF99",
                    "#E5FF99",
                    "#CCFF99",
                    "#B2FF99",
                    "#99FF99",
                    "#99FFB3",
                    "#99FFCC",
                    "#99FFE5",
                    "#99FFFF",
                    "#99E5FF",
                    "#99CCFF",
                    "#99B2FF",
                    "#9999FF",
                    "#B399FF",
                    "#CC99FF",
                    "#E599FF",
                    "#FF99FF",
                    "#FF99E5",
                    "#FF99CC",
                    "#FF99B2",
                    "80x",
                ],
                [
                    "64x",
                    "#A3A3A3",
                    "#FF4747",
                    "#FF7547",
                    "#FFA347",
                    "#FFD147",
                    "#FFFF47",
                    "#D1FF47",
                    "#A3FF47",
                    "#75FF47",
                    "#47FF47",
                    "#47FF75",
                    "#47FFA3",
                    "#47FFD1",
                    "#47FFFF",
                    "#47D1FF",
                    "#47A3FF",
                    "#4775FF",
                    "#4747FF",
                    "#7547FF",
                    "#A347FF",
                    "#D147FF",
                    "#FF47FF",
                    "#FF47D1",
                    "#FF47A3",
                    "#FF4775",
                    "64x",
                ],
                [
                    "48x",
                    "#7A7A7A",
                    "#B54040",
                    "#B55D40",
                    "#B57A40",
                    "#B59840",
                    "#B5B540",
                    "#98B540",
                    "#7AB540",
                    "#5DB540",
                    "#40B540",
                    "#40B55D",
                    "#40B57A",
                    "#40B598",
                    "#40B5B5",
                    "#4098B5",
                    "#407AB5",
                    "#405DB5",
                    "#4040B5",
                    "#5D40B5",
                    "#7A40B5",
                    "#9840B5",
                    "#B540B5",
                    "#B54098",
                    "#B5407A",
                    "#B5405D",
                    "48x",
                ],
                [
                    "32x",
                    "#525252",
                    "#792A2A",
                    "#793E2A",
                    "#79522A",
                    "#79652A",
                    "#79792A",
                    "#65792A",
                    "#52792A",
                    "#3E792A",
                    "#2A792A",
                    "#2A793E",
                    "#2A7952",
                    "#2A7965",
                    "#2A7979",
                    "#2A6579",
                    "#2A5279",
                    "#2A3E79",
                    "#2A2A79",
                    "#3E2A79",
                    "#522A79",
                    "#652A79",
                    "#792A79",
                    "#792A65",
                    "#792A52",
                    "#792A3E",
                    "32x",
                ],
                [
                    "24x",
                    "#3D3D3D",
                    "#5B2020",
                    "#5B2F20",
                    "#5B3D20",
                    "#5B4C20",
                    "#5B5B20",
                    "#4C5B20",
                    "#3D5B20",
                    "#2F5B20",
                    "#205B20",
                    "#205B2F",
                    "#205B3D",
                    "#205B4C",
                    "#205B5B",
                    "#204C5B",
                    "#203D5B",
                    "#202F5B",
                    "#20205B",
                    "#2F205B",
                    "#3D205B",
                    "#4C205B",
                    "#5B205B",
                    "#5B204C",
                    "#5B203D",
                    "#5B202F",
                    "24x",
                ],
                [
                    "16x",
                    "#292929",
                    "#3C1515",
                    "#3C1F15",
                    "#3C2915",
                    "#3C3315",
                    "#3C3C15",
                    "#333C15",
                    "#293C15",
                    "#1F3C15",
                    "#153C15",
                    "#153C1F",
                    "#153C29",
                    "#153C33",
                    "#153C3C",
                    "#15333C",
                    "#15293C",
                    "#151F3C",
                    "#15153C",
                    "#1F153C",
                    "#29153C",
                    "#33153C",
                    "#3C153C",
                    "#3C1533",
                    "#3C1529",
                    "#3C151F",
                    "16x",
                ],
                [
                    "12x",
                    "#1F1F1F",
                    "#2D1010",
                    "#2D1710",
                    "#2D1F10",
                    "#2D2610",
                    "#2D2D10",
                    "#262D10",
                    "#1F2D10",
                    "#172D10",
                    "#102D10",
                    "#102D17",
                    "#102D1F",
                    "#102D26",
                    "#102D2D",
                    "#10262D",
                    "#101F2D",
                    "#10172D",
                    "#10102D",
                    "#17102D",
                    "#1F102D",
                    "#26102D",
                    "#2D102D",
                    "#2D1026",
                    "#2D101F",
                    "#2D1017",
                    "12x",
                ],
                [
                    "8x",
                    "#141414",
                    "#1E0B0B",
                    "#1E100B",
                    "#1E140B",
                    "#1E190B",
                    "#1E1E0B",
                    "#191E0B",
                    "#141E0B",
                    "#101E0B",
                    "#0B1E0B",
                    "#0B1E10",
                    "#0B1E14",
                    "#0B1E19",
                    "#0B1E1E",
                    "#0B191E",
                    "#0B141E",
                    "#0B101E",
                    "#0B0B1E",
                    "#100B1E",
                    "#140B1E",
                    "#190B1E",
                    "#1E0B1E",
                    "#1E0B19",
                    "#1E0B14",
                    "#1E0B10",
                    "8x",
                ],
                [
                    "0x",
                    "#000000",
                    "0",
                    "15",
                    "30",
                    "45",
                    "60",
                    "75",
                    "90",
                    "105",
                    "120",
                    "135",
                    "150",
                    "165",
                    "180",
                    "195",
                    "210",
                    "225",
                    "240",
                    "255",
                    "270",
                    "285",
                    "300",
                    "315",
                    "330",
                    "345",
                    "0x",
                ],
            ];

            // --- State Variables ---
            let currentGridData = [...sourceGridData.map((row) => [...row])]; // Holds data being displayed (start with a copy)
            let isInterpolationEnabled = false;
            let interpolationSteps = 1;
            let saturationOffset = 0; // NEW: Saturation offset state (-100 to 100)

            // --- DOM Elements ---
            const paletteInput = document.getElementById("palette-input");
            const updateButton = document.getElementById("update-button");
            const paletteTable = document.getElementById("palette-table");
            const tableBody = paletteTable.getElementsByTagName("tbody")[0];
            const modal = document.getElementById("edit-modal");
            const openModalButton = document.getElementById(
                "edit-palette-button",
            );
            const closeModalButton =
                document.getElementById("close-modal-button");
            const exportPngButton =
                document.getElementById("export-png-button");
            // Interpolation Controls
            const interpolationToggle = document.getElementById(
                "interpolation-toggle",
            );
            const interpolationStepsGroup = document.getElementById(
                "interpolation-steps-group",
            );
            const stepsSlider = document.getElementById(
                "interpolation-steps-slider",
            );
            const stepsNumber = document.getElementById(
                "interpolation-steps-number",
            );
            // NEW: Saturation Controls
            const saturationOffsetSlider = document.getElementById(
                "saturation-offset-slider",
            );
            const saturationOffsetNumber = document.getElementById(
                "saturation-offset-number",
            );

            // --- Helper Functions ---

            function isValidHex(str) {
                return (
                    typeof str === "string" &&
                    str.startsWith("#") &&
                    (str.length === 4 || str.length === 7) &&
                    /^#[0-9A-Fa-f]+$/.test(str)
                );
            }
            function hexToRgb(hex) {
                let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(
                    shorthandRegex,
                    (m, r, g, b) => r + r + g + g + b + b,
                );
                let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                    hex,
                );
                return result
                    ? {
                          r: parseInt(result[1], 16),
                          g: parseInt(result[2], 16),
                          b: parseInt(result[3], 16),
                      }
                    : null;
            }
            function componentToHex(c) {
                let hex = c.toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            }
            function rgbToHex(r, g, b) {
                return (
                    "#" +
                    componentToHex(r) +
                    componentToHex(g) +
                    componentToHex(b)
                );
            }
            function interpolateHexColor(hex1, hex2, steps) {
                const rgb1 = hexToRgb(hex1);
                const rgb2 = hexToRgb(hex2);
                if (!rgb1 || !rgb2) return []; // Invalid input

                const interpolatedColors = [];
                const totalIntervals = steps + 1;

                for (let i = 1; i <= steps; i++) {
                    const r = Math.round(
                        rgb1.r + (rgb2.r - rgb1.r) * (i / totalIntervals),
                    );
                    const g = Math.round(
                        rgb1.g + (rgb2.g - rgb1.g) * (i / totalIntervals),
                    );
                    const b = Math.round(
                        rgb1.b + (rgb2.b - rgb1.b) * (i / totalIntervals),
                    );
                    interpolatedColors.push(rgbToHex(r, g, b));
                }
                return interpolatedColors;
            }

            // --- NEW: HSL Conversion and Adjustment ---
            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b),
                    min = Math.min(r, g, b);
                let h,
                    s,
                    l = (max + min) / 2;

                if (max == min) {
                    h = s = 0; // achromatic
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return { h, s, l }; // h, s, l are in [0, 1] range
            }

            function hslToRgb(h, s, l) {
                let r, g, b;

                if (s == 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255),
                };
            }

            function adjustSaturation(hexColor, offsetPercent) {
                const rgb = hexToRgb(hexColor);
                if (!rgb) return hexColor; // Return original if invalid

                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);

                // Adjust saturation: offset is -100 to 100, convert to -1.0 to 1.0
                const offset = offsetPercent / 100;
                hsl.s = Math.max(0, Math.min(1, hsl.s + offset)); // Clamp between 0 and 1

                const newRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                return rgbToHex(newRgb.r, newRgb.g, newRgb.b);
            }
            // --- END NEW HSL ---

            // --- Core Logic ---

            // Generate a new grid with vertically interpolated colors (inserts rows)
            function generateInterpolatedPalette(originalData, steps) {
                if (steps <= 0) return originalData.map((row) => [...row]); // Return a copy

                const newGridData = [];
                if (!originalData || originalData.length === 0)
                    return newGridData;

                const numCols = originalData[0].length;

                // Add the top header row (Row 0)
                newGridData.push([...originalData[0]]);

                // Iterate through original rows, checking pairs for interpolation
                // Skip first (header) and last (footer) rows for starting interpolation
                for (let i = 1; i < originalData.length - 2; i++) {
                    const currentRow = originalData[i];
                    const nextRow = originalData[i + 1];

                    // Add the current original row to the new grid
                    newGridData.push([...currentRow]);

                    // Prepare arrays to hold interpolated colors for each step (new row)
                    const interpolatedRowsData = Array.from(
                        { length: steps },
                        () => new Array(numCols).fill(""),
                    );

                    let canInterpolateRowPair = false; // Can we interpolate between row i and i+1?

                    // Iterate through columns (excluding first and last label columns)
                    for (let j = 1; j < numCols - 1; j++) {
                        const cell1 = currentRow[j];
                        const cell2 = nextRow[j];

                        // Check if BOTH cells in the column are valid hex colors
                        if (isValidHex(cell1) && isValidHex(cell2)) {
                            canInterpolateRowPair = true; // Found a column to interpolate
                            const interpolatedColors = interpolateHexColor(
                                cell1,
                                cell2,
                                steps,
                            );

                            // Place interpolated colors into the corresponding step's row data
                            for (let s = 0; s < steps; s++) {
                                interpolatedRowsData[s][j] =
                                    interpolatedColors[s];
                            }
                        } else {
                            // If not interpolating this column, fill placeholder rows with empty strings
                            for (let s = 0; s < steps; s++) {
                                interpolatedRowsData[s][j] = ""; // Keep empty or copy label? Empty is simpler.
                            }
                        }
                    }

                    // If interpolation was possible between these rows, add the new rows
                    if (canInterpolateRowPair) {
                        interpolatedRowsData.forEach((newRowData) => {
                            // Add placeholders for first/last column labels in the new rows
                            newRowData[0] = "-"; // Placeholder for left label
                            newRowData[newRowData.length - 1] = "-"; // Placeholder for right label
                            newGridData.push(newRowData);
                        });
                    }
                }

                // Add the second to last original row (which was skipped in the loop)
                if (originalData.length > 2) {
                    newGridData.push([
                        ...originalData[originalData.length - 2],
                    ]);
                }
                // Add the last original row (bottom labels/colors)
                if (originalData.length > 1) {
                    newGridData.push([
                        ...originalData[originalData.length - 1],
                    ]);
                }

                return newGridData;
            }

            function convertToSimpleFormat(gridData) {
                return gridData.map((row) => row.join(" ")).join("\n");
            }
            function parseSimpleFormat(textData) {
                const lines = textData.trim().split("\n");
                return lines.map((line) => {
                    return line
                        .trim()
                        .split(" ")
                        .filter((cell) => cell !== "");
                });
            }
            function getTextColor(hexBgColor) {
                if (!hexBgColor || typeof hexBgColor !== "string")
                    return "var(--text-color)";
                const rgb = hexToRgb(hexBgColor);
                if (!rgb) return "var(--text-color)";
                const lum =
                    (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255;
                return lum > 0.5
                    ? "var(--button-text-color)"
                    : "var(--text-color)";
            }
            async function copyToClipboard(text, element) {
                if (!navigator.clipboard) {
                    try {
                        const textArea = document.createElement("textarea");
                        textArea.value = text;
                        textArea.style.position = "fixed";
                        textArea.style.opacity = "0";
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        document.execCommand("copy");
                        document.body.removeChild(textArea);
                        showCopiedFeedback(element);
                    } catch (err) {
                        console.error("Fallback copy failed: ", err);
                        alert("Failed to copy.");
                    }
                    return;
                }
                try {
                    await navigator.clipboard.writeText(text);
                    showCopiedFeedback(element);
                } catch (err) {
                    console.error("Failed to copy text: ", err);
                    alert("Failed to copy.");
                }
            }
            function showCopiedFeedback(element) {
                element.classList.add("copied");
                setTimeout(() => element.classList.remove("copied"), 1000);
            }

            // Render the palette table from grid data
            // Render the palette table from grid data
            function renderPalette(gridData) {
                tableBody.innerHTML = ""; // Clear previous content
                if (!Array.isArray(gridData)) {
                    console.error("Invalid grid data: not an array");
                    return;
                }

                gridData.forEach((rowData, rowIndex) => {
                    if (!Array.isArray(rowData)) {
                        console.warn(`Skipping invalid row ${rowIndex}`);
                        return;
                    }
                    const row = tableBody.insertRow();

                    rowData.forEach((cellData, cellIndex) => {
                        const cell = row.insertCell();
                        const isInterpolatedLabelPlaceholder = cellData === "-";

                        if (isValidHex(cellData)) {
                            // It's a color swatch
                            const originalHexColor = cellData; // Store original hex

                            // --- Apply Saturation Adjustment ---
                            const adjustedHexColor = adjustSaturation(
                                originalHexColor,
                                saturationOffset,
                            );
                            // --- End Saturation Adjustment ---

                            // --- Calculate text content based on ADJUSTED color ---
                            const adjustedHexText = adjustedHexColor
                                .substring(1)
                                .toUpperCase();

                            cell.style.backgroundColor = adjustedHexColor; // Use adjusted color for background
                            cell.textContent = adjustedHexText; // << UPDATED: Display adjusted hex text
                            cell.style.color = getTextColor(adjustedHexColor); // Calculate text color based on adjusted background
                            cell.classList.add("swatch");
                            // Optional: Store original hex in data attribute if needed for other purposes
                            cell.dataset.originalHex = originalHexColor
                                .substring(1)
                                .toUpperCase();
                            cell.dataset.adjustedHex = adjustedHexText; // Store adjusted hex too

                            cell.addEventListener("click", () => {
                                // << UPDATED: Copy the ADJUSTED hex text
                                copyToClipboard(adjustedHexText, cell);
                            });

                            if (isInterpolationEnabled) {
                                cell.classList.add("interpolated");
                            }
                        } else if (typeof cellData === "string") {
                            // It's a label or placeholder
                            cell.textContent = cellData;
                            cell.classList.add("label");
                            if (isInterpolatedLabelPlaceholder) {
                                cell.classList.add("interpolated-label"); // Use class for styling
                            } else {
                                // Regular label styling
                                cell.style.color = getTextColor(
                                    getComputedStyle(cell).backgroundColor,
                                );
                            }
                        } else {
                            // Invalid data
                            console.warn(
                                `Invalid cell data type at row ${rowIndex}, cell ${cellIndex}:`,
                                typeof cellData,
                                cellData,
                            );
                            cell.textContent = "?";
                            cell.style.backgroundColor = "#555";
                            cell.style.color = "var(--text-color)";
                        }
                    });
                });
            }

            // Update the view based on interpolation state
            function updatePaletteView() {
                if (isInterpolationEnabled) {
                    currentGridData = generateInterpolatedPalette(
                        sourceGridData,
                        interpolationSteps,
                    );
                } else {
                    // Reset to a fresh copy of the source data
                    currentGridData = sourceGridData.map((row) => [...row]);
                }
                // Render the potentially interpolated grid.
                // Saturation is applied *during* renderPalette.
                renderPalette(currentGridData);
            }

            // --- Event Listeners ---

            // Modal Events
            openModalButton.addEventListener("click", () => {
                paletteInput.value = convertToSimpleFormat(sourceGridData);
                modal.style.display = "block";
            });
            closeModalButton.addEventListener("click", () => {
                modal.style.display = "none";
            });
            window.addEventListener("click", (event) => {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            });

            // Update Button (Modal)
            updateButton.addEventListener("click", () => {
                const textData = paletteInput.value;
                try {
                    const newDataParsed = parseSimpleFormat(textData);
                    if (
                        !Array.isArray(newDataParsed) ||
                        newDataParsed.length === 0 ||
                        !Array.isArray(newDataParsed[0])
                    ) {
                        throw new Error("Parsed data is not a valid grid.");
                    }

                    sourceGridData = newDataParsed; // Update the source

                    // Reset view to show the new source data without interpolation
                    isInterpolationEnabled = false;
                    interpolationToggle.checked = false;
                    // Keep current saturation offset
                    currentGridData = sourceGridData.map((row) => [...row]); // Update current view to new source copy
                    renderPalette(currentGridData); // Render with current saturation offset
                    modal.style.display = "none";
                    alert(
                        "Palette source updated. Shade distribution disabled.",
                    );
                } catch (error) {
                    console.error(
                        "Error parsing or processing text input:",
                        error,
                    );
                    alert(
                        `Failed to update palette:\n${error.message}\n\nPlease check the format.`,
                    );
                }
            });

            // Export PNG Event Listener
            exportPngButton.addEventListener("click", () => {
                exportPngButton.disabled = true; // Disable button during export
                exportPngButton.textContent = "Exporting...";

                setTimeout(() => {
                    html2canvas(paletteTable, {
                        backgroundColor:
                            getComputedStyle(paletteTable).backgroundColor,
                        useCORS: true,
                        logging: false,
                    })
                        .then((canvas) => {
                            const pngUrl = canvas.toDataURL("image/png");
                            const downloadLink = document.createElement("a");
                            downloadLink.href = pngUrl;
                            downloadLink.download = "palette.png";
                            document.body.appendChild(downloadLink);
                            downloadLink.click();
                            document.body.removeChild(downloadLink);
                            exportPngButton.disabled = false;
                            exportPngButton.textContent = "Export as PNG";
                        })
                        .catch((err) => {
                            console.error("Error exporting PNG:", err);
                            alert(
                                "Error exporting palette as PNG. See console for details.",
                            );
                            exportPngButton.disabled = false;
                            exportPngButton.textContent = "Export as PNG";
                        });
                }, 150);
            });

            // Interpolation Toggle Listener
            interpolationToggle.addEventListener("change", (event) => {
                isInterpolationEnabled = event.target.checked;
                updatePaletteView(); // Regenerates grid if needed and re-renders
            });

            // Interpolation Steps Slider Listener
            stepsSlider.addEventListener("input", (event) => {
                interpolationSteps = parseInt(event.target.value, 10);
                stepsNumber.value = interpolationSteps; // Sync number input
                if (isInterpolationEnabled) {
                    updatePaletteView(); // Regenerates grid and re-renders
                }
            });

            // Interpolation Steps Number Input Listener
            stepsNumber.addEventListener("input", (event) => {
                let value = parseInt(event.target.value, 10);
                const min = parseInt(stepsNumber.min, 10);
                const max = parseInt(stepsNumber.max, 10);
                if (isNaN(value)) {
                    value = min;
                } else if (value < min) {
                    value = min;
                } else if (value > max) {
                    value = max;
                }
                stepsNumber.value = value;
                interpolationSteps = value;
                stepsSlider.value = interpolationSteps; // Sync slider
                if (isInterpolationEnabled) {
                    updatePaletteView(); // Regenerates grid and re-renders
                }
            });

            // --- NEW: Saturation Event Listeners ---
            saturationOffsetSlider.addEventListener("input", (event) => {
                saturationOffset = parseInt(event.target.value, 10);
                saturationOffsetNumber.value = saturationOffset; // Sync number input
                // No need to regenerate the grid, just re-render with the new offset
                renderPalette(currentGridData);
            });

            saturationOffsetNumber.addEventListener("input", (event) => {
                let value = parseInt(event.target.value, 10);
                const min = parseInt(saturationOffsetNumber.min, 10);
                const max = parseInt(saturationOffsetNumber.max, 10);
                if (isNaN(value)) {
                    value = 0; // Default to 0 if invalid
                } else if (value < min) {
                    value = min;
                } else if (value > max) {
                    value = max;
                }
                saturationOffsetNumber.value = value; // Update input field
                saturationOffset = value;
                saturationOffsetSlider.value = saturationOffset; // Sync slider
                // No need to regenerate the grid, just re-render with the new offset
                renderPalette(currentGridData);
            });
            // --- END NEW Saturation Listeners ---

            // --- Initial Load ---
            stepsSlider.value = interpolationSteps; // Set initial slider value
            stepsNumber.value = interpolationSteps; // Set initial number value
            saturationOffsetSlider.value = saturationOffset; // Set initial saturation slider
            saturationOffsetNumber.value = saturationOffset; // Set initial saturation number
            renderPalette(currentGridData); // Render the initial data (copy of source)
        </script>
    </body>
</html>
