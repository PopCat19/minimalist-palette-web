// --- Default Palette Data in YAML Format ---
const defaultPaletteYAML = `palette:
  row_0:
    - label: "100x"
    - color: "#FFFFFF"
    - label: "Red"
    - label: "Vermilion"
    - label: "Orange"
    - label: "Amber"
    - label: "Yellow"
    - label: "Lime"
    - label: "Chartreuse"
    - label: "Ddahai"
    - label: "Green"
    - label: "Erin"
    - label: "Spring"
    - label: "Gashtanta"
    - label: "Cyan"
    - label: "Capri"
    - label: "Azure"
    - label: "Cerulean"
    - label: "Blue"
    - label: "Volta"
    - label: "Violet"
    - label: "Llew"
    - label: "Magenta"
    - label: "Cerise"
    - label: "Rose"
    - label: "Crimson"
    - label: "100x"
  row_1:
    - label: "96x"
    - color: "#F4F4F4"
    - color: "#FFEBEB"
    - color: "#FFF0EB"
    - color: "#FFF5EB"
    - color: "#FFFAEB"
    - color: "#FFFFEB"
    - color: "#FAFFEB"
    - color: "#F5FFEB"
    - color: "#F0FFEB"
    - color: "#EBFFEB"
    - color: "#EBFFF0"
    - color: "#EBFFF5"
    - color: "#EBFFFA"
    - color: "#EBFFFF"
    - color: "#EBFAFF"
    - color: "#EBF5FF"
    - color: "#EBF0FF"
    - color: "#EBEBFF"
    - color: "#F0EBFF"
    - color: "#F5EBFF"
    - color: "#FAEBFF"
    - color: "#FFEBFF"
    - color: "#FFEBFA"
    - color: "#FFEBF5"
    - color: "#FFEBF0"
    - label: "96x"
  row_2:
    - label: "88x"
    - color: "#E0E0E0"
    - color: "#FFC2C2"
    - color: "#FFD1C2"
    - color: "#FFE0C2"
    - color: "#FFF0C2"
    - color: "#FFFFC2"
    - color: "#F0FFC2"
    - color: "#E0FFC2"
    - color: "#D1FFC2"
    - color: "#C2FFC2"
    - color: "#C2FFD1"
    - color: "#C2FFE0"
    - color: "#C2FFF0"
    - color: "#C2FFFF"
    - color: "#C2F0FF"
    - color: "#C2E0FF"
    - color: "#C2D1FF"
    - color: "#C2C2FF"
    - color: "#D1C2FF"
    - color: "#E0C2FF"
    - color: "#F0C2FF"
    - color: "#FFC2FF"
    - color: "#FFC2F0"
    - color: "#FFC2E0"
    - color: "#FFC2D1"
    - label: "88x"
  row_3:
    - label: "80x"
    - color: "#CCCCCC"
    - color: "#FF9999"
    - color: "#FFB399"
    - color: "#FFCC99"
    - color: "#FFE599"
    - color: "#FFFF99"
    - color: "#E5FF99"
    - color: "#CCFF99"
    - color: "#B2FF99"
    - color: "#99FF99"
    - color: "#99FFB3"
    - color: "#99FFCC"
    - color: "#99FFE5"
    - color: "#99FFFF"
    - color: "#99E5FF"
    - color: "#99CCFF"
    - color: "#99B2FF"
    - color: "#9999FF"
    - color: "#B399FF"
    - color: "#CC99FF"
    - color: "#E599FF"
    - color: "#FF99FF"
    - color: "#FF99E5"
    - color: "#FF99CC"
    - color: "#FF99B2"
    - label: "80x"
  row_4:
    - label: "64x"
    - color: "#A3A3A3"
    - color: "#FF4747"
    - color: "#FF7547"
    - color: "#FFA347"
    - color: "#FFD147"
    - color: "#FFFF47"
    - color: "#D1FF47"
    - color: "#A3FF47"
    - color: "#75FF47"
    - color: "#47FF47"
    - color: "#47FF75"
    - color: "#47FFA3"
    - color: "#47FFD1"
    - color: "#47FFFF"
    - color: "#47D1FF"
    - color: "#47A3FF"
    - color: "#4775FF"
    - color: "#4747FF"
    - color: "#7547FF"
    - color: "#A347FF"
    - color: "#D147FF"
    - color: "#FF47FF"
    - color: "#FF47D1"
    - color: "#FF47A3"
    - color: "#FF4775"
    - label: "64x"
  row_5:
    - label: "48x"
    - color: "#7A7A7A"
    - color: "#B54040"
    - color: "#B55D40"
    - color: "#B57A40"
    - color: "#B59840"
    - color: "#B5B540"
    - color: "#98B540"
    - color: "#7AB540"
    - color: "#5DB540"
    - color: "#40B540"
    - color: "#40B55D"
    - color: "#40B57A"
    - color: "#40B598"
    - color: "#40B5B5"
    - color: "#4098B5"
    - color: "#407AB5"
    - color: "#405DB5"
    - color: "#4040B5"
    - color: "#5D40B5"
    - color: "#7A40B5"
    - color: "#9840B5"
    - color: "#B540B5"
    - color: "#B54098"
    - color: "#B5407A"
    - color: "#B5405D"
    - label: "48x"
  row_6:
    - label: "32x"
    - color: "#525252"
    - color: "#792A2A"
    - color: "#793E2A"
    - color: "#79522A"
    - color: "#79652A"
    - color: "#79792A"
    - color: "#65792A"
    - color: "#52792A"
    - color: "#3E792A"
    - color: "#2A792A"
    - color: "#2A793E"
    - color: "#2A7952"
    - color: "#2A7965"
    - color: "#2A7979"
    - color: "#2A6579"
    - color: "#2A5279"
    - color: "#2A3E79"
    - color: "#2A2A79"
    - color: "#3E2A79"
    - color: "#522A79"
    - color: "#652A79"
    - color: "#792A79"
    - color: "#792A65"
    - color: "#792A52"
    - color: "#792A3E"
    - label: "32x"
  row_7:
    - label: "24x"
    - color: "#3D3D3D"
    - color: "#5B2020"
    - color: "#5B2F20"
    - color: "#5B3D20"
    - color: "#5B4C20"
    - color: "#5B5B20"
    - color: "#4C5B20"
    - color: "#3D5B20"
    - color: "#2F5B20"
    - color: "#205B20"
    - color: "#205B2F"
    - color: "#205B3D"
    - color: "#205B4C"
    - color: "#205B5B"
    - color: "#204C5B"
    - color: "#203D5B"
    - color: "#202F5B"
    - color: "#20205B"
    - color: "#2F205B"
    - color: "#3D205B"
    - color: "#4C205B"
    - color: "#5B205B"
    - color: "#5B204C"
    - color: "#5B203D"
    - color: "#5B202F"
    - label: "24x"
  row_8:
    - label: "16x"
    - color: "#292929"
    - color: "#3C1515"
    - color: "#3C1F15"
    - color: "#3C2915"
    - color: "#3C3315"
    - color: "#3C3C15"
    - color: "#333C15"
    - color: "#293C15"
    - color: "#1F3C15"
    - color: "#153C15"
    - color: "#153C1F"
    - color: "#153C29"
    - color: "#153C33"
    - color: "#153C3C"
    - color: "#15333C"
    - color: "#15293C"
    - color: "#151F3C"
    - color: "#15153C"
    - color: "#1F153C"
    - color: "#29153C"
    - color: "#33153C"
    - color: "#3C153C"
    - color: "#3C1533"
    - color: "#3C1529"
    - color: "#3C151F"
    - label: "16x"
  row_9:
    - label: "12x"
    - color: "#1F1F1F"
    - color: "#2D1010"
    - color: "#2D1710"
    - color: "#2D1F10"
    - color: "#2D2610"
    - color: "#2D2D10"
    - color: "#262D10"
    - color: "#1F2D10"
    - color: "#172D10"
    - color: "#102D10"
    - color: "#102D17"
    - color: "#102D1F"
    - color: "#102D26"
    - color: "#102D2D"
    - color: "#10262D"
    - color: "#101F2D"
    - color: "#10172D"
    - color: "#10102D"
    - color: "#17102D"
    - color: "#1F102D"
    - color: "#26102D"
    - color: "#2D102D"
    - color: "#2D1026"
    - color: "#2D101F"
    - color: "#2D1017"
    - label: "12x"
  row_10:
    - label: "8x"
    - color: "#141414"
    - color: "#1E0B0B"
    - color: "#1E100B"
    - color: "#1E140B"
    - color: "#1E190B"
    - color: "#1E1E0B"
    - color: "#191E0B"
    - color: "#141E0B"
    - color: "#101E0B"
    - color: "#0B1E0B"
    - color: "#0B1E10"
    - color: "#0B1E14"
    - color: "#0B1E19"
    - color: "#0B1E1E"
    - color: "#0B191E"
    - color: "#0B141E"
    - color: "#0B101E"
    - color: "#0B0B1E"
    - color: "#100B1E"
    - color: "#140B1E"
    - color: "#190B1E"
    - color: "#1E0B1E"
    - color: "#1E0B19"
    - color: "#1E0B14"
    - color: "#1E0B10"
    - label: "8x"
  row_11:
    - label: "0x"
    - color: "#000000"
    - label: "0"
    - label: "15"
    - label: "30"
    - label: "45"
    - label: "60"
    - label: "75"
    - label: "90"
    - label: "105"
    - label: "120"
    - label: "135"
    - label: "150"
    - label: "165"
    - label: "180"
    - label: "195"
    - label: "210"
    - label: "225"
    - label: "240"
    - label: "255"
    - label: "270"
    - label: "285"
    - label: "300"
    - label: "315"
    - label: "330"
    - label: "345"
    - label: "0x"

metadata:
  version: "1.0"
  description: "Default minimalist color palette"
`;

// Load default palette from YAML
let sourceGridData = convertYAMLToGrid(defaultPaletteYAML) || [];

// --- State Variables ---
let currentGridData = [...sourceGridData.map((row) => [...row])];
let isInterpolationEnabled = false;
let interpolationSteps = 1;
let saturationOffset = 0;
// --- Panning State --- // Renamed for clarity
let isPanning = false;
let startX, startY, currentX, currentY;
let paletteOffsetX = 50; // Initial offset matches CSS
let paletteOffsetY = 50;
// --- Zoom State ---
let scale = 1; // Default scale is 1
const minScale = 0.1;
const maxScale = 5;
const scaleStep = 0.1;
const zoomDebounceDelay = 10; // Optional: debounce zoom updates slightly
let zoomTimeout;
// --- Click vs Drag State --- // Renamed for clarity
const dragThreshold = 5; // Pixels to differentiate click from drag
let pointerHasMoved = false; // Renamed from mouseHasMoved
let pointerDownPos = { x: 0, y: 0 }; // Renamed from mouseDownPos
// --- NEW: Flag to track if touch event handled the action ---
let touchEventHandled = false;
// --- NEW: Touch Device Detection ---
const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
// --- Local Storage Key ---
const localStorageKey = "minimalistPaletteAppState";
// --- Color Picker State ---
let pickerTargetRow = -1;
let pickerTargetCol = -1;
let isPickerUpdating = false; // Prevent recursive updates
// --- NEW: Color Picker Drag/Resize State ---
let isDraggingColorPicker = false;
let pickerStartX, pickerStartY, pickerInitialX, pickerInitialY;
let isResizingColorPicker = false;
let cpResizeStartX, cpResizeStartY, cpResizeInitialWidth, cpResizeInitialHeight;
// --- NEW: Color Picking Mode State ---
let isColorPickingMode = false;
// ... existing variables ...
let selectedCells = []; // NEW: Array to store [row, col] of selected cells
const multiSelectTolerance = 2; // NEW: Tolerance for S/L matching
// --- NEW: Hue Tolerance ---
const multiSelectHueTolerance = 2; // Degrees (+/-) for enabling Hue batch edit
// --- NEW: Anchor for range selection ---
let selectionAnchor = null; // Stores [row, col] of the first cell clicked
// --- NEW: Flag for state loading ---
let stateLoadedSuccessfully = false;

// --- DOM Elements ---
// Palette display elements
const canvasViewport = document.getElementById("canvas-viewport");
const paletteContainer = document.getElementById("palette-container");
const paletteGrid = document.getElementById("palette-grid"); // New grid reference

// Config Modal elements
const configToggleButton = document.getElementById("config-toggle-button");
const configModal = document.getElementById("config-modal");
const closeModalButton = configModal.querySelector(".modal-close-button"); // Find close button inside modal
const editPaletteButton = document.getElementById("edit-palette-button");
const paletteEditorSection = document.getElementById("palette-editor-section");
const paletteInput = document.getElementById("palette-input");
const updateButton = document.getElementById("update-button");
const exportPngButton = document.getElementById("export-png-button");
const exportScaleInput = document.getElementById("export-scale-input"); // NEW: Export Scale Input
const resetViewButton = document.getElementById("reset-view-button"); // NEW: Reset View Button

// Adjustment controls (now inside modal)
const interpolationToggle = document.getElementById("interpolation-toggle");
const interpolationStepsGroup = document.getElementById(
  "interpolation-steps-group",
);
const stepsSlider = document.getElementById("interpolation-steps-slider");
const stepsNumber = document.getElementById("interpolation-steps-number");
const saturationOffsetSlider = document.getElementById(
  "saturation-offset-slider",
);
const saturationOffsetNumber = document.getElementById(
  "saturation-offset-number",
);

// --- NEW: Zoom Controls Elements --- REMOVED zoomSlider
const zoomSlider = document.getElementById("zoom-slider"); // Restore reference
const zoomNumber = document.getElementById("zoom-number");

// --- NEW: UI Scale Controls Elements --- REMOVED uiScaleSlider
// const uiScaleSlider = document.getElementById('ui-scale-slider');
const uiScaleNumber = document.getElementById("ui-scale-number");

// --- NEW: Generate X Row Elements ---
const generateXValueInput = document.getElementById("generate-x-value");
const generateRef1ValueInput = document.getElementById("generate-ref1-value"); // New Ref 1 Input
const generateRef2ValueInput = document.getElementById("generate-ref2-value"); // New Ref 2 Input
const generateXButton = document.getElementById("generate-x-button");

// --- NEW: Popout Editor Elements ---
const popoutEditor = document.getElementById("popout-editor");
const popoutHeader = popoutEditor.querySelector(".popout-header");
const popoutCloseButton = document.getElementById("popout-close-button");
const popoutPaletteInput = document.getElementById("popout-palette-input");
const popoutUpdateButton = document.getElementById("popout-update-button");
const popoutResizeHandle = document.getElementById("popout-resize-handle"); // NEW: Resize Handle
const popoutStatusMessage = document.getElementById("popout-status-message"); // NEW

// --- NEW: State Management Buttons ---
const saveStateButton = document.getElementById("save-state-button");
const resetStateButton = document.getElementById("reset-state-button");

// --- NEW: Palette Import/Export Elements ---
const exportPaletteButton = document.getElementById("export-palette-button");
const importPaletteButton = document.getElementById("import-palette-button");
const importPaletteFileInput = document.getElementById(
  "import-palette-file-input",
);
const stateTimestampDiv = document.getElementById("state-timestamp");

// --- NEW: Color Picker Modal Elements ---
const colorPickerModal = document.getElementById("color-picker-modal");
const colorPickerCloseButton = document.getElementById(
  "color-picker-close-button",
);
const colorPickerPreview = document.getElementById("color-picker-preview");
const pickerHueSlider = document.getElementById("picker-hue-slider");
const pickerHueNumber = document.getElementById("picker-hue-number");
const pickerSatSlider = document.getElementById("picker-sat-slider");
const pickerSatNumber = document.getElementById("picker-sat-number");
const pickerLumSlider = document.getElementById("picker-lum-slider");
const pickerLumNumber = document.getElementById("picker-lum-number");
const pickerHexInput = document.getElementById("picker-hex-input");
const pickerCopyHexButton = document.getElementById("picker-copy-hex-button");
const pickerCancelButton = document.getElementById("picker-cancel-button");
const pickerApplyButton = document.getElementById("picker-apply-button");
// --- NEW: Color Pick Toggle Button Element ---
const colorPickToggleButton = document.getElementById(
  "color-pick-toggle-button",
);
const colorPickerHeader = colorPickerModal.querySelector(
  ".color-picker-header",
); // NEW: Header ref
const colorPickerResizeHandle = document.getElementById(
  "color-picker-resize-handle",
); // NEW: Resize handle ref

// --- NEW: Tooltip DOM Elements ---
const paletteTooltip = document.getElementById("palette-tooltip");
const tooltipHexValue = paletteTooltip.querySelector("#tooltip-hex span");
const tooltipHslValue = paletteTooltip.querySelector("#tooltip-hsl span");
const tooltipRgbValue = paletteTooltip.querySelector("#tooltip-rgb span");

// --- NEW: Global state for tooltip interaction ---
let isShiftHeld = false;
let isMouseOverTooltip = false;
let allowTooltipInteraction = false; // Flag to allow mouse to move to tooltip
let currentTooltipTargetCell = null; // Keep track of the cell that triggered the tooltip

// --- Helper Functions ---
function isValidHex(str) {
  return (
    typeof str === "string" &&
    str.startsWith("#") &&
    (str.length === 4 || str.length === 7) &&
    /^#[0-9A-Fa-f]+$/.test(str)
  );
}

// --- YAML Conversion Functions ---
function convertGridToYAML(gridData) {
  let yaml = "palette:\n";
  gridData.forEach((row, rowIndex) => {
    yaml += `  row_${rowIndex}:\n`;
    row.forEach((cell, cellIndex) => {
      if (isValidHex(cell)) {
        yaml += `    - color: "${cell}"\n`;
      } else {
        yaml += `    - label: "${cell}"\n`;
      }
    });
  });
  yaml += "\nmetadata:\n";
  yaml += `  timestamp: "${new Date().toISOString()}"\n`;
  yaml += `  version: "1.0"\n`;
  return yaml;
}

function convertYAMLToGrid(yamlString) {
  try {
    // Simple YAML parser for our specific format
    const lines = yamlString.split("\n");
    const gridData = [];
    let currentRow = null;

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed === "palette:" || trimmed.startsWith("metadata:"))
        continue;

      // Check if this is a row declaration
      if (trimmed.startsWith("row_")) {
        if (currentRow !== null) {
          gridData.push(currentRow);
        }
        currentRow = [];
      }
      // Check if this is a cell
      else if (trimmed.startsWith("- ")) {
        if (currentRow === null) continue;

        // Extract color or label
        const colorMatch = trimmed.match(/- color: "([^"]+)"/);
        const labelMatch = trimmed.match(/- label: "([^"]+)"/);

        if (colorMatch) {
          currentRow.push(colorMatch[1]);
        } else if (labelMatch) {
          currentRow.push(labelMatch[1]);
        }
      }
    }

    // Don't forget the last row
    if (currentRow !== null && currentRow.length > 0) {
      gridData.push(currentRow);
    }

    return gridData;
  } catch (error) {
    console.error("Error parsing YAML:", error);
    return null;
  }
}
function hexToRgb(hex) {
  let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
  let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
      }
    : null;
}
function componentToHex(c) {
  let hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
function interpolateHexColor(hex1, hex2, steps) {
  const rgb1 = hexToRgb(hex1);
  const rgb2 = hexToRgb(hex2);
  if (!rgb1 || !rgb2) return []; // Invalid input

  const interpolatedColors = [];
  const totalIntervals = steps + 1;

  for (let i = 1; i <= steps; i++) {
    const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * (i / totalIntervals));
    const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * (i / totalIntervals));
    const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * (i / totalIntervals));
    interpolatedColors.push(rgbToHex(r, g, b));
  }
  return interpolatedColors;
}

// --- REVISED: HSL Conversion and Adjustment ---
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  let h = 0,
    s = 0,
    l = (max + min) / 2; // Initialize h

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  // Return h in degrees (0-360), s and l in percent (0-100)
  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    l: Math.round(l * 100),
  };
}

function hslToRgb(h, s, l) {
  // Convert h, s, l from picker range (0-360, 0-100, 0-100) to calculation range (0-1, 0-1, 0-1)
  h /= 360;
  s /= 100;
  l /= 100;
  let r, g, b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
  };
}

// --- NEW: Combined Converters for Picker ---
function hexToHsl(hex) {
  const rgb = hexToRgb(hex);
  return rgb ? rgbToHsl(rgb.r, rgb.g, rgb.b) : null; // Returns h(0-360), s(0-100), l(0-100)
}

function hslToHex(h, s, l) {
  const rgb = hslToRgb(h, s, l);
  return rgbToHex(rgb.r, rgb.g, rgb.b);
}

function adjustSaturation(hexColor, offsetPercent) {
  const rgb = hexToRgb(hexColor);
  if (!rgb) return hexColor;

  const hslRaw = rgbToHslRaw(rgb.r, rgb.g, rgb.b); // Use raw HSL (0-1 range)

  const saturationThreshold = 0.01;
  if (hslRaw.s < saturationThreshold) {
    return hexColor;
  }

  const offset = offsetPercent / 100;
  hslRaw.s = Math.max(0, Math.min(1, hslRaw.s + offset)); // Clamp between 0 and 1

  const newRgb = hslToRgbRaw(hslRaw.h, hslRaw.s, hslRaw.l); // Use raw HSL
  return rgbToHex(newRgb.r, newRgb.g, newRgb.b);
}

// Keep original HSL calculation helpers for adjustSaturation (operating on 0-1 range)
function rgbToHslRaw(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  let h = 0,
    s = 0,
    l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, l }; // h, s, l are in [0, 1] range
}
function hslToRgbRaw(h, s, l) {
  let r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
  };
}

// NEW: Function to parse 'x' value from labels like '100x'
function parseXValue(label) {
  if (typeof label !== "string" || !label.endsWith("x")) {
    return null;
  }
  const numPart = label.substring(0, label.length - 1);
  const value = parseInt(numPart, 10);
  return isNaN(value) ? null : value;
}

// NEW: Interpolate RGB (moved out from hex interpolation for reuse)
function interpolateRgb(rgb1, rgb2, t) {
  const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);
  const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);
  const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);
  return { r, g, b };
}

// NEW Helper to get coordinates from mouse or touch events
function getEventCoords(event) {
  if (event.touches && event.touches.length > 0) {
    return { x: event.touches[0].clientX, y: event.touches[0].clientY };
  } else {
    return { x: event.clientX, y: event.clientY };
  }
}

// --- NEW: UI Scale Function --- (UPDATED)
function applyUiScale(scalePercent) {
  const scaleValue = Math.max(50, Math.min(200, scalePercent)) / 100; // Clamp 50-200%, convert to 0.5-2.0
  document.documentElement.style.fontSize = `${10 * scaleValue}px`;
  console.log(
    `UI Scale set to ${scalePercent}% (root font size: ${10 * scaleValue}px)`,
  );

  // Update number input ONLY if called externally (less likely now)
  if (uiScaleNumber.value !== String(scalePercent)) {
    uiScaleNumber.value = scalePercent;
  }
  // REMOVED Slider sync
  // if (uiScaleSlider.value !== String(scalePercent)) {
  //     uiScaleSlider.value = scalePercent;
  // }
}

// --- Core Logic ---

// Generate a new grid with vertically interpolated colors (inserts rows)
function generateInterpolatedPalette(originalData, steps) {
  if (steps <= 0) return originalData.map((row) => [...row]); // Return a copy

  const newGridData = [];
  if (!originalData || originalData.length === 0) return newGridData;

  const numCols = originalData[0].length;

  // Add the top header row (Row 0)
  newGridData.push([...originalData[0]]);

  // Iterate through original rows, checking pairs for interpolation
  // Skip first (header) and last (footer) rows for starting interpolation
  for (let i = 1; i < originalData.length - 2; i++) {
    const currentRow = originalData[i];
    const nextRow = originalData[i + 1];

    // Add the current original row to the new grid
    newGridData.push([...currentRow]);

    // Prepare arrays to hold interpolated colors for each step (new row)
    const interpolatedRowsData = Array.from({ length: steps }, () =>
      new Array(numCols).fill(""),
    );

    let canInterpolateRowPair = false; // Can we interpolate between row i and i+1?

    // Iterate through columns (excluding first and last label columns)
    for (let j = 1; j < numCols - 1; j++) {
      const cell1 = currentRow[j];
      const cell2 = nextRow[j];

      // Check if BOTH cells in the column are valid hex colors
      if (isValidHex(cell1) && isValidHex(cell2)) {
        canInterpolateRowPair = true; // Found a column to interpolate
        const interpolatedColors = interpolateHexColor(cell1, cell2, steps);

        // Place interpolated colors into the corresponding step's row data
        for (let s = 0; s < steps; s++) {
          interpolatedRowsData[s][j] = interpolatedColors[s];
        }
      } else {
        // If not interpolating this column, fill placeholder rows with empty strings
        for (let s = 0; s < steps; s++) {
          interpolatedRowsData[s][j] = ""; // Keep empty or copy label? Empty is simpler.
        }
      }
    }

    // If interpolation was possible between these rows, add the new rows
    if (canInterpolateRowPair) {
      interpolatedRowsData.forEach((newRowData) => {
        // Add placeholders for first/last column labels in the new rows
        newRowData[0] = "-"; // Placeholder for left label
        newRowData[newRowData.length - 1] = "-"; // Placeholder for right label
        newGridData.push(newRowData);
      });
    }
  }

  // Add the second to last original row (which was skipped in the loop)
  if (originalData.length > 2) {
    newGridData.push([...originalData[originalData.length - 2]]);
  }
  // Add the last original row (bottom labels/colors)
  if (originalData.length > 1) {
    newGridData.push([...originalData[originalData.length - 1]]);
  }

  return newGridData;
}

function convertToSimpleFormat(gridData) {
  return gridData.map((row) => row.join(" ")).join("\n");
}
function parseSimpleFormat(textData) {
  const lines = textData.trim().split("\n");
  return lines.map((line) => {
    return line
      .trim()
      .split(" ")
      .filter((cell) => cell !== "");
  });
}
function getTextColor(hexBgColor) {
  if (!hexBgColor || typeof hexBgColor !== "string") return "#000000"; // Default to black
  const rgb = hexToRgb(hexBgColor);
  if (!rgb) return "#000000"; // Default to black on error
  // Calculate luminance (per WCAG)
  const lum = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b) / 255;
  // Return pure white or black for maximum contrast
  return lum > 0.5 ? "#000000" : "#FFFFFF";
}
async function copyToClipboard(text, element) {
  if (!navigator.clipboard) {
    try {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.position = "fixed";
      textArea.style.opacity = "0";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
      // Use showCopiedFeedback for general elements, or custom for tooltip spans
      if (element && element.classList.contains("cell-content")) {
        showCopiedFeedback(element);
      } else if (element) {
        // For tooltip spans
        const originalText = element.textContent;
        element.textContent = "Copied!";
        setTimeout(() => {
          element.textContent = originalText;
        }, 1000);
      }
    } catch (err) {
      console.error("Fallback copy failed: ", err);
      alert(
        "Failed to copy. Your browser might not support this feature or require specific permissions.",
      );
    }
    return;
  }
  try {
    await navigator.clipboard.writeText(text);
    // Use showCopiedFeedback for general elements, or custom for tooltip spans
    if (element && element.classList.contains("cell-content")) {
      showCopiedFeedback(element);
    } else if (element) {
      // For tooltip spans
      const originalText = element.textContent;
      element.textContent = "Copied!";
      setTimeout(() => {
        element.textContent = originalText;
      }, 1000);
    }
  } catch (err) {
    console.error("Failed to copy text: ", err);
    alert("Failed to copy.");
  }
}
function showCopiedFeedback(element) {
  element.classList.add("copied");
  setTimeout(() => element.classList.remove("copied"), 1000);
}

// --- NEW: Palette Tooltip Functions ---
function updateAndShowPaletteTooltip(hexColor, event, cellElement) {
  if (
    !paletteTooltip ||
    !isValidHex(hexColor) ||
    !tooltipHexValue ||
    !tooltipHslValue ||
    !tooltipRgbValue
  ) {
    hidePaletteTooltip();
    return;
  }
  currentTooltipTargetCell = cellElement; // Store the triggering cell

  const hsl = hexToHsl(hexColor);
  const rgb = hexToRgb(hexColor);

  tooltipHexValue.textContent = hexColor.toUpperCase();
  if (hsl) {
    tooltipHslValue.textContent = `H:${hsl.h}° S:${hsl.s}% L:${hsl.l}%`;
  } else {
    tooltipHslValue.textContent = "N/A";
  }
  if (rgb) {
    tooltipRgbValue.textContent = `R:${rgb.r} G:${rgb.g} B:${rgb.b}`;
  } else {
    tooltipRgbValue.textContent = "N/A";
  }

  // Get the bounding rect of the cell element to position tooltip relative to it
  const cellRect = cellElement.getBoundingClientRect();
  const offsetX = 15; // Offset from cell
  const offsetY = 15;

  // Position tooltip relative to the cell's screen position
  let newLeft = cellRect.right + offsetX;
  let newTop = cellRect.top + offsetY;

  paletteTooltip.style.display = "block"; // Display first to measure

  // Adjust if tooltip would go off screen
  if (newLeft + paletteTooltip.offsetWidth > window.innerWidth) {
    newLeft = cellRect.left - paletteTooltip.offsetWidth - offsetX;
  }
  if (newTop + paletteTooltip.offsetHeight > window.innerHeight) {
    newTop = cellRect.top - paletteTooltip.offsetHeight - offsetY;
  }

  newLeft = Math.max(0, newLeft);
  newTop = Math.max(0, newTop);

  paletteTooltip.style.left = `${newLeft}px`;
  paletteTooltip.style.top = `${newTop}px`;

  if (isShiftHeld) {
    paletteTooltip.classList.add("palette-tooltip--interactive");
    allowTooltipInteraction = true;
  } else {
    paletteTooltip.classList.remove("palette-tooltip--interactive");
    allowTooltipInteraction = false;
  }

  requestAnimationFrame(() => {
    paletteTooltip.style.opacity = "1";
  });
}

function hidePaletteTooltip() {
  if (paletteTooltip) {
    // If shift is held and mouse is over tooltip, don't hide
    if (isShiftHeld && isMouseOverTooltip && allowTooltipInteraction) {
      return;
    }
    paletteTooltip.style.opacity = "0";
    paletteTooltip.classList.remove("palette-tooltip--interactive");
    allowTooltipInteraction = false;
    currentTooltipTargetCell = null;
    setTimeout(() => {
      if (paletteTooltip.style.opacity === "0") {
        paletteTooltip.style.display = "none";
      }
    }, 150);
  }
}

// --- NEW: Tooltip Interaction Handlers ---
document.addEventListener("keydown", (event) => {
  if (event.key === "Shift") {
    isShiftHeld = true;
    // If tooltip is visible (meaning mouse is likely over a swatch or was just now)
    // make it interactive.
    if (paletteTooltip.style.display === "block" && currentTooltipTargetCell) {
      paletteTooltip.classList.add("palette-tooltip--interactive");
      allowTooltipInteraction = true;
    }
  }

  // Hotkey logic for copying from tooltip (1: HEX, 2: HSL, 3: RGB)
  const activeElement = document.activeElement;
  const isTyping =
    activeElement &&
    (activeElement.tagName === "INPUT" ||
      activeElement.tagName === "TEXTAREA" ||
      activeElement.isContentEditable);

  // Check if tooltip is visible over a cell AND not typing in an input
  // Allow keybind copy if we have a target cell, even if tooltip isn't visible
  // This fixes the zoom issue where tooltip might be hidden but we still want to copy
  if (!isTyping && currentTooltipTargetCell) {
    let textToCopy = null;
    let copyTypeForLog = ""; // For logging purposes

    if (event.key === "1" || event.key === "2" || event.key === "3") {
      // Prevent default browser action for these keys if any (e.g. navigating history)
      event.preventDefault();

      switch (event.key) {
        case "1": // HEX
          textToCopy = tooltipHexValue.textContent;
          copyTypeForLog = "HEX";
          break;
        case "2": // HSL
          textToCopy = tooltipHslValue.textContent; // Full string "H:X° S:Y% L:Z%"
          copyTypeForLog = "HSL";
          break;
        case "3": // RGB
          const rgbFullText = tooltipRgbValue.textContent; // "R:X G:Y B:Z"
          const rgbMatch = rgbFullText.match(
            /R:(\d{1,3})\s*G:(\d{1,3})\s*B:(\d{1,3})/,
          );
          if (rgbMatch) {
            textToCopy = `${rgbMatch[1]},${rgbMatch[2]},${rgbMatch[3]}`; // "X,Y,Z"
            copyTypeForLog = "RGB";
          } else {
            console.warn(
              "Could not parse RGB from tooltip for hotkey copy:",
              rgbFullText,
            );
          }
          break;
      }

      if (textToCopy) {
        const cellDiv = currentTooltipTargetCell;

        navigator.clipboard
          .writeText(textToCopy)
          .then(() => {
            showCopiedFeedback(cellDiv); // Use existing feedback function
            console.log(
              `${copyTypeForLog} value copied via hotkey: ${textToCopy}`,
            );
          })
          .catch((err) => {
            console.error(`Hotkey copy for ${copyTypeForLog} failed: `, err);
            alert("Failed to copy."); // Use existing failure feedback
          });
      }
    }
  }
});

document.addEventListener("keyup", (event) => {
  if (event.key === "Shift") {
    isShiftHeld = false;
    // If mouse is not over the tooltip when shift is released, hide it.
    if (!isMouseOverTooltip) {
      hidePaletteTooltip();
    }
    // Tooltip might still be interactive if mouse is over it,
    // but general interaction allowance is reset.
    // The 'palette-tooltip--interactive' class will be removed by hidePaletteTooltip
    // or when mouse leaves tooltip.
    allowTooltipInteraction = false;
    // If mouse IS over tooltip, it remains visible but non-interactive style is reapplied on mouseleave
    if (isMouseOverTooltip && paletteTooltip.style.display === "block") {
      paletteTooltip.classList.remove("palette-tooltip--interactive");
    }
  }
});

paletteTooltip.addEventListener("mouseenter", () => {
  isMouseOverTooltip = true;
  if (isShiftHeld) {
    // Keep it interactive if shift is still held
    paletteTooltip.classList.add("palette-tooltip--interactive");
    allowTooltipInteraction = true;
  }
});

paletteTooltip.addEventListener("mouseleave", () => {
  isMouseOverTooltip = false;
  // If shift is not held, hide the tooltip when mouse leaves it.
  if (!isShiftHeld) {
    hidePaletteTooltip();
  }
  // Always remove interactive class if mouse leaves, shift release will handle full hide.
  paletteTooltip.classList.remove("palette-tooltip--interactive");
});

function handleTooltipCopy(event) {
  const targetSpan = event.target.closest("span[data-copy-type]");
  if (!targetSpan || !allowTooltipInteraction) return;

  const copyType = targetSpan.dataset.copyType;
  let textToCopy = "";

  // Reconstruct the text based on type, as spans only hold the value part
  const hex = tooltipHexValue.textContent;
  const hslFull = tooltipHslValue.textContent; // e.g., "H:X° S:Y% L:Z%"
  const rgbFull = tooltipRgbValue.textContent; // e.g., "R:X G:Y B:Z"

  switch (copyType) {
    case "hex":
      textToCopy = hex;
      break;
    case "hsl":
      textToCopy = hslFull; // Copy the full HSL string
      break;
    case "rgb":
      textToCopy = rgbFull; // Copy the full RGB string
      break;
  }

  if (textToCopy) {
    copyToClipboard(textToCopy, targetSpan); // Pass targetSpan for feedback
    // Optionally hide tooltip after copy
    setTimeout(() => {
      hidePaletteTooltip();
    }, 1100); // Hide after "Copied!" message fades
  }
}

[tooltipHexValue, tooltipHslValue, tooltipRgbValue].forEach((span) => {
  span.addEventListener("click", handleTooltipCopy);
  // For keyboard accessibility (Enter key)
  span.addEventListener("keydown", (event) => {
    if (event.key === "Enter") {
      handleTooltipCopy(event);
    }
  });
});

// --- Core Logic ---

// Render the palette grid from grid data
function renderPalette(gridData) {
  paletteGrid.innerHTML = ""; // Clear previous grid content
  if (!Array.isArray(gridData)) {
    console.error("Invalid grid data: not an array");
    return;
  }

  gridData.forEach((rowData, rowIndex) => {
    if (!Array.isArray(rowData)) {
      console.warn(`Skipping invalid row ${rowIndex}`);
      return;
    }

    rowData.forEach((cellData, cellIndex) => {
      const cellContentDiv = document.createElement("div");
      cellContentDiv.classList.add("cell-content");
      paletteGrid.appendChild(cellContentDiv);

      const isInterpolatedLabelPlaceholder = cellData === "-";
      // Add data attributes for easy access to coordinates
      cellContentDiv.dataset.rowIndex = rowIndex;
      cellContentDiv.dataset.cellIndex = cellIndex;

      if (isValidHex(cellData)) {
        const originalHexColor = cellData; // Use current cell data for display
        // Apply saturation offset *only for display* if needed
        const adjustedHexColor = adjustSaturation(
          originalHexColor,
          saturationOffset,
        );
        const adjustedHexText = adjustedHexColor.substring(1).toUpperCase();
        const textColor = getTextColor(adjustedHexColor);

        cellContentDiv.style.backgroundColor = adjustedHexColor;
        cellContentDiv.textContent = adjustedHexText;
        cellContentDiv.style.color = textColor;
        cellContentDiv.classList.add("swatch");
        // Store original hex from source data if applicable (check bounds)
        if (
          rowIndex < sourceGridData.length &&
          cellIndex < sourceGridData[rowIndex].length
        ) {
          cellContentDiv.dataset.sourceHex =
            sourceGridData[rowIndex][cellIndex];
        } else {
          cellContentDiv.dataset.sourceHex = originalHexColor; // Fallback for generated/interpolated
        }

        // --- Tooltip Listeners ---
        cellContentDiv.addEventListener("mouseenter", (event) => {
          const hexForTooltip =
            cellContentDiv.dataset.sourceHex || originalHexColor;
          if (isValidHex(hexForTooltip)) {
            // Pass the cellContentDiv as the third argument
            updateAndShowPaletteTooltip(hexForTooltip, event, cellContentDiv);
          }
        });

        cellContentDiv.addEventListener("mouseleave", () => {
          // If allowTooltipInteraction is true, it means Shift was held
          // when the tooltip became active for this cell. The user might be
          // trying to move their mouse to the tooltip. So, don't hide it here.
          // Hiding will be handled by Shift keyup or tooltip's own mouseleave.
          if (allowTooltipInteraction) {
            return;
          }

          // If not allowing interaction (e.g., Shift not held) and the mouse
          // is not currently over the tooltip itself, then hide it.
          if (!isMouseOverTooltip) {
            hidePaletteTooltip();
          }
        });

        cellContentDiv.addEventListener("mousemove", (event) => {
          // Only update position if tooltip is block
          if (paletteTooltip && paletteTooltip.style.display === "block") {
            // If interaction is allowed AND mouse is NOT YET over the tooltip,
            // it means Shift is held and mouse is still over the swatch.
            // Tooltip should still follow the mouse over the swatch.
            // updateAndShowPaletteTooltip handles setting/removing interactive class.
            if (allowTooltipInteraction && !isMouseOverTooltip) {
              const hexForTooltip =
                cellContentDiv.dataset.sourceHex || originalHexColor;
              if (isValidHex(hexForTooltip)) {
                updateAndShowPaletteTooltip(
                  hexForTooltip,
                  event,
                  cellContentDiv,
                );
              }
            }
            // If interaction is NOT allowed, tooltip simply follows mouse over swatch.
            else if (!allowTooltipInteraction) {
              const hexForTooltip =
                cellContentDiv.dataset.sourceHex || originalHexColor;
              if (isValidHex(hexForTooltip)) {
                updateAndShowPaletteTooltip(
                  hexForTooltip,
                  event,
                  cellContentDiv,
                );
              }
            }
            // If allowTooltipInteraction is true AND isMouseOverTooltip is true,
            // then the mouse is over the tooltip, and this swatch's mousemove
            // should not interfere with its position.
          }
        });
        // --- END Tooltip Listeners ---

        // --- Touch End Listener (Handles Touch Selection/Picking) ---
        if (isTouchDevice) {
          cellContentDiv.addEventListener(
            "touchend",
            (event) => {
              // Prevent default behavior that might follow touchend (like triggering click immediately or zoom)
              // event.preventDefault(); // Might be needed, test carefully

              // If pointer moved significantly, it was a pan ending on this cell, ignore tap
              if (pointerHasMoved) {
                // console.log("TouchEnd ignored due to pointer move.");
                touchEventHandled = false; // Ensure flag is reset if ignored
                return;
              }

              // If not in color picking mode, or if interpolation is on, let click handler deal with copy
              if (!isColorPickingMode || isInterpolationEnabled) {
                touchEventHandled = false; // Let click handler proceed for copy/selection
                return; // Or handle single tap copy explicitly here? For now, let it fall through
              }

              // --- Handle Touch Selection (Tap-Tap Range) ---
              const touchRowIndex = parseInt(
                cellContentDiv.dataset.rowIndex,
                10,
              );
              const touchCellIndex = parseInt(
                cellContentDiv.dataset.cellIndex,
                10,
              );

              // Validate coordinates against sourceGridData
              if (
                touchRowIndex >= sourceGridData.length ||
                touchCellIndex >= sourceGridData[touchRowIndex].length ||
                !isValidHex(sourceGridData[touchRowIndex][touchCellIndex])
              ) {
                console.warn(
                  "TouchEnd on invalid cell or outside source data bounds.",
                );
                clearSelection(); // Clear any pending range selection
                return;
              }

              if (isAwaitingRangeEndTap) {
                // --- This is the second tap ---
                if (!selectionAnchor) {
                  // Should not happen, but reset defensively
                  console.warn(
                    "Second tap detected, but no anchor set. Resetting.",
                  );
                  isAwaitingRangeEndTap = false;
                  selectionAnchor = [touchRowIndex, touchCellIndex]; // Treat as first tap
                  applySelectionStyles(selectionAnchor); // Style just the new anchor
                  // Do not open picker yet
                } else if (
                  selectionAnchor[0] === touchRowIndex &&
                  selectionAnchor[1] === touchCellIndex
                ) {
                  // --- Tapped same cell again: Confirm single selection ---
                  console.log(
                    "Range selection cancelled: Tapped anchor again. Confirming single select.",
                  );
                  selectedCells = [selectionAnchor]; // Define selection as only the anchor
                  // No need to re-apply style, it's already on anchor
                  openColorPicker(
                    selectionAnchor[0],
                    selectionAnchor[1],
                    event,
                  );
                  isAwaitingRangeEndTap = false;
                  // selectionAnchor remains set until clearSelection is called elsewhere
                } else {
                  // --- Tapped different cell: Define range ---
                  console.log("Range selection: Defining range.");
                  const [anchorRow, anchorCol] = selectionAnchor;
                  const targetRow = touchRowIndex;
                  const targetCol = touchCellIndex;

                  const minRow = Math.min(anchorRow, targetRow);
                  const maxRow = Math.max(anchorRow, targetRow);
                  const minCol = Math.min(anchorCol, targetCol);
                  const maxCol = Math.max(anchorCol, targetCol);

                  // Clear previous visual selection (keep anchor conceptually)
                  selectedCells.forEach((coord) => {
                    const cellDiv = paletteGrid.querySelector(
                      `.cell-content[data-row-index="${coord[0]}"][data-cell-index="${coord[1]}"]`,
                    );
                    if (cellDiv) {
                      cellDiv.classList.remove("selected");
                    }
                  });
                  selectedCells = []; // Reset selected cells array

                  // Select cells within the rectangle
                  for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                      if (
                        r < sourceGridData.length &&
                        c < sourceGridData[r].length &&
                        isValidHex(sourceGridData[r][c])
                      ) {
                        selectedCells.push([r, c]);
                        applySelectionStyles([r, c]); // Apply style to each cell in range
                      }
                    }
                  }
                  console.log(
                    `Range selected (touch): ${selectedCells.length} cells.`,
                  );

                  // Open/update picker after selection change
                  if (selectedCells.length > 0) {
                    openColorPicker(
                      selectedCells[0][0],
                      selectedCells[0][1],
                      event,
                    );
                  } else if (colorPickerModal.classList.contains("visible")) {
                    closeColorPicker(); // Close if selection ended up empty
                  }
                  isAwaitingRangeEndTap = false;
                  // selectionAnchor remains set until clearSelection is called elsewhere
                }
              } else {
                // --- This is the first tap (or a tap outside range mode) ---
                console.log("Range selection: Setting anchor.");
                clearSelection(); // Clear previous selection AND resets isAwaitingRangeEndTap
                selectionAnchor = [touchRowIndex, touchCellIndex];
                applySelectionStyles(selectionAnchor); // Style just the anchor
                isAwaitingRangeEndTap = true;
                // Do NOT add to selectedCells yet
                // Do NOT open picker yet
              }

              // Set flag indicating touch handled this interaction
              touchEventHandled = true;
              // Prevent the browser from firing a 'click' event after this touchend
              event.preventDefault();
              // Also stop propagation to prevent canvas viewport listeners if needed
              event.stopPropagation();
            },
            { passive: false },
          ); // Use passive:false if preventDefault is needed
        }
        // --- END Touch End Listener ---

        // --- REVISED Click Listener (Handles Desktop Clicks, Multi-Select, Range Select) ---
        cellContentDiv.addEventListener("click", (event) => {
          // If a touch event already handled this action, or if the pointer moved, bail out
          if (touchEventHandled || pointerHasMoved) {
            touchEventHandled = false; // Reset flag after check
            return;
          }
          // Touch devices don't have Ctrl/Shift easily, ignore range select for them
          if (isTouchDevice) return; // Let touchend handle touch interaction

          // --- Desktop Click Logic ---
          const clickRowIndex = parseInt(cellContentDiv.dataset.rowIndex, 10);
          const clickCellIndex = parseInt(cellContentDiv.dataset.cellIndex, 10);

          if (
            clickRowIndex >= sourceGridData.length ||
            clickCellIndex >= sourceGridData[clickRowIndex].length
          ) {
            console.warn("Clicked cell outside source data bounds.");
            return;
          }
          const clickedSourceHex =
            sourceGridData[clickRowIndex][clickCellIndex];
          // Only proceed if it's a valid swatch cell
          if (!isValidHex(clickedSourceHex)) {
            console.log(
              "Clicked on a non-swatch cell (label/invalid). Ignoring selection.",
            );
            return;
          }
          const clickedHsl = hexToHsl(clickedSourceHex); // Needed for similarity check later

          // --- Determine Action based on Modifiers ---
          const isCtrlClick = event.ctrlKey && !event.shiftKey; // Ctrl for individual selection
          const isShiftClick = event.shiftKey && !event.ctrlKey; // Shift for range selection
          const isSimpleClick = !event.shiftKey && !event.ctrlKey;

          // 1. Shift Click: Range Selection
          if (isShiftClick && isColorPickingMode && !isInterpolationEnabled) {
            console.log("Shift Click (Range Selection) detected.");
            if (!selectionAnchor) {
              // First click in a potential range select sequence
              console.log("Setting anchor point.");
              clearSelection(); // Clear any previous selection
              selectedCells.push([clickRowIndex, clickCellIndex]);
              selectionAnchor = [clickRowIndex, clickCellIndex]; // Set anchor
              applySelectionStyles(selectionAnchor); // Apply style to anchor
            } else {
              // Anchor already exists, perform range selection
              console.log("Performing range selection.");
              const [anchorRow, anchorCol] = selectionAnchor;
              const targetRow = clickRowIndex;
              const targetCol = clickCellIndex;

              const minRow = Math.min(anchorRow, targetRow);
              const maxRow = Math.max(anchorRow, targetRow);
              const minCol = Math.min(anchorCol, targetCol);
              const maxCol = Math.max(anchorCol, targetCol);

              // Clear previous visual selection ONLY (keep anchor)
              selectedCells.forEach((coord) => {
                const cellDiv = paletteGrid.querySelector(
                  `.cell-content[data-row-index="${coord[0]}"][data-cell-index="${coord[1]}"]`,
                );
                if (cellDiv) {
                  cellDiv.classList.remove("selected");
                }
              });
              selectedCells = []; // Reset selected cells array

              // Select cells within the rectangle
              for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                  // Check bounds and if it's a valid swatch in source data
                  if (
                    r < sourceGridData.length &&
                    c < sourceGridData[r].length &&
                    isValidHex(sourceGridData[r][c])
                  ) {
                    selectedCells.push([r, c]);
                    applySelectionStyles([r, c]);
                  }
                }
              }
              console.log(`Range selected: ${selectedCells.length} cells.`);
            }
            // Open/update picker after selection change
            if (selectedCells.length > 0) {
              openColorPicker(selectedCells[0][0], selectedCells[0][1], event);
            } else if (colorPickerModal.classList.contains("visible")) {
              closeColorPicker(); // Close if selection ended up empty
            }

            // 2. Ctrl Click: Toggle individual selection (add/remove)
            else if (
              isCtrlClick &&
              isColorPickingMode &&
              !isInterpolationEnabled
            ) {
              console.log("Ctrl Click (Toggle Selection) detected.");
              if (!clickedHsl) {
                console.warn("Cannot Ctrl+Click: Invalid HSL.");
                return;
              }

              // If selection is empty, this click sets the anchor
              if (selectedCells.length === 0) {
                selectionAnchor = [clickRowIndex, clickCellIndex];
                console.log("Setting anchor with first Ctrl+Click.");
              }
              // Use handleSwatchSelection for the add/remove/similarity logic
              handleSwatchSelection(
                event,
                clickRowIndex,
                clickCellIndex,
                clickedHsl,
              );
              // Open/update picker after selection change
              if (selectedCells.length > 0) {
                openColorPicker(
                  selectedCells[0][0],
                  selectedCells[0][1],
                  event,
                );
              }
            } else if (colorPickerModal.classList.contains("visible")) {
              closeColorPicker(); // Close if selection ended up empty
            }

            // 3. Simple Click (No Modifiers)
          } else if (isSimpleClick) {
            if (isColorPickingMode && !isInterpolationEnabled) {
              // Simple click in pick mode: Select only this cell, set anchor
              console.log("Simple Click in Pick Mode detected.");
              clearSelection(); // Clears old selection AND anchor
              selectedCells.push([clickRowIndex, clickCellIndex]);
              selectionAnchor = [clickRowIndex, clickCellIndex]; // Set new anchor
              applySelectionStyles(selectionAnchor);
              openColorPicker(clickRowIndex, clickCellIndex, event);
            } else {
              // Simple click NOT in pick mode (or interpolation on): Copy hex
              console.log("Simple Click - Copy behavior.");
              const displayedHex = cellContentDiv.textContent;
              copyToClipboard(displayedHex, cellContentDiv);
              clearSelection(); // Clear selection and anchor on copy
              if (colorPickerModal.classList.contains("visible")) {
                closeColorPicker();
              }
            }
          }
          // Ignore other modifier combinations (like Ctrl alone) for selection for now

          // Reset touch handled flag after processing click
          touchEventHandled = false;
        });
        // --- END REVISED Click Listener ---

        // --- Update mouseover/mouseout to respect selection ---
        cellContentDiv.addEventListener("mouseover", () => {
          // This is DOM mouseover, not our state var
          if (
            !isColorPickingMode &&
            !cellContentDiv.classList.contains("selected")
          ) {
            // Don't show hover if selected
            cellContentDiv.style.boxShadow = `inset 0 0 0 2px ${textColor}`;
          }
        });
        cellContentDiv.addEventListener("mouseout", () => {
          // This is DOM mouseout
          if (!cellContentDiv.classList.contains("selected")) {
            // Don't remove shadow if selected
            cellContentDiv.style.boxShadow = "none";
          }
          // Tooltip hiding is handled by 'mouseleave' on the cell itself and tooltip logic.
        });

        // --- Apply initial selected style if cell is in selectedCells ---
        if (
          selectedCells.some(
            (coord) => coord[0] === rowIndex && coord[1] === cellIndex,
          )
        ) {
          cellContentDiv.classList.add("selected");
          // CSS class handles the selection styling
        }
      } else if (typeof cellData === "string") {
        // Label rendering
        cellContentDiv.textContent = cellData;
        cellContentDiv.classList.add("label");
        if (isInterpolatedLabelPlaceholder) {
          cellContentDiv.classList.add("interpolated-label");
        } else {
          cellContentDiv.style.color = getTextColor("#2a2a2a"); // Use a fixed background for text color calc
          if (
            cellIndex === 0 ||
            cellIndex === rowData.length - 1 ||
            rowIndex === 0 ||
            rowIndex === gridData.length - 1
          ) {
            cellContentDiv.classList.add("legend-label");
          }
        }
        // Make labels clickable to copy
        cellContentDiv.style.cursor = "pointer";
        cellContentDiv.addEventListener("click", (event) => {
          event.stopPropagation();
          const labelText = cellContentDiv.textContent;
          navigator.clipboard
            .writeText(labelText)
            .then(() => {
              showCopiedFeedback(cellContentDiv);
              console.log(`Label copied: ${labelText}`);
            })
            .catch((err) => {
              console.error("Failed to copy label:", err);
              alert("Failed to copy label.");
            });
        });
      } else {
        // Error handling
        console.warn(
          `Invalid cell data type at row ${rowIndex}, cell ${cellIndex}:`,
          typeof cellData,
          cellData,
        );
        cellContentDiv.textContent = "?";
        cellContentDiv.style.backgroundColor = "#555";
        cellContentDiv.style.color = "var(--text-color)";
        cellContentDiv.classList.add("invalid");
        cellContentDiv.style.pointerEvents = "none"; // Prevent invalid cells from being selectable
      }
    });
  });
}

// --- NEW: Function to handle swatch selection logic (Focus: Add/Remove for Shift+Click) ---
function handleSwatchSelection(event, rowIndex, colIndex, clickedHsl) {
  // This function is now primarily for the *add/remove* logic of Shift+Click / Touch tap
  // It should NOT set the anchor here, as that's handled by the click listener logic

  const isMultiSelectIntent =
    (event.type === "touchend" && isTouchDevice && isColorPickingMode) ||
    (event.type === "click" && event.ctrlKey && !event.shiftKey); // Check for exclusive ctrl - removed !isTouchDevice check

  const cellId = `${rowIndex}-${colIndex}`;
  const existingIndex = selectedCells.findIndex(
    (coord) => coord[0] === rowIndex && coord[1] === colIndex,
  );
  const targetDiv = paletteGrid.querySelector(
    `.cell-content[data-row-index="${rowIndex}"][data-cell-index="${colIndex}"]`,
  );

  if (!targetDiv) return;

  if (isMultiSelectIntent) {
    // --- Multi-select logic (add/remove/check similarity) ---
    if (existingIndex > -1) {
      // Already selected, deselect it
      selectedCells.splice(existingIndex, 1);
      targetDiv.classList.remove("selected");
      // If we just deselected the anchor, clear the anchor
      if (
        selectionAnchor &&
        selectionAnchor[0] === rowIndex &&
        selectionAnchor[1] === colIndex
      ) {
        // console.log("Anchor deselected, clearing anchor.");
        selectionAnchor = null;
        // If selection is now empty, ensure picker closes if open? (Handled after call)
      }
      // If selection is empty, maybe reset anchor? Or keep last anchor?
      // Let's reset anchor if selection becomes empty
      if (selectedCells.length === 0) {
        selectionAnchor = null;
        // console.log("Selection empty after deselect, clearing anchor.");
      }
    } else {
      // Not selected, try to add
      // **Anchor setting moved to click listener logic**
      if (selectedCells.length === 0) {
        // First selection (anchor should have been set by caller)
        selectedCells.push([rowIndex, colIndex]);
        applySelectionStyles([rowIndex, colIndex]);
      } else {
        // Check S/L similarity with the FIRST selected cell (which might be the anchor or not)
        const firstSelectedCoords = selectedCells[0]; // Use first in current selection list
        if (
          firstSelectedCoords[0] >= sourceGridData.length ||
          firstSelectedCoords[1] >=
            sourceGridData[firstSelectedCoords[0]].length
        ) {
          console.warn(
            "First selected cell out of bounds during multi-select add. Clearing.",
          );
          clearSelection(); // This clears anchor too
          selectedCells.push([rowIndex, colIndex]); // Select current as new first
          selectionAnchor = [rowIndex, colIndex]; // Set anchor here explicitly after clear
          applySelectionStyles([rowIndex, colIndex]);
          return;
        }
        const firstSelectedHex =
          sourceGridData[firstSelectedCoords[0]][firstSelectedCoords[1]];
        const firstSelectedHsl = hexToHsl(firstSelectedHex);

        if (firstSelectedHsl) {
          const sDiff = Math.abs(clickedHsl.s - firstSelectedHsl.s);
          const lDiff = Math.abs(clickedHsl.l - firstSelectedHsl.l);

          if (sDiff <= multiSelectTolerance || lDiff <= multiSelectTolerance) {
            selectedCells.push([rowIndex, colIndex]);
            applySelectionStyles([rowIndex, colIndex]);
          } else {
            // Condition not met - Start new selection with this cell
            console.log(
              "New selection started: Dissimilar color added via Shift+Click/Tap.",
            );
            clearSelection(); // Clears anchor
            selectedCells.push([rowIndex, colIndex]);
            selectionAnchor = [rowIndex, colIndex]; // Set anchor explicitly
            applySelectionStyles([rowIndex, colIndex]);
          }
        } else {
          console.warn(
            "Could not get HSL for first selected cell during multi-select check.",
          );
          clearSelection(); // Clears anchor
          selectedCells.push([rowIndex, colIndex]);
          selectionAnchor = [rowIndex, colIndex]; // Set anchor explicitly
          applySelectionStyles([rowIndex, colIndex]);
        }
      }
    }
  } else {
    // Not a multi-select intent (e.g., simple click called this somehow - shouldn't happen now)
    // This case should ideally be handled by the simple click logic in the event listener
    console.warn("handleSwatchSelection called without multi-select intent.");
    // Fallback: Standard single select: Clear previous, select current
    clearSelection(); // Clears anchor
    selectedCells.push([rowIndex, colIndex]);
    selectionAnchor = [rowIndex, colIndex]; // Set anchor
    applySelectionStyles([rowIndex, colIndex]);
  }

  // console.log("Selected Cells:", selectedCells, "Anchor:", selectionAnchor); // More detailed log
}

// --- NEW: Function to clear selection state and visuals (UPDATED)---
function clearSelection() {
  selectedCells.forEach((coord) => {
    const cellDiv = paletteGrid.querySelector(
      `.cell-content[data-row-index="${coord[0]}"][data-cell-index="${coord[1]}"]`,
    );
    if (cellDiv) {
      cellDiv.classList.remove("selected");
    }
  });
  selectedCells = []; // Reset the array
  selectionAnchor = null; // Reset selection anchor
  isAwaitingRangeEndTap = false; // Reset touch range state
  // console.log("Selection cleared, anchor reset."); // Optional debug
}

// Update the view based on interpolation state
function updatePaletteView() {
  if (isInterpolationEnabled) {
    currentGridData = generateInterpolatedPalette(
      sourceGridData,
      interpolationSteps,
    );
  } else {
    // Reset to a fresh copy of the source data
    currentGridData = sourceGridData.map((row) => [...row]);
  }
  // Render the potentially interpolated grid.
  // Saturation is applied *during* renderPalette.
  renderPalette(currentGridData);
}

// --- NEW: Panning Logic ---
function startPan(event) {
  // Don't pan if clicking on interactive elements within the viewport
  // Check for popout, color picker, OR if the target is a swatch in color pick mode on touch
  const targetIsSwatch =
    event.target.classList.contains("cell-content") &&
    event.target.classList.contains("swatch");
  if (
    event.target.closest("#popout-editor") ||
    event.target.closest("#color-picker-modal") ||
    (isTouchDevice && isColorPickingMode && targetIsSwatch)
  ) {
    return;
  }

  isPanning = true;
  const coords = getEventCoords(event); // Use helper for coords
  startX = coords.x;
  startY = coords.y;
  // --- Store pointer down position and reset move flag ---
  pointerDownPos = { x: startX, y: startY }; // Use renamed var
  pointerHasMoved = false; // Use renamed var
  // --- END ---
  canvasViewport.classList.add("grabbing");
  // Prevent text selection during drag / default touch actions like scroll
  event.preventDefault();
}

function panMove(event) {
  if (!isPanning) return;
  event.preventDefault(); // Prevent scroll during pan
  const coords = getEventCoords(event); // Use helper for coords
  currentX = coords.x;
  currentY = coords.y;

  // --- Check if pointer has moved beyond threshold --- // Use renamed vars
  if (!pointerHasMoved) {
    const dxAbs = Math.abs(currentX - pointerDownPos.x);
    const dyAbs = Math.abs(currentY - pointerDownPos.y);
    if (dxAbs > dragThreshold || dyAbs > dragThreshold) {
      pointerHasMoved = true;
    }
  }
  // --- END ---

  const dx = currentX - startX;
  const dy = currentY - startY;

  paletteOffsetX += dx;
  paletteOffsetY += dy;

  // Apply transform using the dedicated function
  updateTransform();

  // Update start for next move delta
  startX = currentX;
  startY = currentY;
}

function endPan() {
  if (isPanning) {
    isPanning = false;
    canvasViewport.classList.remove("grabbing");
    // Reset pointerHasMoved *after* potential click/touchend handlers might have checked it.
    // Use a small delay to ensure handlers can read the value before reset.
    setTimeout(() => {
      pointerHasMoved = false;
    }, 50);
  }
  // Reset touch flags regardless
  touchEventHandled = false;
  isAwaitingRangeEndTap = false; // Cancel touch range selection on pan end
}

// --- REVISED: Zoom Logic (triggered by controls) ---
function applyZoom(newScalePercent) {
  const newScale = Math.max(
    minScale,
    Math.min(maxScale, newScalePercent / 100),
  );

  // If scale didn't change, do nothing
  if (newScale === scale) return;

  // Get mouse position relative to the viewport
  const rect = canvasViewport.getBoundingClientRect();

  // Use viewport center as the zoom focal point
  const focalX = rect.width / 2;
  const focalY = rect.height / 2;

  // Calculate the point on the palette container under the mouse before zoom
  const pointX = (focalX - paletteOffsetX) / scale;
  const pointY = (focalY - paletteOffsetY) / scale;

  // Update scale
  scale = newScale;

  // Calculate the new offset to keep the point under the mouse stationary
  paletteOffsetX = focalX - pointX * scale;
  paletteOffsetY = focalY - pointY * scale;

  // Apply new transform
  updateTransform();
}

// --- NEW: Apply Transform Function ---
function updateTransform() {
  paletteContainer.style.transform = `translate(${paletteOffsetX}px, ${paletteOffsetY}px) scale(${scale})`;
}

// --- Reset View Function ---
function resetView() {
  const viewportWidth = canvasViewport.clientWidth;
  const viewportHeight = canvasViewport.clientHeight;
  const containerWidth = paletteContainer.offsetWidth;
  const containerHeight = paletteContainer.offsetHeight;

  if (
    viewportWidth > 0 &&
    viewportHeight > 0 &&
    containerWidth > 0 &&
    containerHeight > 0
  ) {
    // Reset scale to 1
    scale = 1;

    // Calculate centered offsets
    paletteOffsetX = (viewportWidth - containerWidth * scale) / 2;
    paletteOffsetY = (viewportHeight - containerHeight * scale) / 2;

    // Apply the transform
    updateTransform();

    // Update zoom controls
    zoomSlider.value = 100;
    zoomNumber.value = 100;

    console.log(
      `Reset view: offset(${paletteOffsetX}, ${paletteOffsetY}), scale: ${scale}`,
    );
  } else {
    console.warn(
      "Could not reset view: Viewport or Container dimensions are zero.",
    );
  }
}

// --- Event Listeners ---

// Panning Listeners
canvasViewport.addEventListener("mousedown", startPan);
canvasViewport.addEventListener("mousemove", panMove);
canvasViewport.addEventListener("mouseup", endPan);
canvasViewport.addEventListener("mouseleave", endPan); // Stop panning if mouse leaves viewport
// Touch Events for mobile
canvasViewport.addEventListener("touchstart", startPan, { passive: false }); // passive: false to allow preventDefault
canvasViewport.addEventListener("touchmove", panMove, { passive: false });
canvasViewport.addEventListener("touchend", endPan);
canvasViewport.addEventListener("touchcancel", endPan);

// --- NEW: Config Modal Functions ---

const focusableModalElementsSelector =
  'button, [href], input:not([type="range"]), select, textarea, [tabindex]:not([tabindex="-1"])';
let firstFocusableElement = null;
let lastFocusableElement = null;

function openConfigModal() {
  configModal.classList.add("visible");
  configModal.classList.remove("editor-visible"); // Reset editor view
  configToggleButton.classList.add("active"); // Add active class to button

  // Set focus trap elements
  const focusableElements = configModal.querySelectorAll(
    focusableModalElementsSelector,
  );
  if (focusableElements.length > 0) {
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];
    // Defer focus setting until after transition/rendering
    requestAnimationFrame(() => {
      firstFocusableElement.focus(); // Focus the first element (usually close button)
    });
  } else {
    firstFocusableElement = null;
    lastFocusableElement = null;
  }

  document.addEventListener("keydown", handleGlobalKeyDown);
}

function closeConfigModal() {
  configModal.classList.remove("visible");
  configToggleButton.classList.remove("active"); // Remove active class from button
  document.removeEventListener("keydown", handleGlobalKeyDown);
  // Optionally return focus to the button that opened the modal
  configToggleButton.focus();
}

function handleGlobalKeyDown(event) {
  if (!configModal.classList.contains("visible")) return;

  // Close on Escape key
  if (event.key === "Escape") {
    closeConfigModal();
    return;
  }

  // Trap focus on Tab key
  if (event.key === "Tab") {
    if (!firstFocusableElement) return; // No focusable elements

    if (event.shiftKey) {
      // Shift + Tab
      if (document.activeElement === firstFocusableElement) {
        lastFocusableElement.focus();
        event.preventDefault();
      }
    } else {
      // Tab
      if (document.activeElement === lastFocusableElement) {
        firstFocusableElement.focus();
        event.preventDefault();
      }
    }
    // If focus is currently outside the modal (e.g., browser UI), bring it back
    // This check might need refinement depending on specific browser behavior
    if (!configModal.contains(document.activeElement)) {
      firstFocusableElement.focus();
    }
  }
}

// Config Modal Toggle Listener (Uses new functions)
configToggleButton.addEventListener("click", () => {
  if (configModal.classList.contains("visible")) {
    closeConfigModal();
  } else {
    openConfigModal();
  }
});

// Close Button Listener (Uses new function)
closeModalButton.addEventListener("click", closeConfigModal);

// Background Click Listener (Uncommented and uses new function)
configModal.addEventListener("click", (event) => {
  // Close only if the click is directly on the modal background, not its children
  if (event.target === configModal) {
    closeConfigModal();
  }
});

// Show/Hide Palette Editor within Modal
editPaletteButton.addEventListener("click", () => {
  // Check if desktop (wider than 768px is common breakpoint)
  const isDesktop = window.innerWidth > 768;

  if (isDesktop) {
    // Desktop: Use browser window pop-out
    const editorContent = convertToSimpleFormat(sourceGridData);
    const popoutWindow = window.open(
      "",
      "PaletteEditor",
      "width=600,height=800,resizable=yes,scrollbars=yes",
    );

    if (popoutWindow) {
      // Create HTML content for the popout window
      popoutWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Edit Palette Data</title>
          <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@400;700&display=swap" rel="stylesheet">
          <style>
            body {
              margin: 0;
              padding: 20px;
              font-family: 'Ubuntu Mono', monospace;
              background-color: #191724;
              color: #e0def4;
            }
            h1 {
              font-size: 1.5rem;
              margin-bottom: 1rem;
              color: #ebbcba;
            }
            textarea {
              width: 100%;
              height: calc(100vh - 180px);
              background-color: #1f1d2e;
              color: #e0def4;
              border: 2px solid #403d52;
              border-radius: 8px;
              padding: 1rem;
              font-family: 'Ubuntu Mono', monospace;
              font-size: 0.875rem;
              resize: none;
              box-sizing: border-box;
            }
            textarea:focus {
              outline: none;
              border-color: #f6c177;
            }
            .button-group {
              margin-top: 1rem;
              display: flex;
              gap: 1rem;
            }
            button {
              padding: 0.75rem 1.5rem;
              background-color: #31748f;
              color: #e0def4;
              border: none;
              border-radius: 6px;
              font-family: 'Inter', sans-serif;
              font-weight: 500;
              cursor: pointer;
              transition: background-color 0.2s;
            }
            button:hover {
              background-color: #3e8fb0;
            }
            button.cancel {
              background-color: #6e6a86;
            }
            button.cancel:hover {
              background-color: #908caa;
            }
            .status {
              margin-top: 0.5rem;
              color: #9ccfd8;
              font-size: 0.875rem;
            }
          </style>
        </head>
        <body>
          <h1>Edit Palette Data</h1>
          <p style="color: #908caa; margin-bottom: 1rem;">Space-delimited rows, #Hex for colors</p>
          <textarea id="paletteData" spellcheck="false">${editorContent}</textarea>
          <div class="button-group">
            <button onclick="applyChanges()">Apply Changes</button>
            <button class="cancel" onclick="window.close()">Cancel</button>
          </div>
          <div id="status" class="status"></div>
          <script>
            function applyChanges() {
              const newData = document.getElementById('paletteData').value;
              if (window.opener && !window.opener.closed) {
                window.opener.postMessage({
                  type: 'updatePalette',
                  data: newData
                }, '*');
                document.getElementById('status').textContent = 'Changes applied!';
                // Don't close the window automatically
              } else {
                alert('Parent window not found. Please apply changes manually.');
              }
            }
            // Focus textarea on load
            document.getElementById('paletteData').focus();
            document.getElementById('paletteData').select();
          </script>
        </body>
        </html>
      `);
      popoutWindow.document.close();
    } else {
      alert("Please allow pop-ups for this site to use the palette editor.");
    }
  } else {
    // Mobile: Use inline editor in modal
    if (paletteEditorSection.classList.contains("hidden")) {
      paletteEditorSection.classList.remove("hidden");
      paletteInput.value = convertToSimpleFormat(sourceGridData);
      editPaletteButton.textContent = "Close Editor";
      paletteInput.focus();
      paletteInput.select();
    } else {
      paletteEditorSection.classList.add("hidden");
      editPaletteButton.textContent = "Edit Palette Data";
    }
  }
});

// Listen for messages from popout window
window.addEventListener("message", (event) => {
  if (event.data && event.data.type === "updatePalette") {
    const newDataParsed = parseSimpleFormat(event.data.data);
    if (
      Array.isArray(newDataParsed) &&
      newDataParsed.length > 0 &&
      Array.isArray(newDataParsed[0])
    ) {
      sourceGridData = newDataParsed;
      isInterpolationEnabled = false;
      interpolationToggle.checked = false;
      currentGridData = sourceGridData.map((row) => [...row]);
      renderPalette(currentGridData);

      // Show success feedback
      const originalText = updateButton.textContent;
      updateButton.textContent = "Updated!";
      updateButton.classList.add("success");
      setTimeout(() => {
        updateButton.textContent = originalText;
        updateButton.classList.remove("success");
      }, 2000);
    }
  }
});

// --- NEW: Popout Close Button Listener --- (keeping for legacy support)
if (popoutCloseButton) {
  popoutCloseButton.addEventListener("click", () => {
    popoutEditor.style.display = "none"; // Hide the popout
  });
}

// Update Button (now only for the modal editor, which is unused but kept for now)
// updateButton.addEventListener('click', () => { ... });

// Export PNG Event Listener (Target remains paletteTable)
exportPngButton.addEventListener("click", () => {
  // Read scale from input, default to 2 if invalid
  let exportScale = parseFloat(exportScaleInput.value) || 2;
  exportScale = Math.max(1, Math.min(10, exportScale)); // Clamp between 1 and 10
  exportScaleInput.value = exportScale; // Update input field in case it was invalid/clamped

  console.log(`Exporting PNG with scale: ${exportScale}x`); // Log the scale being used

  // Disable button temporarily
  exportPngButton.disabled = true;
  exportPngButton.textContent = "Exporting...";
  exportScaleInput.disabled = true; // Disable scale input too

  // Slight delay to allow UI to settle if needed
  setTimeout(() => {
    // Determine the background color to use
    const tableBgColor = getComputedStyle(paletteContainer).backgroundColor;

    html2canvas(paletteGrid, {
      backgroundColor: tableBgColor, // Use container BG for capture
      useCORS: true,
      logging: false,
      scale: exportScale, // Use scale from input
      // Position/offset adjustments might be needed if transform interferes
      // x: paletteContainer.offsetLeft, // Experiment if capture is off
      // y: paletteContainer.offsetTop,
    })
      .then((canvas) => {
        const pngUrl = canvas.toDataURL("image/png");
        const downloadLink = document.createElement("a");
        downloadLink.href = pngUrl;
        downloadLink.download = "palette.png";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      })
      .catch((err) => {
        console.error("Error exporting PNG:", err);
        alert("Error exporting palette as PNG. See console for details.");
      })
      .finally(() => {
        // Re-enable button and input
        exportPngButton.disabled = false;
        exportPngButton.textContent = "Export as PNG";
        exportScaleInput.disabled = false;
      });
  }, 150); // Delay
});

// Interpolation/Saturation Listeners
interpolationToggle.addEventListener("change", (event) => {
  isInterpolationEnabled = event.target.checked;
  updatePaletteView();
});
stepsSlider.addEventListener("input", (event) => {
  interpolationSteps = parseInt(event.target.value, 10);
  stepsNumber.value = interpolationSteps;
  if (isInterpolationEnabled) {
    updatePaletteView();
  }
});
stepsNumber.addEventListener("input", (event) => {
  let value = parseInt(event.target.value, 10);
  const min = parseInt(stepsNumber.min, 10);
  const max = parseInt(stepsNumber.max, 10);
  if (isNaN(value)) {
    value = min;
  } else if (value < min) {
    value = min;
  } else if (value > max) {
    value = max;
  }
  stepsNumber.value = value;
  interpolationSteps = value;
  stepsSlider.value = interpolationSteps;
  if (isInterpolationEnabled) {
    updatePaletteView();
  }
});
saturationOffsetSlider.addEventListener("input", (event) => {
  saturationOffset = parseInt(event.target.value, 10);
  saturationOffsetNumber.value = saturationOffset;
  renderPalette(currentGridData); // Just re-render
});
saturationOffsetNumber.addEventListener("input", (event) => {
  let value = parseInt(event.target.value, 10);
  const min = parseInt(saturationOffsetNumber.min, 10);
  const max = parseInt(saturationOffsetNumber.max, 10);
  if (isNaN(value)) {
    value = 0;
  } else if (value < min) {
    value = min;
  } else if (value > max) {
    value = max;
  }
  saturationOffsetNumber.value = value;
  saturationOffset = value;
  saturationOffsetSlider.value = saturationOffset;
  renderPalette(currentGridData); // Just re-render
});

// --- Zoom Control Listeners --- (UPDATED)
// Restore zoomSlider listener
zoomSlider.addEventListener("input", (event) => {
  const zoomValue = parseInt(event.target.value, 10);
  zoomNumber.value = zoomValue; // Sync number input
  clearTimeout(zoomTimeout);
  zoomTimeout = setTimeout(() => applyZoom(zoomValue), zoomDebounceDelay);
});

zoomNumber.addEventListener("input", (event) => {
  let value = parseInt(event.target.value, 10);
  const min = parseInt(zoomNumber.min, 10);
  const max = parseInt(zoomNumber.max, 10);
  // -- TEMPORARILY REMOVE CLAMPING/DEFAULTING ON INPUT --
  // if (isNaN(value)) {
  //     value = 100; // Default to 100% if invalid
  // } else if (value < min) {
  //     value = min;
  // } else if (value > max) {
  //     value = max;
  // }
  // zoomNumber.value = value; // Don't immediately update input field

  // -- Sync slider ONLY if value is valid --
  if (!isNaN(value)) {
    zoomSlider.value = Math.max(min, Math.min(max, value)); // Clamp slider value
  }
  // -- Apply zoom (with debounce) using potentially un-clamped value --
  // ApplyZoom will handle clamping internally before using the scale
  clearTimeout(zoomTimeout);
  if (!isNaN(value)) {
    // Only set timeout if value is a number
    zoomTimeout = setTimeout(() => applyZoom(value), zoomDebounceDelay);
  }
});

// Add 'change' listener to zoomNumber for final validation/clamping
zoomNumber.addEventListener("change", (event) => {
  let value = parseInt(event.target.value, 10);
  const min = parseInt(zoomNumber.min, 10);
  const max = parseInt(zoomNumber.max, 10);

  if (isNaN(value)) {
    value = 100; // Default to 100 if invalid
  } else {
    value = Math.max(min, Math.min(max, value)); // Clamp within min/max
  }
  // Update the input field visually to the clamped value
  zoomNumber.value = value;
  zoomSlider.value = value; // Sync slider to clamped value

  // Apply the final clamped value immediately (or keep debounce if preferred)
  clearTimeout(zoomTimeout); // Clear any pending timeouts from 'input'
  applyZoom(value);
});

// --- NEW: UI Scale Control Listeners --- (UPDATED)
// REMOVED uiScaleSlider listener
// ...

uiScaleNumber.addEventListener("input", (event) => {
  let value = parseInt(event.target.value, 10);
  // -- TEMPORARILY REMOVE CLAMPING/DEFAULTING ON INPUT --
  // const min = parseInt(uiScaleNumber.min, 10);
  // const max = parseInt(uiScaleNumber.max, 10);
  // if (isNaN(value)) {
  //     value = 100; // Default to 100 if invalid
  // } else {
  //     value = Math.max(min, Math.min(max, value)); // Clamp within min/max
  // }
  // uiScaleNumber.value = value; // Don't immediately update input field

  // Apply scale (applyUiScale handles clamping internally)
  if (!isNaN(value)) {
    // Only apply if it's a number
    applyUiScale(value);
  }
});

// Add 'change' listener to uiScaleNumber for final validation/clamping
uiScaleNumber.addEventListener("change", (event) => {
  let value = parseInt(event.target.value, 10);
  const min = parseInt(uiScaleNumber.min, 10);
  const max = parseInt(uiScaleNumber.max, 10);

  if (isNaN(value)) {
    value = 100; // Default to 100 if invalid
  } else {
    value = Math.max(min, Math.min(max, value)); // Clamp within min/max
  }
  // Update the input field visually to the clamped value
  uiScaleNumber.value = value;
  // Apply the final clamped value
  applyUiScale(value);
});

// --- REVISED: Generate X Row Event Listener (Manual References) ---
generateXButton.addEventListener("click", () => {
  const targetX = parseInt(generateXValueInput.value, 10);
  const ref1X = parseInt(generateRef1ValueInput.value, 10);
  const ref2X = parseInt(generateRef2ValueInput.value, 10);
  const originalButtonText = generateXButton.textContent; // Store original text
  let generateSuccess = false; // Flag for feedback

  console.log(
    `--- Generate Row Clicked --- Target: ${targetX}x, Ref1: ${ref1X}x, Ref2: ${ref2X}x`,
  );

  try {
    if (isNaN(targetX) || isNaN(ref1X) || isNaN(ref2X)) {
      // alert('Please enter valid numbers for Target X, Ref 1 X, and Ref 2 X.'); // Replaced alert
      throw new Error("Please enter valid numbers.");
    }
    if (ref1X === ref2X) {
      // alert('Reference 1 X and Reference 2 X cannot be the same.'); // Replaced alert
      throw new Error("Reference X values cannot be the same.");
    }

    // Find the exact rows for ref1 and ref2
    let rowRef1 = null;
    let rowRef2 = null;
    let existingRowIndex = -1;

    sourceGridData.forEach((row, index) => {
      const currentX = parseXValue(row[0]);
      if (currentX === null) return;

      if (currentX === targetX) {
        existingRowIndex = index;
      }
      if (currentX === ref1X) {
        rowRef1 = row;
      }
      if (currentX === ref2X) {
        rowRef2 = row;
      }
    });

    if (existingRowIndex !== -1) {
      // alert(`Row ${targetX}x already exists.`); // Replaced alert
      throw new Error(`Row ${targetX}x already exists.`);
    }
    if (!rowRef1) {
      // alert(`Could not find reference row ${ref1X}x.`); // Replaced alert
      throw new Error(`Could not find reference row ${ref1X}x.`);
    }
    if (!rowRef2) {
      // alert(`Could not find reference row ${ref2X}x.`); // Replaced alert
      throw new Error(`Could not find reference row ${ref2X}x.`);
    }

    // Calculate interpolation/extrapolation factor t relative to ref1 and ref2
    const t = (targetX - ref1X) / (ref2X - ref1X);
    console.log(`Calculation factor t: ${t}`);

    if (isNaN(t)) {
      console.error(
        "Invalid factor (NaN). ref1X and ref2X might be identical.",
      );
      // alert('Internal error calculating factor (reference values might be identical).'); // Replaced alert
      throw new Error("Internal error calculating factor.");
    }

    const newRow = [`${targetX}x`];
    const numCols = rowRef1.length;
    console.log(`Generating new row with ${numCols} columns...`);

    // Interpolate/Extrapolate columns
    for (let j = 1; j < numCols - 1; j++) {
      const colorRef1Str = rowRef1[j];
      const colorRef2Str = rowRef2[j];
      const rgbRef1 = isValidHex(colorRef1Str) ? hexToRgb(colorRef1Str) : null;
      const rgbRef2 = isValidHex(colorRef2Str) ? hexToRgb(colorRef2Str) : null;

      if (rgbRef1 && rgbRef2) {
        const newR = Math.round(rgbRef1.r + (rgbRef2.r - rgbRef1.r) * t);
        const newG = Math.round(rgbRef1.g + (rgbRef2.g - rgbRef1.g) * t);
        const newB = Math.round(rgbRef1.b + (rgbRef2.b - rgbRef1.b) * t);

        const clamp = (val) => Math.max(0, Math.min(255, val));
        newRow.push(rgbToHex(clamp(newR), clamp(newG), clamp(newB)));
      } else {
        newRow.push("-");
      }
    }

    newRow.push(`${targetX}x`);

    // Find insertion index
    let insertIndex = sourceGridData.findIndex((row) => {
      const currentX = parseXValue(row[0]);
      return currentX !== null && currentX < targetX;
    });
    if (insertIndex === -1) {
      let lastXIndex = -1;
      for (let i = sourceGridData.length - 1; i >= 0; i--) {
        if (parseXValue(sourceGridData[i][0]) !== null) {
          lastXIndex = i;
          break;
        }
      }
      insertIndex = lastXIndex !== -1 ? lastXIndex + 1 : sourceGridData.length;
    }

    console.log(`Inserting new row at source index ${insertIndex}`);
    sourceGridData.splice(insertIndex, 0, newRow);

    // Update state and render
    console.log("Updating state and re-rendering...");
    isInterpolationEnabled = false;
    interpolationToggle.checked = false;
    currentGridData = sourceGridData.map((row) => [...row]);
    renderPalette(currentGridData);
    generateXValueInput.value = "";

    // alert(`Generated row ${targetX}x using references ${ref1X}x and ${ref2X}x.`); // Replaced alert
    console.log(`--- Generate Row Successful ---`);
    generateSuccess = true; // Mark success
  } catch (error) {
    console.error("Error generating row:", error);
    // alert(`Error generating row: ${error.message}`); // Replaced alert
    generateSuccess = false; // Mark failure
    // Do not return here, proceed to feedback
  }

  // Provide visual feedback on the button
  if (generateSuccess) {
    generateXButton.textContent = "Generated!";
    generateXButton.classList.remove("error"); // Ensure error class is removed
    generateXButton.classList.add("success");
    setTimeout(() => {
      generateXButton.textContent = originalButtonText;
      generateXButton.classList.remove("success");
    }, 1500);
  } else {
    generateXButton.textContent = "Error";
    generateXButton.classList.remove("success"); // Ensure success class is removed
    generateXButton.classList.add("error");
    setTimeout(() => {
      generateXButton.textContent = originalButtonText;
      generateXButton.classList.remove("error");
    }, 2000);
  }
});

// --- NEW: Popout Dragging State ---
let isDraggingPopout = false;
let popoutStartX, popoutStartY, popoutInitialX, popoutInitialY;

// --- NEW: Popout Resizing State ---
let isResizingPopout = false;
let resizeStartX, resizeStartY, resizeInitialWidth, resizeInitialHeight;

// --- NEW: Snapping Constants ---
const SNAP_THRESHOLD = 20; // Pixels within which snapping occurs
const SNAP_GAP = 16; // Pixels gap from the edge when snapped

// --- Popout Drag Functions (UPDATED for Touch & Button Check) ---
function startPopoutDrag(event) {
  // --- NEW: Prevent drag if target is a button inside the header ---
  if (event.target.closest("button")) {
    // console.log("Popout drag prevented: Target is a button.");
    return;
  }
  // --- END NEW ---

  // Prevent drag if resizing is active
  if (isResizingPopout) return;

  isDraggingPopout = true;
  popoutInitialX = popoutEditor.offsetLeft;
  popoutInitialY = popoutEditor.offsetTop;
  const coords = getEventCoords(event);
  popoutStartX = coords.x;
  popoutStartY = coords.y;

  // Add listeners to the whole document
  document.addEventListener("mousemove", dragPopout);
  document.addEventListener("mouseup", stopPopoutDrag);
  document.addEventListener("touchmove", dragPopout, { passive: false }); // Prevent scroll on touch move
  document.addEventListener("touchend", stopPopoutDrag);

  popoutHeader.style.cursor = "grabbing";
  document.body.style.userSelect = "none"; // Prevent text selection during drag
  if (event.type === "touchstart") {
    event.preventDefault(); // Prevent default touch actions like scrolling
  }
}

function dragPopout(event) {
  if (!isDraggingPopout) return;
  const coords = getEventCoords(event);
  const dx = coords.x - popoutStartX;
  const dy = coords.y - popoutStartY;

  let potentialLeft = popoutInitialX + dx;
  let potentialTop = popoutInitialY + dy;

  // Get editor dimensions and viewport dimensions
  const editorWidth = popoutEditor.offsetWidth;
  const editorHeight = popoutEditor.offsetHeight;
  const viewportWidth = canvasViewport.clientWidth;
  const viewportHeight = canvasViewport.clientHeight;

  // Calculate potential edge positions
  let potentialRight = potentialLeft + editorWidth;
  let potentialBottom = potentialTop + editorHeight;

  // --- Snapping Logic ---
  // Snap Left Edge
  if (Math.abs(potentialLeft) < SNAP_THRESHOLD) {
    potentialLeft = SNAP_GAP;
  }
  // Snap Right Edge
  else if (Math.abs(potentialRight - viewportWidth) < SNAP_THRESHOLD) {
    potentialLeft = viewportWidth - editorWidth - SNAP_GAP;
  }

  // Snap Top Edge
  if (Math.abs(potentialTop) < SNAP_THRESHOLD) {
    potentialTop = SNAP_GAP;
  }
  // Snap Bottom Edge
  else if (Math.abs(potentialBottom - viewportHeight) < SNAP_THRESHOLD) {
    potentialTop = viewportHeight - editorHeight - SNAP_GAP;
  }
  // --- End Snapping ---

  popoutEditor.style.left = `${potentialLeft}px`;
  popoutEditor.style.top = `${potentialTop}px`;

  // Necessary for touchmove to prevent scrolling
  if (event.type === "touchmove") {
    event.preventDefault();
  }
}

function stopPopoutDrag() {
  if (isDraggingPopout) {
    isDraggingPopout = false;
    document.removeEventListener("mousemove", dragPopout);
    document.removeEventListener("mouseup", stopPopoutDrag);
    document.removeEventListener("touchmove", dragPopout);
    document.removeEventListener("touchend", stopPopoutDrag);
    popoutHeader.style.cursor = "move";
    document.body.style.userSelect = ""; // Restore text selection
  }
}

// --- Popout Resize Functions (UPDATED for Touch & Button Check - Unlikely but safe) ---
function startPopoutResize(event) {
  // --- NEW: Prevent resize if target is not the handle itself (optional but safer) ---
  if (event.target !== popoutResizeHandle) {
    // console.log("Popout resize prevented: Target not resize handle.");
    return;
  }
  // --- END NEW ---

  // Prevent resize if dragging is active
  if (isDraggingPopout) return;

  isResizingPopout = true;
  const coords = getEventCoords(event);
  resizeStartX = coords.x;
  resizeStartY = coords.y;
  resizeInitialWidth = popoutEditor.offsetWidth;
  resizeInitialHeight = popoutEditor.offsetHeight;

  // Add listeners to the whole document
  document.addEventListener("mousemove", resizePopout);
  document.addEventListener("mouseup", stopPopoutResize);
  document.addEventListener("touchmove", resizePopout, { passive: false }); // Prevent scroll on touch move
  document.addEventListener("touchend", stopPopoutResize);

  document.body.style.cursor = "nwse-resize"; // Apply resize cursor globally
  document.body.style.userSelect = "none"; // Prevent text selection
  if (event.type === "touchstart") {
    event.preventDefault(); // Prevent default touch actions
  }
}

function resizePopout(event) {
  if (!isResizingPopout) return;
  const coords = getEventCoords(event);
  const dx = coords.x - resizeStartX;
  const dy = coords.y - resizeStartY;

  // Get min dimensions from CSS and current position
  const minWidth = parseInt(getComputedStyle(popoutEditor).minWidth, 10) || 150;
  const minHeight =
    parseInt(getComputedStyle(popoutEditor).minHeight, 10) || 100;
  const currentLeft = popoutEditor.offsetLeft;
  const currentTop = popoutEditor.offsetTop;
  const viewportWidth = canvasViewport.clientWidth;
  const viewportHeight = canvasViewport.clientHeight;

  // Calculate potential new dimensions
  let newWidth = resizeInitialWidth + dx;
  let newHeight = resizeInitialHeight + dy;

  // Enforce minimum dimensions first
  newWidth = Math.max(minWidth, newWidth);
  newHeight = Math.max(minHeight, newHeight);

  // Calculate potential edge positions based on resizing
  let potentialRight = currentLeft + newWidth;
  let potentialBottom = currentTop + newHeight;

  // --- Snapping Logic for Resize ---
  // Snap Right Edge
  if (Math.abs(potentialRight - viewportWidth) < SNAP_THRESHOLD) {
    newWidth = viewportWidth - currentLeft - SNAP_GAP;
    // Re-check min width after snapping
    newWidth = Math.max(minWidth, newWidth);
  }
  // Snap Bottom Edge
  if (Math.abs(potentialBottom - viewportHeight) < SNAP_THRESHOLD) {
    newHeight = viewportHeight - currentTop - SNAP_GAP;
    // Re-check min height after snapping
    newHeight = Math.max(minHeight, newHeight);
  }
  // --- End Snapping ---

  popoutEditor.style.width = `${newWidth}px`;
  popoutEditor.style.height = `${newHeight}px`;

  // Necessary for touchmove to prevent scrolling
  if (event.type === "touchmove") {
    event.preventDefault();
  }
}

function stopPopoutResize() {
  if (isResizingPopout) {
    isResizingPopout = false;
    document.removeEventListener("mousemove", resizePopout);
    document.removeEventListener("mouseup", stopPopoutResize);
    document.removeEventListener("touchmove", resizePopout);
    document.removeEventListener("touchend", stopPopoutResize);
    document.body.style.cursor = ""; // Restore default cursor
    document.body.style.userSelect = ""; // Restore text selection
  }
}

// --- Popout Drag Listeners (UPDATED for Touch & Snap) ---
popoutHeader.addEventListener("mousedown", startPopoutDrag);
popoutHeader.addEventListener("touchstart", startPopoutDrag, {
  passive: false,
}); // Add touch listener

// --- Popout Resize Listener (UPDATED for Touch & Snap) ---
popoutResizeHandle.addEventListener("mousedown", startPopoutResize);
popoutResizeHandle.addEventListener("touchstart", startPopoutResize, {
  passive: false,
}); // Add touch listener

// --- NEW: Popout Update Button Listener (Uses Status Message) ---
popoutUpdateButton.addEventListener("click", () => {
  const textData = popoutPaletteInput.value;
  const originalButtonText = popoutUpdateButton.textContent; // Store original text
  let updateSuccess = false; // Flag to track success

  try {
    const newDataParsed = parseSimpleFormat(textData);
    if (
      !Array.isArray(newDataParsed) ||
      newDataParsed.length === 0 ||
      !Array.isArray(newDataParsed[0])
    ) {
      throw new Error("Parsed data is not a valid grid.");
    }
    sourceGridData = newDataParsed;
    isInterpolationEnabled = false; // Reset interpolation
    interpolationToggle.checked = false;
    currentGridData = sourceGridData.map((row) => [...row]);
    renderPalette(currentGridData); // Re-render main palette
    updateSuccess = true; // Mark as success
    // showPopoutStatus('Palette updated.', false); // REMOVE: Use button feedback instead
  } catch (error) {
    console.error("Error parsing or processing text input:", error);
    // showPopoutStatus(`Error: ${error.message}`, true); // REMOVE: Use button feedback instead
    updateSuccess = false; // Mark as failure
  }

  // Provide visual feedback on the button
  if (updateSuccess) {
    popoutUpdateButton.textContent = "Updated!"; // Success feedback
    // Optional: add a 'success' class for styling
    setTimeout(() => {
      popoutUpdateButton.textContent = originalButtonText; // Reset text
      // Optional: remove the 'success' class
    }, 1500); // Show feedback for 1.5 seconds
  } else {
    popoutUpdateButton.textContent = "Error"; // Error feedback
    // Optional: add an 'error' class for styling
    setTimeout(() => {
      popoutUpdateButton.textContent = originalButtonText; // Reset text
      // Optional: remove the 'error' class
    }, 2000); // Show feedback slightly longer for errors
  }
});
// --- NEW: Popout Status Message Logic ---
let statusTimeout = null;

function showPopoutStatus(message, isError = false) {
  if (!popoutStatusMessage) return; // Element might not exist yet

  clearTimeout(statusTimeout);

  popoutStatusMessage.textContent = message;
  popoutStatusMessage.classList.remove("success", "error", "visible");

  // Need a tiny delay before adding class for transition to work if classes were just removed
  requestAnimationFrame(() => {
    popoutStatusMessage.classList.add(isError ? "error" : "success");
    popoutStatusMessage.classList.add("visible");

    // Set timeout to hide the message
    statusTimeout = setTimeout(() => {
      popoutStatusMessage.classList.remove("visible");
      // Optional: clear text after fade out
      // setTimeout(() => { popoutStatusMessage.textContent = ''; }, 300);
    }, 3000); // Display for 3 seconds
  });
}

// --- NEW: Palette Export Function ---
function exportPaletteData() {
  const originalButtonText = exportPaletteButton.textContent; // Store original text
  let exportSuccess = false; // Flag for feedback

  try {
    // Convert to YAML format instead of simple format
    const yamlData = convertGridToYAML(sourceGridData);
    const blob = new Blob([yamlData], { type: "text/yaml;charset=utf-8" });
    const url = URL.createObjectURL(blob);

    const downloadLink = document.createElement("a");
    downloadLink.href = url;
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    downloadLink.download = `palette_${timestamp}.yaml`;

    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
    URL.revokeObjectURL(url);

    console.log("Palette data exported.");
    // alert('Palette exported as .txt file.'); // Replaced alert
    exportSuccess = true; // Mark success
  } catch (error) {
    console.error("Error exporting palette data:", error);
    // alert('Failed to export palette data.'); // Replaced alert
    exportSuccess = false; // Mark failure
    // Do not return here, proceed to feedback
  }

  // Provide visual feedback on the button
  if (exportSuccess) {
    exportPaletteButton.textContent = "Exported!";
    exportPaletteButton.classList.remove("error"); // Ensure error class removed
    exportPaletteButton.classList.add("success");
    setTimeout(() => {
      exportPaletteButton.textContent = originalButtonText;
      exportPaletteButton.classList.remove("success");
    }, 1500);
  } else {
    exportPaletteButton.textContent = "Failed to Export";
    exportPaletteButton.classList.remove("success"); // Ensure success class removed
    exportPaletteButton.classList.add("error");
    setTimeout(() => {
      exportPaletteButton.textContent = originalButtonText;
      exportPaletteButton.classList.remove("error");
    }, 2000);
  }
}

// --- Local Storage Functions ---

function saveStateToLocalStorage() {
  const originalButtonText = saveStateButton.textContent; // Store original text
  let saveSuccess = false; // Flag for feedback

  try {
    const stateToSave = {
      sourceGridData: sourceGridData,
      isInterpolationEnabled: isInterpolationEnabled,
      interpolationSteps: interpolationSteps,
      saturationOffset: saturationOffset,
      paletteZoom: scale,
      paletteOffsetX: paletteOffsetX,
      paletteOffsetY: paletteOffsetY,
      uiScalePercent: parseInt(uiScaleNumber.value || "100", 10),
      timestamp: new Date().toISOString(),
      popout: {
        left: popoutEditor.style.left || "",
        top: popoutEditor.style.top || "",
        width: popoutEditor.style.width || "",
        height: popoutEditor.style.height || "",
      },
    };
    localStorage.setItem(localStorageKey, JSON.stringify(stateToSave));
    console.log("Application state saved to local storage.");
    // alert('Current state saved!'); // Replaced alert
    saveSuccess = true; // Mark success
    // Update timestamp display
    if (stateTimestampDiv) {
      stateTimestampDiv.textContent = `Last saved: ${new Date().toLocaleString()}`;
    }
  } catch (error) {
    console.error("Error saving state to local storage:", error);
    // alert('Failed to save state. Local storage might be full or disabled.'); // Replaced alert
    saveSuccess = false; // Mark failure
    // Do not return here, proceed to feedback
  }

  // Provide visual feedback on the button
  if (saveSuccess) {
    saveStateButton.textContent = "Saved!";
    saveStateButton.classList.remove("error"); // Ensure error class removed
    saveStateButton.classList.add("success");
    setTimeout(() => {
      saveStateButton.textContent = originalButtonText;
      saveStateButton.classList.remove("success");
    }, 1500);
  } else {
    saveStateButton.textContent = "Failed to Save";
    saveStateButton.classList.remove("success"); // Ensure success class removed
    saveStateButton.classList.add("error");
    setTimeout(() => {
      saveStateButton.textContent = originalButtonText;
      saveStateButton.classList.remove("error");
    }, 2000);
  }
}

function loadStateFromLocalStorage() {
  try {
    const savedStateJSON = localStorage.getItem(localStorageKey);
    if (!savedStateJSON) {
      console.log("No saved state found in local storage.");
      stateLoadedSuccessfully = false;
      return;
    }
    const savedState = JSON.parse(savedStateJSON);
    console.log("Loading saved state:", savedState);

    // Reset the flag at the start of loading
    stateLoadedSuccessfully = false;

    // Display timestamp if available
    if (savedState.timestamp && stateTimestampDiv) {
      stateTimestampDiv.textContent = `Last saved: ${new Date(savedState.timestamp).toLocaleString()}`;
    }

    if (
      Array.isArray(savedState.sourceGridData) &&
      savedState.sourceGridData.length > 0 &&
      Array.isArray(savedState.sourceGridData[0])
    ) {
      sourceGridData = savedState.sourceGridData;
      currentGridData = sourceGridData.map((row) => [...row]);
    } else {
      console.warn("Loaded sourceGridData is invalid, using default.");
    }
    isInterpolationEnabled =
      typeof savedState.isInterpolationEnabled === "boolean"
        ? savedState.isInterpolationEnabled
        : false;
    interpolationSteps =
      typeof savedState.interpolationSteps === "number"
        ? savedState.interpolationSteps
        : 1;
    saturationOffset =
      typeof savedState.saturationOffset === "number"
        ? savedState.saturationOffset
        : 0;
    scale =
      typeof savedState.paletteZoom === "number"
        ? Math.max(minScale, Math.min(maxScale, savedState.paletteZoom))
        : 1;
    paletteOffsetX =
      typeof savedState.paletteOffsetX === "number"
        ? savedState.paletteOffsetX
        : 50;
    paletteOffsetY =
      typeof savedState.paletteOffsetY === "number"
        ? savedState.paletteOffsetY
        : 50;
    const uiScalePercent =
      typeof savedState.uiScalePercent === "number"
        ? savedState.uiScalePercent
        : 100;
    applyUiScale(uiScalePercent);
    if (savedState.popout) {
      if (savedState.popout.left)
        popoutEditor.style.left = savedState.popout.left;
      if (savedState.popout.top) popoutEditor.style.top = savedState.popout.top;
      if (savedState.popout.width)
        popoutEditor.style.width = savedState.popout.width;
      if (savedState.popout.height)
        popoutEditor.style.height = savedState.popout.height;
    }
    interpolationToggle.checked = isInterpolationEnabled;
    stepsSlider.value = interpolationSteps;
    stepsNumber.value = interpolationSteps;
    saturationOffsetSlider.value = saturationOffset;
    saturationOffsetNumber.value = saturationOffset;
    zoomSlider.value = scale * 100;
    zoomNumber.value = scale * 100;
    console.log("Successfully loaded state from local storage.");
  } catch (error) {
    console.error("Error loading or parsing state from local storage:", error);
  }
}

// --- State Management Listeners ---
saveStateButton.addEventListener("click", saveStateToLocalStorage);
resetStateButton.addEventListener("click", () => {
  if (
    confirm(
      "Are you sure you want to reset all saved settings and reload the page?",
    )
  ) {
    try {
      localStorage.removeItem(localStorageKey);
      console.log("Saved state removed from local storage.");
      // alert('State reset. Reloading page...'); // REMOVED alert
      location.reload();
    } catch (error) {
      console.error("Error removing state from local storage:", error);
      // alert('Failed to reset state. Please clear local storage manually if needed.'); // This error is less common and might still warrant an alert, but let's remove for consistency. Could replace with a non-blocking message if a dedicated UI element existed.
      console.warn("Manual local storage clear might be needed.");
    }
  }
});

// Reset View button listener
if (resetViewButton) {
  resetViewButton.addEventListener("click", resetView);
}

// --- NEW: Palette Export Listener ---
exportPaletteButton.addEventListener("click", exportPaletteData);

// --- Palette Import Logic --- (Implementation)
function handlePaletteImport(file) {
  const originalButtonText = importPaletteButton.textContent; // Store original text
  let importSuccess = false; // Flag for feedback, will be set inside onload/onerror

  if (
    !file ||
    (!file.type.match("text.*") &&
      !file.name.endsWith(".yaml") &&
      !file.name.endsWith(".yml"))
  ) {
    console.warn("No text/yaml file selected or file type not supported.");
    // alert('Please select a valid .txt/.yaml file.'); // Replaced alert
    importPaletteButton.textContent = "Invalid File"; // Immediate feedback
    importPaletteButton.classList.add("error");
    setTimeout(() => {
      importPaletteButton.textContent = originalButtonText;
      importPaletteButton.classList.remove("error");
    }, 2000);
    return; // Exit function
  }

  const reader = new FileReader();

  reader.onload = (event) => {
    const textData = event.target.result;
    try {
      // Try to parse as YAML first, fall back to simple format
      let newDataParsed;
      if (
        file.name.endsWith(".yaml") ||
        file.name.endsWith(".yml") ||
        textData.trim().startsWith("palette:")
      ) {
        newDataParsed = convertYAMLToGrid(textData);
        if (!newDataParsed) {
          throw new Error("Failed to parse YAML format");
        }
      } else {
        newDataParsed = parseSimpleFormat(textData);
      }
      if (
        !Array.isArray(newDataParsed) ||
        newDataParsed.length === 0 ||
        !Array.isArray(newDataParsed[0])
      ) {
        throw new Error("Imported data is not a valid grid. Check format.");
      }
      // Basic validation (heuristic)
      if (newDataParsed.length > 0 && newDataParsed[0].length > 0) {
        const firstCell = newDataParsed[0][0];
        const lastCell = newDataParsed[0][newDataParsed[0].length - 1];
        if (typeof firstCell !== "string" || typeof lastCell !== "string") {
          console.warn(
            "Imported data format warning: First/last cells of first row may not be labels.",
          );
        }
      }

      sourceGridData = newDataParsed;
      isInterpolationEnabled = false;
      interpolationToggle.checked = false;
      currentGridData = sourceGridData.map((row) => [...row]);
      renderPalette(currentGridData); // Re-render main palette

      // alert('Palette imported successfully!'); // Replaced alert
      console.log("Palette data imported from file:", file.name);
      importSuccess = true; // Mark success

      // If popout is open, update its content too
      if (popoutEditor.style.display === "flex") {
        popoutPaletteInput.value = convertToSimpleFormat(sourceGridData);
        // showPopoutStatus('Palette imported.', false); // REMOVED: Use button feedback
      }
    } catch (error) {
      console.error("Error parsing or processing imported file:", error);
      // alert(`Error importing palette: ${error.message}`); // Replaced alert
      importSuccess = false; // Mark failure
      // Do not re-throw, proceed to feedback
    }

    // Provide visual feedback on the button after load/error
    if (importSuccess) {
      importPaletteButton.textContent = "Imported!";
      importPaletteButton.classList.remove("error");
      importPaletteButton.classList.add("success");
      setTimeout(() => {
        importPaletteButton.textContent = originalButtonText;
        importPaletteButton.classList.remove("success");
      }, 1500);
    } else {
      importPaletteButton.textContent = "Import Failed";
      importPaletteButton.classList.remove("success");
      importPaletteButton.classList.add("error");
      setTimeout(() => {
        importPaletteButton.textContent = originalButtonText;
        importPaletteButton.classList.remove("error");
      }, 2000);
    }
  };

  reader.onerror = (event) => {
    console.error("File reading error:", event.target.error);
    // alert('Error reading the selected file.'); // Replaced alert
    importSuccess = false; // Mark failure

    // Provide visual feedback on the button after error
    importPaletteButton.textContent = "Read Error"; // Specific error
    importPaletteButton.classList.remove("success");
    importPaletteButton.classList.add("error");
    setTimeout(() => {
      importPaletteButton.textContent = originalButtonText;
      importPaletteButton.classList.remove("error");
    }, 2000);
  };

  reader.readAsText(file); // Read the file as text
}

importPaletteButton.addEventListener("click", () => {
  importPaletteFileInput.click(); // Trigger the hidden file input
});

importPaletteFileInput.addEventListener("change", (event) => {
  const file = event.target.files[0];
  if (file) {
    handlePaletteImport(file);
  }
  // Reset the input value so the change event fires even if the same file is selected again
  event.target.value = null;
});

// --- NEW: Color Picker Functions ---
function updatePickerPreview(hex) {
  colorPickerPreview.style.backgroundColor = hex;
  // Optional: Update hue slider background dynamically
  // pickerHueSlider.style.background = \`linear-gradient(to right, hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(360, 100%, 50%))\`;
}

function updatePickerFromHsl() {
  if (isPickerUpdating) return;
  isPickerUpdating = true;

  const h = parseInt(pickerHueNumber.value, 10);
  const s = parseInt(pickerSatNumber.value, 10);
  const l = parseInt(pickerLumNumber.value, 10);

  if (isNaN(h) || isNaN(s) || isNaN(l)) {
    isPickerUpdating = false;
    return; // Avoid errors if inputs are temporarily invalid
  }

  const newHex = hslToHex(h, s, l);
  pickerHexInput.value = newHex.toUpperCase();
  updatePickerPreview(newHex);

  isPickerUpdating = false;
}

function updatePickerFromHex() {
  if (isPickerUpdating) return;
  isPickerUpdating = true;

  let hex = pickerHexInput.value;
  if (!hex.startsWith("#")) {
    hex = "#" + hex;
  }

  if (isValidHex(hex)) {
    const hsl = hexToHsl(hex);
    if (hsl) {
      pickerHueSlider.value = hsl.h;
      pickerHueNumber.value = hsl.h;
      pickerSatSlider.value = hsl.s;
      pickerSatNumber.value = hsl.s;
      pickerLumSlider.value = hsl.l;
      pickerLumNumber.value = hsl.l;
      updatePickerPreview(hex);
      pickerHexInput.value = hex.toUpperCase(); // Ensure # and uppercase
    } else {
      console.warn("Could not convert valid HEX to HSL:", hex);
    }
  } else {
    // Maybe add visual feedback for invalid hex
    console.log("Invalid HEX input:", hex);
  }

  isPickerUpdating = false;
}

function openColorPicker(rowIndex, cellIndex, event = null) {
  // Check if source data exists for the coordinates (use first selected)
  if (
    rowIndex >= sourceGridData.length ||
    cellIndex >= sourceGridData[rowIndex].length
  ) {
    console.error(
      `Invalid coordinates for sourceGridData: [${rowIndex}][${cellIndex}]`,
    );
    clearSelection(); // Clear potentially invalid selection
    return;
  }
  const originalHex = sourceGridData[rowIndex][cellIndex];

  if (!isValidHex(originalHex)) {
    console.error(
      `Cannot open picker: Cell at source[${rowIndex}][${cellIndex}] is not a valid HEX color.`,
      originalHex,
    );
    clearSelection(); // Clear invalid selection
    return;
  }

  // We no longer store targetRow/Col globally, rely on selectedCells
  // pickerTargetRow = rowIndex;
  // pickerTargetCol = cellIndex;

  const hsl = hexToHsl(originalHex);
  if (!hsl) {
    console.error("Error converting initial HEX to HSL:", originalHex);
    clearSelection(); // Clear invalid selection
    return;
  }

  isPickerUpdating = true;

  // Determine if Multi-Select Mode
  const isMultiSelect = selectedCells.length > 1;
  const firstSelectedHsl = hsl; // HSL of the first selected cell

  // --- Flags to determine if controls should be disabled in multi-select ---
  let shouldDisableH = false; // NEW Hue flag
  let shouldDisableS = false;
  let shouldDisableL = false;

  if (isMultiSelect) {
    // Iterate through OTHER selected cells to check for variance
    for (let i = 1; i < selectedCells.length; i++) {
      const [r, c] = selectedCells[i];
      if (r < sourceGridData.length && c < sourceGridData[r].length) {
        const currentHex = sourceGridData[r][c];
        const currentHsl = hexToHsl(currentHex);
        if (currentHsl) {
          // --- NEW: Check Hue Variance ---
          if (
            !shouldDisableH &&
            getHueDifference(currentHsl.h, firstSelectedHsl.h) >
              multiSelectHueTolerance
          ) {
            shouldDisableH = true;
          }
          // --- END NEW ---

          if (
            !shouldDisableS &&
            Math.abs(currentHsl.s - firstSelectedHsl.s) > multiSelectTolerance
          ) {
            shouldDisableS = true;
          }
          if (
            !shouldDisableL &&
            Math.abs(currentHsl.l - firstSelectedHsl.l) > multiSelectTolerance
          ) {
            shouldDisableL = true;
          }
          // Optimization: If all are disabled, no need to check further
          if (shouldDisableH && shouldDisableS && shouldDisableL) break;
        } else {
          console.warn(
            `Could not get HSL for selected cell [${r},${c}] during variance check.`,
          );
        }
      }
    }
  }
  // --- END Check variance ---

  // Set initial values based on the *first* selected cell
  pickerHueSlider.value = firstSelectedHsl.h;
  pickerHueNumber.value = firstSelectedHsl.h; // Keep initial set
  pickerSatSlider.value = firstSelectedHsl.s;
  pickerSatNumber.value = firstSelectedHsl.s; // Keep initial set
  pickerLumSlider.value = firstSelectedHsl.l;
  pickerLumNumber.value = firstSelectedHsl.l; // Keep initial set
  pickerHexInput.value = isMultiSelect ? "Multiple" : originalHex.toUpperCase();
  updatePickerPreview(originalHex);

  // --- Enable/Disable Controls based on mode and variance AND UPDATE DISPLAY ---
  pickerHexInput.disabled = isMultiSelect; // Hex always disabled in multi

  // --- Hue Controls ---
  pickerHueSlider.disabled = isMultiSelect && shouldDisableH;
  pickerHueNumber.disabled = isMultiSelect && shouldDisableH;
  if (pickerHueNumber.disabled) {
    pickerHueNumber.value = ""; // Clear value if disabled
    pickerHueNumber.placeholder = "Varies"; // Show placeholder
  } else {
    pickerHueNumber.value = firstSelectedHsl.h; // Ensure value is set if enabled
    pickerHueNumber.placeholder = ""; // Clear placeholder
  }

  // --- Saturation Controls ---
  pickerSatSlider.disabled = isMultiSelect && shouldDisableS;
  pickerSatNumber.disabled = isMultiSelect && shouldDisableS;
  if (pickerSatNumber.disabled) {
    pickerSatNumber.value = "";
    pickerSatNumber.placeholder = "Varies";
  } else {
    pickerSatNumber.value = firstSelectedHsl.s;
    pickerSatNumber.placeholder = "";
  }

  // --- Luminance Controls ---
  pickerLumSlider.disabled = isMultiSelect && shouldDisableL;
  pickerLumNumber.disabled = isMultiSelect && shouldDisableL;
  if (pickerLumNumber.disabled) {
    pickerLumNumber.value = "";
    pickerLumNumber.placeholder = "Varies";
  } else {
    pickerLumNumber.value = firstSelectedHsl.l;
    pickerLumNumber.placeholder = "";
  }

  // Add/Remove visual class for disabled state
  pickerHueSlider
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerHueSlider.disabled); // Use slider's disabled state
  pickerHexInput
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerHexInput.disabled);
  pickerSatSlider
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerSatSlider.disabled);
  pickerLumSlider
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerLumSlider.disabled);

  // --- Update Title ---
  colorPickerModal.querySelector(".color-picker-title").textContent =
    isMultiSelect ? `Edit ${selectedCells.length} Colors` : "Edit Color";

  // --- Position the modal near the event location (mouse or touch) ---
  if (event) {
    const coords = getEventCoords(event);
    const viewportWidth = canvasViewport.clientWidth;
    const viewportHeight = canvasViewport.clientHeight;
    const modalWidth = colorPickerModal.offsetWidth;
    const modalHeight = colorPickerModal.offsetHeight;
    const cursorOffset = 20; // Pixels offset from cursor

    let targetX = coords.x + cursorOffset;
    let targetY = coords.y + cursorOffset;

    // Prevent spawning off the right edge
    if (targetX + modalWidth > viewportWidth) {
      targetX = coords.x - modalWidth - cursorOffset; // Try left of cursor
      // If still off-screen (e.g., modal wider than viewport), align to right edge
      if (targetX < 0)
        targetX = Math.max(0, viewportWidth - modalWidth - SNAP_GAP); // Use SNAP_GAP as a small margin
    }
    // If it's still off-screen after trying left (e.g., near right edge and modal wide), align to right
    if (targetX + modalWidth > viewportWidth) {
      targetX = Math.max(0, viewportWidth - modalWidth - SNAP_GAP);
    }

    // Prevent spawning off the bottom edge
    if (targetY + modalHeight > viewportHeight) {
      targetY = coords.y - modalHeight - cursorOffset; // Try above cursor
      // If still off-screen (e.g., modal taller than viewport), align to bottom edge
      if (targetY < 0)
        targetY = Math.max(0, viewportHeight - modalHeight - SNAP_GAP); // Use SNAP_GAP
    }
    // If it's still off-screen after trying above (e.g., near bottom edge and modal tall), align to bottom
    if (targetY + modalHeight > viewportHeight) {
      targetY = Math.max(0, viewportHeight - modalHeight - SNAP_GAP);
    }

    // Ensure it's not off the left or top edge
    targetX = Math.max(SNAP_GAP, targetX); // Use SNAP_GAP as a small margin
    targetY = Math.max(SNAP_GAP, targetY); // Use SNAP_GAP

    colorPickerModal.style.left = `${targetX}px`;
    colorPickerModal.style.top = `${targetY}px`;

    console.log(`Positioning picker at: (${targetX}, ${targetY})`);
  } else {
    // Fallback to default position if no event provided
    console.log("No event provided, using default picker position.");
    colorPickerModal.style.left = "150px";
    colorPickerModal.style.top = "150px";
  }
  // --- END Position the modal ---

  colorPickerModal.classList.add("visible");
  isPickerUpdating = false;

  // --- Focus appropriate element ---
  if (isMultiSelect) {
    // Try focusing the first *enabled* slider (H, L, or S)
    if (!pickerHueSlider.disabled) {
      pickerHueSlider.focus();
    } else if (!pickerLumSlider.disabled) {
      pickerLumSlider.focus();
    } else if (!pickerSatSlider.disabled) {
      pickerSatSlider.focus();
    } // else maybe focus Apply button?
  } else {
    pickerHueSlider.focus(); // Focus Hue for single edit
  }
}

function closeColorPicker() {
  colorPickerModal.classList.remove("visible");
  // Clear selection when picker is closed manually
  clearSelection();
  // Re-enable potentially disabled controls for next time
  pickerHueSlider.disabled = false;
  pickerHueNumber.disabled = false;
  pickerHexInput.disabled = false;
  // --- Re-enable S/L controls ---
  pickerSatSlider.disabled = false;
  pickerSatNumber.disabled = false;
  pickerLumSlider.disabled = false;
  pickerLumNumber.disabled = false;

  // Remove disabled classes
  pickerHueSlider.closest(".picker-control-group").classList.remove("disabled");
  pickerHexInput.closest(".picker-control-group").classList.remove("disabled");
  // --- Remove disabled class for S/L ---
  pickerSatSlider.closest(".picker-control-group").classList.remove("disabled");
  pickerLumSlider.closest(".picker-control-group").classList.remove("disabled");
}

// --- Event Listeners ---

// Buttons
pickerApplyButton.addEventListener("click", (event) => {
  if (touchEventHandled) {
    touchEventHandled = false;
    return;
  }

  if (selectedCells.length === 0) {
    console.warn("Apply clicked with no cells selected.");
    closeColorPicker();
    return;
  }

  const originalButtonText = pickerApplyButton.textContent; // Store original text

  const isMultiSelect = selectedCells.length > 1;
  let applySuccess = false;

  if (isMultiSelect) {
    // --- Use helper function for multi-select logic ---
    applySuccess = applyMultiSelectChanges();
    // --- End Use helper function ---
  } else {
    // Apply changes to a single cell (H, S, L)
    const [rowIndex, colIndex] = selectedCells[0];
    const finalHex = pickerHexInput.value;

    if (isValidHex(finalHex)) {
      if (
        rowIndex < sourceGridData.length &&
        colIndex < sourceGridData[rowIndex].length
      ) {
        sourceGridData[rowIndex][colIndex] = finalHex;
        console.log(`Applied ${finalHex} to cell [${rowIndex}, ${colIndex}].`);
        applySuccess = true;
      } else {
        console.warn(
          `Invalid coordinates for single apply: [${rowIndex}, ${colIndex}]`,
        );
        applySuccess = false; // Consider this a failure? Or just log?
      }
    } else {
      // alert("Invalid HEX code. Cannot apply."); // Keep alert for prominent feedback
      console.error("Single apply failed: Invalid HEX.", finalHex);
      applySuccess = false;
      // return; // Keep picker open on error
    }
  }

  // Provide visual feedback
  if (applySuccess) {
    updatePaletteView();
    pickerApplyButton.textContent = "Applied!"; // Success feedback
    // You could also add a class like pickerApplyButton.classList.add('success');
    setTimeout(() => {
      pickerApplyButton.textContent = originalButtonText; // Reset text
      // pickerApplyButton.classList.remove('success');
    }, 1500); // Show feedback for 1.5 seconds
  } else {
    // Failure feedback (specifically for invalid HEX for now)
    pickerApplyButton.textContent = "Invalid HEX"; // Error feedback
    // You could also add a class like pickerApplyButton.classList.add('error');
    setTimeout(() => {
      pickerApplyButton.textContent = originalButtonText; // Reset text
      // pickerApplyButton.classList.remove('error');
    }, 2000); // Show feedback slightly longer for errors
  }
});

// --- Touch End handler for Apply Button ---
if (isTouchDevice) {
  pickerApplyButton.addEventListener(
    "touchend",
    (event) => {
      if (pointerHasMoved) return;
      event.preventDefault();
      event.stopPropagation();

      if (selectedCells.length === 0) {
        console.warn("Apply touchend with no cells selected.");
        closeColorPicker();
        return;
      }

      const originalButtonText = pickerApplyButton.textContent; // Store original text

      const isMultiSelect = selectedCells.length > 1;
      let applySuccess = false;

      if (isMultiSelect) {
        // --- Use helper function for multi-select logic ---
        applySuccess = applyMultiSelectChanges();
        // --- End Use helper function ---
      } else {
        // Single select logic (same as click handler)
        const [rowIndex, colIndex] = selectedCells[0];
        const finalHex = pickerHexInput.value;
        if (isValidHex(finalHex)) {
          if (
            rowIndex < sourceGridData.length &&
            colIndex < sourceGridData[rowIndex].length
          ) {
            sourceGridData[rowIndex][colIndex] = finalHex;
            console.log(
              `Applied ${finalHex} by touch to cell [${rowIndex}, ${colIndex}].`,
            );
            applySuccess = true;
          } else {
            console.warn(
              `Invalid coords for single apply touch: [${rowIndex}, ${colIndex}]`,
            );
            applySuccess = false;
          }
        } else {
          // alert("Invalid HEX code. Cannot apply.");
          console.error("Single apply touch failed: Invalid HEX.", finalHex);
          applySuccess = false;
        }
      }

      // Provide visual feedback
      if (applySuccess) {
        updatePaletteView();
        pickerApplyButton.textContent = "Applied!"; // Success feedback
        setTimeout(() => {
          pickerApplyButton.textContent = originalButtonText; // Reset text
        }, 1500); // Show feedback for 1.5 seconds
      } else {
        // Failure feedback
        pickerApplyButton.textContent = "Invalid HEX"; // Error feedback
        setTimeout(() => {
          pickerApplyButton.textContent = originalButtonText; // Reset text
        }, 2000); // Show feedback slightly longer for errors
      }
      touchEventHandled = true;
    },
    { passive: false },
  );
}

// --- NEW: Color Picker Control Event Listeners ---

// Close Button
colorPickerCloseButton.addEventListener("click", closeColorPicker);

// HSL Sliders and Number Inputs Synchronization
[pickerHueSlider, pickerHueNumber].forEach((el) => {
  el.addEventListener("input", () => {
    if (isPickerUpdating || pickerHueSlider.disabled) return; // Check disabled state
    const h = parseInt(el.value, 10);
    if (!isNaN(h)) {
      pickerHueSlider.value = h;
      pickerHueNumber.value = h;
      updatePickerFromHsl();
    }
  });
});

[pickerSatSlider, pickerSatNumber].forEach((el) => {
  el.addEventListener("input", () => {
    // --- Check disabled state ---
    if (isPickerUpdating || pickerSatSlider.disabled) return;
    const s = parseInt(el.value, 10);
    if (!isNaN(s)) {
      pickerSatSlider.value = s;
      pickerSatNumber.value = s;
      updatePickerFromHsl();
    }
  });
});

[pickerLumSlider, pickerLumNumber].forEach((el) => {
  el.addEventListener("input", () => {
    // --- Check disabled state ---
    if (isPickerUpdating || pickerLumSlider.disabled) return;
    const l = parseInt(el.value, 10);
    if (!isNaN(l)) {
      pickerLumSlider.value = l;
      pickerLumNumber.value = l;
      updatePickerFromHsl();
    }
  });
});

// HEX Input Listener
pickerHexInput.addEventListener("change", () => {
  // Use 'change' to trigger after blur or Enter
  if (isPickerUpdating || pickerHexInput.disabled) return; // Check disabled state
  updatePickerFromHex();
});

// Copy HEX Button
pickerCopyHexButton.addEventListener("click", () => {
  const hexValue = pickerHexInput.value;
  // Only copy if it's a valid hex (or "Multiple" if we want to prevent copying that)
  if (isValidHex(hexValue)) {
    // Use the existing copy function but target the button itself for feedback
    copyToClipboard(hexValue, pickerCopyHexButton);
  } else if (hexValue !== "Multiple") {
    console.warn("Attempted to copy invalid HEX:", hexValue);
    // Optional: Add visual feedback for failed copy
    pickerCopyHexButton.textContent = "Invalid";
    setTimeout(() => {
      pickerCopyHexButton.textContent = "Copy";
    }, 1500);
  }
});

// Color Pick Toggle Button Listener
colorPickToggleButton.addEventListener("click", () => {
  isColorPickingMode = !isColorPickingMode;
  colorPickToggleButton.classList.toggle("active", isColorPickingMode);
  document.body.classList.toggle("color-picking-active", isColorPickingMode);
  console.log("Color Picking Mode:", isColorPickingMode ? "ON" : "OFF");

  // Clear selection when toggling mode off
  if (!isColorPickingMode) {
    clearSelection();
    if (colorPickerModal.classList.contains("visible")) {
      closeColorPicker(); // Also close picker if open
    }
  }
});

// --- NEW: Color Picker Drag Functions ---
function startColorPickerDrag(event) {
  // --- NEW: Prevent drag if target is a button inside the header ---
  if (event.target.closest("button")) {
    // console.log("Color Picker drag prevented: Target is a button.");
    return;
  }
  // --- END NEW ---

  if (isResizingColorPicker) return; // Don't drag if resizing

  isDraggingColorPicker = true;
  pickerInitialX = colorPickerModal.offsetLeft;
  pickerInitialY = colorPickerModal.offsetTop;
  const coords = getEventCoords(event);
  pickerStartX = coords.x;
  pickerStartY = coords.y;

  document.addEventListener("mousemove", dragColorPicker);
  document.addEventListener("mouseup", stopColorPickerDrag);
  document.addEventListener("touchmove", dragColorPicker, { passive: false });
  document.addEventListener("touchend", stopColorPickerDrag);

  colorPickerHeader.style.cursor = "grabbing";
  document.body.style.userSelect = "none";
  if (event.type === "touchstart") {
    event.preventDefault();
  }
}

function dragColorPicker(event) {
  if (!isDraggingColorPicker) return;
  const coords = getEventCoords(event);
  const dx = coords.x - pickerStartX;
  const dy = coords.y - pickerStartY;

  let newLeft = pickerInitialX + dx;
  let newTop = pickerInitialY + dy;

  // Basic boundary checks (optional, could add snapping later)
  const viewportWidth = canvasViewport.clientWidth;
  const viewportHeight = canvasViewport.clientHeight;
  const modalWidth = colorPickerModal.offsetWidth;
  const modalHeight = colorPickerModal.offsetHeight;

  newLeft = Math.max(0, Math.min(newLeft, viewportWidth - modalWidth));
  newTop = Math.max(0, Math.min(newTop, viewportHeight - modalHeight));

  colorPickerModal.style.left = `${newLeft}px`;
  colorPickerModal.style.top = `${newTop}px`;

  if (event.type === "touchmove") {
    event.preventDefault();
  }
}

function stopColorPickerDrag() {
  if (isDraggingColorPicker) {
    isDraggingColorPicker = false;
    document.removeEventListener("mousemove", dragColorPicker);
    document.removeEventListener("mouseup", stopColorPickerDrag);
    document.removeEventListener("touchmove", dragColorPicker);
    document.removeEventListener("touchend", stopColorPickerDrag);
    colorPickerHeader.style.cursor = "move";
    document.body.style.userSelect = "";
  }
}

// --- NEW: Color Picker Resize Functions ---
function startColorPickerResize(event) {
  // --- NEW: Prevent resize if target is not the handle itself (optional but safer) ---
  if (event.target !== colorPickerResizeHandle) {
    // console.log("Color Picker resize prevented: Target not resize handle.");
    return;
  }
  // --- END NEW ---

  if (isDraggingColorPicker) return; // Don't resize if dragging

  isResizingColorPicker = true;
  const coords = getEventCoords(event);
  cpResizeStartX = coords.x;
  cpResizeStartY = coords.y;
  cpResizeInitialWidth = colorPickerModal.offsetWidth;
  cpResizeInitialHeight = colorPickerModal.offsetHeight;

  document.addEventListener("mousemove", resizeColorPicker);
  document.addEventListener("mouseup", stopColorPickerResize);
  document.addEventListener("touchmove", resizeColorPicker, { passive: false });
  document.addEventListener("touchend", stopColorPickerResize);

  document.body.style.cursor = "nwse-resize";
  document.body.style.userSelect = "none";
  if (event.type === "touchstart") {
    event.preventDefault();
  }
}

function resizeColorPicker(event) {
  if (!isResizingColorPicker) return;
  const coords = getEventCoords(event);
  const dx = coords.x - cpResizeStartX;
  const dy = coords.y - cpResizeStartY;

  const minWidth =
    parseInt(getComputedStyle(colorPickerModal).minWidth, 10) || 250;
  const minHeight =
    parseInt(getComputedStyle(colorPickerModal).minHeight, 10) || 300;
  const currentLeft = colorPickerModal.offsetLeft;
  const currentTop = colorPickerModal.offsetTop;
  const viewportWidth = canvasViewport.clientWidth;
  const viewportHeight = canvasViewport.clientHeight;

  let newWidth = cpResizeInitialWidth + dx;
  let newHeight = cpResizeInitialHeight + dy;

  // Enforce minimum dimensions
  newWidth = Math.max(minWidth, newWidth);
  newHeight = Math.max(minHeight, newHeight);

  // Enforce maximum dimensions (prevent resizing beyond viewport edges)
  newWidth = Math.min(newWidth, viewportWidth - currentLeft);
  newHeight = Math.min(newHeight, viewportHeight - currentTop);

  colorPickerModal.style.width = `${newWidth}px`;
  colorPickerModal.style.height = `${newHeight}px`;

  if (event.type === "touchmove") {
    event.preventDefault();
  }
}

function stopColorPickerResize() {
  if (isResizingColorPicker) {
    isResizingColorPicker = false;
    document.removeEventListener("mousemove", resizeColorPicker);
    document.removeEventListener("mouseup", stopColorPickerResize);
    document.removeEventListener("touchmove", resizeColorPicker);
    document.removeEventListener("touchend", stopColorPickerResize);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }
}

// --- NEW: Add Color Picker Drag/Resize Listeners ---
colorPickerHeader.addEventListener("mousedown", startColorPickerDrag);
colorPickerHeader.addEventListener("touchstart", startColorPickerDrag, {
  passive: false,
});
colorPickerResizeHandle.addEventListener("mousedown", startColorPickerResize);
colorPickerResizeHandle.addEventListener("touchstart", startColorPickerResize, {
  passive: false,
});

// --- NEW: Color Pick Toggle Button Listener ---
// ... existing listener ...

// --- Initial Load --- (Restoring definition)
function initializeApp() {
  console.log("Initializing app...");
  loadState(); // Load state first

  // Initial rendering of the palette
  updatePaletteView();

  // --- NEW: Center Palette Conditionally ---
  if (!stateLoadedSuccessfully) {
    console.log("No saved position state found, centering palette.");
    // Ensure the grid has dimensions after updatePaletteView
    // Use setTimeout to ensure DOM has updated
    setTimeout(() => {
      const viewportWidth = canvasViewport.clientWidth;
      const viewportHeight = canvasViewport.clientHeight;
      const containerWidth = paletteContainer.offsetWidth;
      const containerHeight = paletteContainer.offsetHeight;

      if (
        viewportWidth > 0 &&
        viewportHeight > 0 &&
        containerWidth > 0 &&
        containerHeight > 0
      ) {
        // Calculate centered offsets considering scale
        paletteOffsetX = (viewportWidth - containerWidth * scale) / 2;
        paletteOffsetY = (viewportHeight - containerHeight * scale) / 2;
        scale = 1; // Ensure default scale

        // Apply the transform
        updateTransform();

        // Update zoom controls to reflect default scale
        zoomSlider.value = 100;
        zoomNumber.value = 100;

        console.log(
          `Centered palette: offset(${paletteOffsetX}, ${paletteOffsetY}), container(${containerWidth}x${containerHeight}), viewport(${viewportWidth}x${viewportHeight})`,
        );
      } else {
        console.warn(
          "Could not center palette: Viewport or Container dimensions are zero.",
        );
      }
    }, 0);
  } else {
    console.log("Saved position state found, using loaded position.");
    // Ensure transform is applied with loaded state values (in case loadState didn't call it)
    updateTransform();
  }
  // --- END NEW ---

  // Setup event listeners for controls etc.
  setupEventListeners(); // Assuming listeners are grouped here

  console.log("App initialized.");
}

// --- Call Initialization ---
initializeApp();

// --- Helper function for multi-apply logic (to avoid duplication) ---
function applyMultiSelectChanges() {
  let newH = null; // NEW: Hue value
  let newS = null;
  let newL = null;
  let appliedChange = false; // Track if any change is possible

  // --- NEW: Parse H if enabled ---
  if (!pickerHueNumber.disabled) {
    newH = parseInt(pickerHueNumber.value, 10);
    if (isNaN(newH) || newH < 0 || newH > 360) {
      // Validate 0-360
      alert("Invalid Hue value (must be 0-360).");
      return false; // Indicate failure
    }
    appliedChange = true;
  }
  // --- END NEW ---

  // Parse S if enabled
  if (!pickerSatNumber.disabled) {
    newS = parseInt(pickerSatNumber.value, 10);
    if (isNaN(newS) || newS < 0 || newS > 100) {
      alert("Invalid Saturation value (must be 0-100).");
      return false;
    }
    appliedChange = true;
  }

  // Parse L if enabled
  if (!pickerLumNumber.disabled) {
    newL = parseInt(pickerLumNumber.value, 10);
    if (isNaN(newL) || newL < 0 || newL > 100) {
      alert("Invalid Luminance value (must be 0-100).");
      return false;
    }
    appliedChange = true;
  }

  if (!appliedChange) {
    console.log(
      "Apply clicked, but no editable values (H/S/L) were changed or enabled.",
    );
    return true; // Success (nothing to do)
  }

  // Apply the changes, preserving original values where necessary
  selectedCells.forEach((coord) => {
    const [rowIndex, colIndex] = coord;
    if (
      rowIndex < sourceGridData.length &&
      colIndex < sourceGridData[rowIndex].length
    ) {
      const originalHex = sourceGridData[rowIndex][colIndex];
      const originalHsl = hexToHsl(originalHex);
      if (originalHsl) {
        // Use parsed value if available (not null), otherwise use original
        const finalH = newH !== null ? newH : originalHsl.h; // Apply H if changed
        const finalS = newS !== null ? newS : originalHsl.s;
        const finalL = newL !== null ? newL : originalHsl.l;

        const finalHex = hslToHex(finalH, finalS, finalL); // Use finalH
        sourceGridData[rowIndex][colIndex] = finalHex;
      } else {
        console.warn(
          `Could not process original color for cell [${rowIndex}, ${colIndex}] during multi-apply.`,
        );
      }
    }
  });

  // Update Log Message
  let logParts = [];
  if (newH !== null) logParts.push(`H:${newH}`);
  if (newS !== null) logParts.push(`S:${newS}`);
  if (newL !== null) logParts.push(`L:${newL}`);
  console.log(
    `Applied changes to ${selectedCells.length} cells. ${logParts.join(", ")}`,
  );

  return true; // Indicate success
}
// --- END Helper function ---

// --- Helper function to apply visual selection styles ---
function applySelectionStyles(coords) {
  const cellDiv = paletteGrid.querySelector(
    `.cell-content[data-row-index="${coords[0]}"][data-cell-index="${coords[1]}"]`,
  );
  if (cellDiv) {
    cellDiv.classList.add("selected");
  }
}

// --- Helper function to calculate minimum angular difference between two hues ---
function getHueDifference(h1, h2) {
  const diff = Math.abs(h1 - h2);
  return Math.min(diff, 360 - diff);
}

// --- State Management Functions ---
function saveState() {
  try {
    const state = {
      sourceGridData,
      isInterpolationEnabled,
      interpolationSteps,
      saturationOffset,
      paletteOffsetX, // Save current position
      paletteOffsetY, // Save current position
      scale, // Save current zoom
      // Save other relevant states like UI scale, popout position/size etc. if needed
      uiScale: currentUiScale,
      popoutEditorState: {
        left: popoutEditor.style.left,
        top: popoutEditor.style.top,
        width: popoutEditor.style.width,
        height: popoutEditor.style.height,
        display: popoutEditor.style.display,
      },
      colorPickerState: {
        left: colorPickerModal.style.left,
        top: colorPickerModal.style.top,
        width: colorPickerModal.style.width,
        height: colorPickerModal.style.height,
        // Don't save 'display' or 'visible' class for color picker, it shouldn't reopen automatically
      },
    };
    localStorage.setItem(localStorageKey, JSON.stringify(state));
    console.log("Application state saved.");
    // Optionally provide feedback to the user
    saveStateButton.textContent = "Saved!";
    setTimeout(() => {
      saveStateButton.textContent = "Save Current State";
    }, 1500);
  } catch (error) {
    console.error("Error saving state:", error);
    alert(
      "Could not save application state. Local storage might be full or disabled.",
    );
  }
}

function loadState() {
  try {
    const savedStateString = localStorage.getItem(localStorageKey);
    if (savedStateString) {
      const savedState = JSON.parse(savedStateString);
      console.log("Loading saved state:", savedState);

      // Reset the flag at the start of loading
      stateLoadedSuccessfully = false;

      // Display timestamp if available
      if (savedState.timestamp && stateTimestampDiv) {
        stateTimestampDiv.textContent = `Last saved: ${new Date(savedState.timestamp).toLocaleString()}`;
      }

      // --- Load Palette Data and Settings ---
      if (
        savedState.sourceGridData &&
        Array.isArray(savedState.sourceGridData)
      ) {
        // Basic validation: check if it's an array of arrays
        if (savedState.sourceGridData.every((row) => Array.isArray(row))) {
          sourceGridData = savedState.sourceGridData.map((row) => [...row]); // Deep copy
          // Update the popout editor textarea if it's visible
          if (popoutEditor.style.display !== "none") {
            popoutPaletteInput.value = convertToSimpleFormat(sourceGridData);
          }
        } else {
          console.warn(
            "Loaded sourceGridData format is invalid. Using default.",
          );
        }
      }
      isInterpolationEnabled =
        typeof savedState.isInterpolationEnabled === "boolean"
          ? savedState.isInterpolationEnabled
          : false;
      interpolationSteps =
        typeof savedState.interpolationSteps === "number"
          ? savedState.interpolationSteps
          : 1;
      saturationOffset =
        typeof savedState.saturationOffset === "number"
          ? savedState.saturationOffset
          : 0;
      currentUiScale =
        typeof savedState.uiScale === "number" ? savedState.uiScale : 100;

      // --- Load Position and Zoom ---
      let positionLoaded = false;
      if (
        typeof savedState.paletteOffsetX === "number" &&
        typeof savedState.paletteOffsetY === "number"
      ) {
        paletteOffsetX = savedState.paletteOffsetX;
        paletteOffsetY = savedState.paletteOffsetY;
        positionLoaded = true;
      }
      if (
        typeof savedState.scale === "number" &&
        savedState.scale >= minScale &&
        savedState.scale <= maxScale
      ) {
        scale = savedState.scale;
      } else {
        scale = 1; // Reset scale if invalid or not found, even if position was loaded
      }

      // --- NEW: Set flag if position/zoom were loaded ---
      if (positionLoaded) {
        // Check only if position was loaded, zoom defaults to 1 if missing/invalid
        stateLoadedSuccessfully = true;
        console.log("Position/Zoom state loaded successfully.");
      } else {
        console.log("Position/Zoom state not found or invalid in saved data.");
      }
      // --- END NEW ---

      // --- Load Popout Editor State ---
      if (savedState.popoutEditorState) {
        popoutEditor.style.left = savedState.popoutEditorState.left || "";
        popoutEditor.style.top = savedState.popoutEditorState.top || "";
        popoutEditor.style.width = savedState.popoutEditorState.width || "";
        popoutEditor.style.height = savedState.popoutEditorState.height || "";
        popoutEditor.style.display =
          savedState.popoutEditorState.display || "none";
        // If popout is now visible, load its content
        if (popoutEditor.style.display !== "none" && sourceGridData) {
          popoutPaletteInput.value = convertToSimpleFormat(sourceGridData);
        }
      }

      // --- Load Color Picker State (Position/Size Only) ---
      if (savedState.colorPickerState) {
        colorPickerModal.style.left = savedState.colorPickerState.left || "";
        colorPickerModal.style.top = savedState.colorPickerState.top || "";
        colorPickerModal.style.width = savedState.colorPickerState.width || "";
        colorPickerModal.style.height =
          savedState.colorPickerState.height || "";
        // Do NOT restore visibility state
      }

      // --- Update UI Elements to Reflect Loaded State ---
      interpolationToggle.checked = isInterpolationEnabled;
      interpolationStepsSlider.value = interpolationSteps;
      interpolationStepsNumber.value = interpolationSteps;
      saturationOffsetSlider.value = saturationOffset;
      saturationOffsetNumber.value = saturationOffset;
      // Update zoom controls
      zoomSlider.value = Math.round(scale * 100);
      zoomNumber.value = Math.round(scale * 100);
      // Update UI Scale input
      uiScaleNumber.value = currentUiScale;
      applyUiScale(currentUiScale); // Apply the loaded UI scale

      console.log("State loaded and applied.");
    } else {
      console.log("No saved state found.");
      stateLoadedSuccessfully = false; // Explicitly false if no state string
    }
  } catch (error) {
    console.error("Error loading state:", error);
    // Don't alert, just proceed with defaults
    localStorage.removeItem(localStorageKey); // Clear potentially corrupted state
    stateLoadedSuccessfully = false; // Ensure flag is false on error
  }
}

function resetState() {
  if (
    confirm(
      "Are you sure you want to reset all settings and palette data? This will reload the page.",
    )
  ) {
    localStorage.removeItem(localStorageKey);
    // Clear specific session things if needed (like selection) - though reload handles this
    selectedCells = [];
    selectionAnchor = null;
    // Reload the page to apply default state
    window.location.reload();
  }
}

// --- State Management Listeners ---
saveStateButton.addEventListener("click", saveStateToLocalStorage);
resetStateButton.addEventListener("click", () => {
  if (
    confirm(
      "Are you sure you want to reset all saved settings and reload the page?",
    )
  ) {
    try {
      localStorage.removeItem(localStorageKey);
      console.log("Saved state removed from local storage.");
      // alert('State reset. Reloading page...'); // REMOVED alert
      location.reload();
    } catch (error) {
      console.error("Error removing state from local storage:", error);
      // alert('Failed to reset state. Please clear local storage manually if needed.'); // This error is less common and might still warrant an alert, but let's remove for consistency. Could replace with a non-blocking message if a dedicated UI element existed.
      console.warn("Manual local storage clear might be needed.");
    }
  }
});

// --- NEW: Palette Export Listener ---
exportPaletteButton.addEventListener("click", exportPaletteData);

// --- Palette Import Logic --- (Implementation)
function handlePaletteImport(file) {
  const originalButtonText = importPaletteButton.textContent; // Store original text
  let importSuccess = false; // Flag for feedback, will be set inside onload/onerror

  if (!file || !file.type.match("text.*")) {
    console.warn("No text file selected or file type not supported.");
    // alert('Please select a valid .txt file.'); // Replaced alert
    importPaletteButton.textContent = "Invalid File"; // Immediate feedback
    importPaletteButton.classList.add("error");
    setTimeout(() => {
      importPaletteButton.textContent = originalButtonText;
      importPaletteButton.classList.remove("error");
    }, 2000);
    return; // Exit function
  }

  const reader = new FileReader();

  reader.onload = (event) => {
    const textData = event.target.result;
    try {
      const newDataParsed = parseSimpleFormat(textData);
      if (
        !Array.isArray(newDataParsed) ||
        newDataParsed.length === 0 ||
        !Array.isArray(newDataParsed[0])
      ) {
        throw new Error("Imported data is not a valid grid. Check format.");
      }
      // Basic validation (heuristic)
      if (newDataParsed.length > 0 && newDataParsed[0].length > 0) {
        const firstCell = newDataParsed[0][0];
        const lastCell = newDataParsed[0][newDataParsed[0].length - 1];
        if (typeof firstCell !== "string" || typeof lastCell !== "string") {
          console.warn(
            "Imported data format warning: First/last cells of first row may not be labels.",
          );
        }
      }

      sourceGridData = newDataParsed;
      isInterpolationEnabled = false;
      interpolationToggle.checked = false;
      currentGridData = sourceGridData.map((row) => [...row]);
      renderPalette(currentGridData); // Re-render main palette

      // alert('Palette imported successfully!'); // Replaced alert
      console.log("Palette data imported from file:", file.name);
      importSuccess = true; // Mark success

      // If popout is open, update its content too
      if (popoutEditor.style.display === "flex") {
        popoutPaletteInput.value = convertToSimpleFormat(sourceGridData);
        // showPopoutStatus('Palette imported.', false); // REMOVED: Use button feedback
      }
    } catch (error) {
      console.error("Error parsing or processing imported file:", error);
      // alert(`Error importing palette: ${error.message}`); // Replaced alert
      importSuccess = false; // Mark failure
      // Do not re-throw, proceed to feedback
    }

    // Provide visual feedback on the button after load/error
    if (importSuccess) {
      importPaletteButton.textContent = "Imported!";
      importPaletteButton.classList.remove("error");
      importPaletteButton.classList.add("success");
      setTimeout(() => {
        importPaletteButton.textContent = originalButtonText;
        importPaletteButton.classList.remove("success");
      }, 1500);
    } else {
      importPaletteButton.textContent = "Import Failed";
      importPaletteButton.classList.remove("success");
      importPaletteButton.classList.add("error");
      setTimeout(() => {
        importPaletteButton.textContent = originalButtonText;
        importPaletteButton.classList.remove("error");
      }, 2000);
    }
  };

  reader.onerror = (event) => {
    console.error("File reading error:", event.target.error);
    // alert('Error reading the selected file.'); // Replaced alert
    importSuccess = false; // Mark failure

    // Provide visual feedback on the button after error
    importPaletteButton.textContent = "Read Error"; // Specific error
    importPaletteButton.classList.remove("success");
    importPaletteButton.classList.add("error");
    setTimeout(() => {
      importPaletteButton.textContent = originalButtonText;
      importPaletteButton.classList.remove("error");
    }, 2000);
  };

  reader.readAsText(file); // Read the file as text
}

importPaletteButton.addEventListener("click", () => {
  importPaletteFileInput.click(); // Trigger the hidden file input
});

importPaletteFileInput.addEventListener("change", (event) => {
  const file = event.target.files[0];
  if (file) {
    handlePaletteImport(file);
  }
  // Reset the input value so the change event fires even if the same file is selected again
  event.target.value = null;
});

// --- NEW: Color Picker Functions ---
function updatePickerPreview(hex) {
  colorPickerPreview.style.backgroundColor = hex;
  // Optional: Update hue slider background dynamically
  // pickerHueSlider.style.background = \`linear-gradient(to right, hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(360, 100%, 50%))\`;
}

function updatePickerFromHsl() {
  if (isPickerUpdating) return;
  isPickerUpdating = true;

  const h = parseInt(pickerHueNumber.value, 10);
  const s = parseInt(pickerSatNumber.value, 10);
  const l = parseInt(pickerLumNumber.value, 10);

  if (isNaN(h) || isNaN(s) || isNaN(l)) {
    isPickerUpdating = false;
    return; // Avoid errors if inputs are temporarily invalid
  }

  const newHex = hslToHex(h, s, l);
  pickerHexInput.value = newHex.toUpperCase();
  updatePickerPreview(newHex);

  isPickerUpdating = false;
}

function updatePickerFromHex() {
  if (isPickerUpdating) return;
  isPickerUpdating = true;

  let hex = pickerHexInput.value;
  if (!hex.startsWith("#")) {
    hex = "#" + hex;
  }

  if (isValidHex(hex)) {
    const hsl = hexToHsl(hex);
    if (hsl) {
      pickerHueSlider.value = hsl.h;
      pickerHueNumber.value = hsl.h;
      pickerSatSlider.value = hsl.s;
      pickerSatNumber.value = hsl.s;
      pickerLumSlider.value = hsl.l;
      pickerLumNumber.value = hsl.l;
      updatePickerPreview(hex);
      pickerHexInput.value = hex.toUpperCase(); // Ensure # and uppercase
    } else {
      console.warn("Could not convert valid HEX to HSL:", hex);
    }
  } else {
    // Maybe add visual feedback for invalid hex
    console.log("Invalid HEX input:", hex);
  }

  isPickerUpdating = false;
}

function openColorPicker(rowIndex, cellIndex, event = null) {
  // Check if source data exists for the coordinates (use first selected)
  if (
    rowIndex >= sourceGridData.length ||
    cellIndex >= sourceGridData[rowIndex].length
  ) {
    console.error(
      `Invalid coordinates for sourceGridData: [${rowIndex}][${cellIndex}]`,
    );
    clearSelection(); // Clear potentially invalid selection
    return;
  }
  const originalHex = sourceGridData[rowIndex][cellIndex];

  if (!isValidHex(originalHex)) {
    console.error(
      `Cannot open picker: Cell at source[${rowIndex}][${cellIndex}] is not a valid HEX color.`,
      originalHex,
    );
    clearSelection(); // Clear invalid selection
    return;
  }

  // We no longer store targetRow/Col globally, rely on selectedCells
  // pickerTargetRow = rowIndex;
  // pickerTargetCol = cellIndex;

  const hsl = hexToHsl(originalHex);
  if (!hsl) {
    console.error("Error converting initial HEX to HSL:", originalHex);
    clearSelection(); // Clear invalid selection
    return;
  }

  isPickerUpdating = true;

  // Determine if Multi-Select Mode
  const isMultiSelect = selectedCells.length > 1;
  const firstSelectedHsl = hsl; // HSL of the first selected cell

  // --- Flags to determine if controls should be disabled in multi-select ---
  let shouldDisableH = false; // NEW Hue flag
  let shouldDisableS = false;
  let shouldDisableL = false;

  if (isMultiSelect) {
    // Iterate through OTHER selected cells to check for variance
    for (let i = 1; i < selectedCells.length; i++) {
      const [r, c] = selectedCells[i];
      if (r < sourceGridData.length && c < sourceGridData[r].length) {
        const currentHex = sourceGridData[r][c];
        const currentHsl = hexToHsl(currentHex);
        if (currentHsl) {
          // --- NEW: Check Hue Variance ---
          if (
            !shouldDisableH &&
            getHueDifference(currentHsl.h, firstSelectedHsl.h) >
              multiSelectHueTolerance
          ) {
            shouldDisableH = true;
          }
          // --- END NEW ---

          if (
            !shouldDisableS &&
            Math.abs(currentHsl.s - firstSelectedHsl.s) > multiSelectTolerance
          ) {
            shouldDisableS = true;
          }
          if (
            !shouldDisableL &&
            Math.abs(currentHsl.l - firstSelectedHsl.l) > multiSelectTolerance
          ) {
            shouldDisableL = true;
          }
          // Optimization: If all are disabled, no need to check further
          if (shouldDisableH && shouldDisableS && shouldDisableL) break;
        } else {
          console.warn(
            `Could not get HSL for selected cell [${r},${c}] during variance check.`,
          );
        }
      }
    }
  }
  // --- END Check variance ---

  // Set initial values based on the *first* selected cell
  pickerHueSlider.value = firstSelectedHsl.h;
  pickerHueNumber.value = firstSelectedHsl.h; // Keep initial set
  pickerSatSlider.value = firstSelectedHsl.s;
  pickerSatNumber.value = firstSelectedHsl.s; // Keep initial set
  pickerLumSlider.value = firstSelectedHsl.l;
  pickerLumNumber.value = firstSelectedHsl.l; // Keep initial set
  pickerHexInput.value = isMultiSelect ? "Multiple" : originalHex.toUpperCase();
  updatePickerPreview(originalHex);

  // --- Enable/Disable Controls based on mode and variance AND UPDATE DISPLAY ---
  pickerHexInput.disabled = isMultiSelect; // Hex always disabled in multi

  // --- Hue Controls ---
  pickerHueSlider.disabled = isMultiSelect && shouldDisableH;
  pickerHueNumber.disabled = isMultiSelect && shouldDisableH;
  if (pickerHueNumber.disabled) {
    pickerHueNumber.value = ""; // Clear value if disabled
    pickerHueNumber.placeholder = "Varies"; // Show placeholder
  } else {
    pickerHueNumber.value = firstSelectedHsl.h; // Ensure value is set if enabled
    pickerHueNumber.placeholder = ""; // Clear placeholder
  }

  // --- Saturation Controls ---
  pickerSatSlider.disabled = isMultiSelect && shouldDisableS;
  pickerSatNumber.disabled = isMultiSelect && shouldDisableS;
  if (pickerSatNumber.disabled) {
    pickerSatNumber.value = "";
    pickerSatNumber.placeholder = "Varies";
  } else {
    pickerSatNumber.value = firstSelectedHsl.s;
    pickerSatNumber.placeholder = "";
  }

  // --- Luminance Controls ---
  pickerLumSlider.disabled = isMultiSelect && shouldDisableL;
  pickerLumNumber.disabled = isMultiSelect && shouldDisableL;
  if (pickerLumNumber.disabled) {
    pickerLumNumber.value = "";
    pickerLumNumber.placeholder = "Varies";
  } else {
    pickerLumNumber.value = firstSelectedHsl.l;
    pickerLumNumber.placeholder = "";
  }

  // Add/Remove visual class for disabled state
  pickerHueSlider
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerHueSlider.disabled); // Use slider's disabled state
  pickerHexInput
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerHexInput.disabled);
  pickerSatSlider
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerSatSlider.disabled);
  pickerLumSlider
    .closest(".picker-control-group")
    .classList.toggle("disabled", pickerLumSlider.disabled);

  // --- Update Title ---
  colorPickerModal.querySelector(".color-picker-title").textContent =
    isMultiSelect ? `Edit ${selectedCells.length} Colors` : "Edit Color";

  // --- Position the modal near the event location (mouse or touch) ---
  if (event) {
    const coords = getEventCoords(event);
    const viewportWidth = canvasViewport.clientWidth;
    const viewportHeight = canvasViewport.clientHeight;
    const modalWidth = colorPickerModal.offsetWidth;
    const modalHeight = colorPickerModal.offsetHeight;
    const cursorOffset = 20; // Pixels offset from cursor

    let targetX = coords.x + cursorOffset;
    let targetY = coords.y + cursorOffset;

    // Prevent spawning off the right edge
    if (targetX + modalWidth > viewportWidth) {
      targetX = coords.x - modalWidth - cursorOffset; // Try left of cursor
      // If still off-screen (e.g., modal wider than viewport), align to right edge
      if (targetX < 0)
        targetX = Math.max(0, viewportWidth - modalWidth - SNAP_GAP); // Use SNAP_GAP as a small margin
    }
    // If it's still off-screen after trying left (e.g., near right edge and modal wide), align to right
    if (targetX + modalWidth > viewportWidth) {
      targetX = Math.max(0, viewportWidth - modalWidth - SNAP_GAP);
    }

    // Prevent spawning off the bottom edge
    if (targetY + modalHeight > viewportHeight) {
      targetY = coords.y - modalHeight - cursorOffset; // Try above cursor
      // If still off-screen (e.g., modal taller than viewport), align to bottom edge
      if (targetY < 0)
        targetY = Math.max(0, viewportHeight - modalHeight - SNAP_GAP); // Use SNAP_GAP
    }
    // If it's still off-screen after trying above (e.g., near bottom edge and modal tall), align to bottom
    if (targetY + modalHeight > viewportHeight) {
      targetY = Math.max(0, viewportHeight - modalHeight - SNAP_GAP);
    }

    // Ensure it's not off the left or top edge
    targetX = Math.max(SNAP_GAP, targetX); // Use SNAP_GAP as a small margin
    targetY = Math.max(SNAP_GAP, targetY); // Use SNAP_GAP

    colorPickerModal.style.left = `${targetX}px`;
    colorPickerModal.style.top = `${targetY}px`;

    console.log(`Positioning picker at: (${targetX}, ${targetY})`);
  } else {
    // Fallback to default position if no event provided
    console.log("No event provided, using default picker position.");
    colorPickerModal.style.left = "150px";
    colorPickerModal.style.top = "150px";
  }
  // --- END Position the modal ---

  colorPickerModal.classList.add("visible");
  isPickerUpdating = false;

  // --- Focus appropriate element ---
  if (isMultiSelect) {
    // Try focusing the first *enabled* slider (H, L, or S)
    if (!pickerHueSlider.disabled) {
      pickerHueSlider.focus();
    } else if (!pickerLumSlider.disabled) {
      pickerLumSlider.focus();
    } else if (!pickerSatSlider.disabled) {
      pickerSatSlider.focus();
    } // else maybe focus Apply button?
  } else {
    pickerHueSlider.focus(); // Focus Hue for single edit
  }
}

function closeColorPicker() {
  colorPickerModal.classList.remove("visible");
  // Clear selection when picker is closed manually
  clearSelection();
  // Re-enable potentially disabled controls for next time
  pickerHueSlider.disabled = false;
  pickerHueNumber.disabled = false;
  pickerHexInput.disabled = false;
  // --- Re-enable S/L controls ---
  pickerSatSlider.disabled = false;
  pickerSatNumber.disabled = false;
  pickerLumSlider.disabled = false;
  pickerLumNumber.disabled = false;

  // Remove disabled classes
  pickerHueSlider.closest(".picker-control-group").classList.remove("disabled");
  pickerHexInput.closest(".picker-control-group").classList.remove("disabled");
  // --- Remove disabled class for S/L ---
  pickerSatSlider.closest(".picker-control-group").classList.remove("disabled");
  pickerLumSlider.closest(".picker-control-group").classList.remove("disabled");
}

// --- Event Listeners ---

// Buttons
pickerApplyButton.addEventListener("click", (event) => {
  if (touchEventHandled) {
    touchEventHandled = false;
    return;
  }

  if (selectedCells.length === 0) {
    console.warn("Apply clicked with no cells selected.");
    closeColorPicker();
    return;
  }

  const originalButtonText = pickerApplyButton.textContent; // Store original text

  const isMultiSelect = selectedCells.length > 1;
  let applySuccess = false;

  if (isMultiSelect) {
    // --- Use helper function for multi-select logic ---
    applySuccess = applyMultiSelectChanges();
    // --- End Use helper function ---
  } else {
    // Apply changes to a single cell (H, S, L)
    const [rowIndex, colIndex] = selectedCells[0];
    const finalHex = pickerHexInput.value;

    if (isValidHex(finalHex)) {
      if (
        rowIndex < sourceGridData.length &&
        colIndex < sourceGridData[rowIndex].length
      ) {
        sourceGridData[rowIndex][colIndex] = finalHex;
        console.log(`Applied ${finalHex} to cell [${rowIndex}, ${colIndex}].`);
        applySuccess = true;
      } else {
        console.warn(
          `Invalid coordinates for single apply: [${rowIndex}, ${colIndex}]`,
        );
        applySuccess = false; // Consider this a failure? Or just log?
      }
    } else {
      // alert("Invalid HEX code. Cannot apply."); // Keep alert for prominent feedback
      console.error("Single apply failed: Invalid HEX.", finalHex);
      applySuccess = false;
      // return; // Keep picker open on error
    }
  }

  // Provide visual feedback
  if (applySuccess) {
    updatePaletteView();
    pickerApplyButton.textContent = "Applied!"; // Success feedback
    // You could also add a class like pickerApplyButton.classList.add('success');
    setTimeout(() => {
      pickerApplyButton.textContent = originalButtonText; // Reset text
      // pickerApplyButton.classList.remove('success');
    }, 1500); // Show feedback for 1.5 seconds
  } else {
    // Failure feedback (specifically for invalid HEX for now)
    pickerApplyButton.textContent = "Invalid HEX"; // Error feedback
    // You could also add a class like pickerApplyButton.classList.add('error');
    setTimeout(() => {
      pickerApplyButton.textContent = originalButtonText; // Reset text
      // pickerApplyButton.classList.remove('error');
    }, 2000); // Show feedback slightly longer for errors
  }
});

// --- Touch End handler for Apply Button ---
if (isTouchDevice) {
  pickerApplyButton.addEventListener(
    "touchend",
    (event) => {
      if (pointerHasMoved) return;
      event.preventDefault();
      event.stopPropagation();

      if (selectedCells.length === 0) {
        console.warn("Apply touchend with no cells selected.");
        closeColorPicker();
        return;
      }

      const originalButtonText = pickerApplyButton.textContent; // Store original text

      const isMultiSelect = selectedCells.length > 1;
      let applySuccess = false;

      if (isMultiSelect) {
        // --- Use helper function for multi-select logic ---
        applySuccess = applyMultiSelectChanges();
        // --- End Use helper function ---
      } else {
        // Single select logic (same as click handler)
        const [rowIndex, colIndex] = selectedCells[0];
        const finalHex = pickerHexInput.value;
        if (isValidHex(finalHex)) {
          if (
            rowIndex < sourceGridData.length &&
            colIndex < sourceGridData[rowIndex].length
          ) {
            sourceGridData[rowIndex][colIndex] = finalHex;
            console.log(
              `Applied ${finalHex} by touch to cell [${rowIndex}, ${colIndex}].`,
            );
            applySuccess = true;
          } else {
            console.warn(
              `Invalid coords for single apply touch: [${rowIndex}, ${colIndex}]`,
            );
            applySuccess = false;
          }
        } else {
          // alert("Invalid HEX code. Cannot apply.");
          console.error("Single apply touch failed: Invalid HEX.", finalHex);
          applySuccess = false;
        }
      }

      // Provide visual feedback
      if (applySuccess) {
        updatePaletteView();
        pickerApplyButton.textContent = "Applied!"; // Success feedback
        setTimeout(() => {
          pickerApplyButton.textContent = originalButtonText; // Reset text
        }, 1500); // Show feedback for 1.5 seconds
      } else {
        // Failure feedback
        pickerApplyButton.textContent = "Invalid HEX"; // Error feedback
        setTimeout(() => {
          pickerApplyButton.textContent = originalButtonText; // Reset text
        }, 2000); // Show feedback slightly longer for errors
      }
      touchEventHandled = true;
    },
    { passive: false },
  );
}

// --- NEW: Color Picker Control Event Listeners ---

// Close Button
colorPickerCloseButton.addEventListener("click", closeColorPicker);

// HSL Sliders and Number Inputs Synchronization
[pickerHueSlider, pickerHueNumber].forEach((el) => {
  el.addEventListener("input", () => {
    if (isPickerUpdating || pickerHueSlider.disabled) return; // Check disabled state
    const h = parseInt(el.value, 10);
    if (!isNaN(h)) {
      pickerHueSlider.value = h;
      pickerHueNumber.value = h;
      updatePickerFromHsl();
    }
  });
});

[pickerSatSlider, pickerSatNumber].forEach((el) => {
  el.addEventListener("input", () => {
    // --- Check disabled state ---
    if (isPickerUpdating || pickerSatSlider.disabled) return;
    const s = parseInt(el.value, 10);
    if (!isNaN(s)) {
      pickerSatSlider.value = s;
      pickerSatNumber.value = s;
      updatePickerFromHsl();
    }
  });
});

[pickerLumSlider, pickerLumNumber].forEach((el) => {
  el.addEventListener("input", () => {
    // --- Check disabled state ---
    if (isPickerUpdating || pickerLumSlider.disabled) return;
    const l = parseInt(el.value, 10);
    if (!isNaN(l)) {
      pickerLumSlider.value = l;
      pickerLumNumber.value = l;
      updatePickerFromHsl();
    }
  });
});

// HEX Input Listener
pickerHexInput.addEventListener("change", () => {
  // Use 'change' to trigger after blur or Enter
  if (isPickerUpdating || pickerHexInput.disabled) return; // Check disabled state
  updatePickerFromHex();
});

// Copy HEX Button
pickerCopyHexButton.addEventListener("click", () => {
  const hexValue = pickerHexInput.value;
  // Only copy if it's a valid hex (or "Multiple" if we want to prevent copying that)
  if (isValidHex(hexValue)) {
    // Use the existing copy function but target the button itself for feedback
    copyToClipboard(hexValue, pickerCopyHexButton);
  } else if (hexValue !== "Multiple") {
    console.warn("Attempted to copy invalid HEX:", hexValue);
    // Optional: Add visual feedback for failed copy
    pickerCopyHexButton.textContent = "Invalid";
    setTimeout(() => {
      pickerCopyHexButton.textContent = "Copy";
    }, 1500);
  }
});

// Color Pick Toggle Button Listener
colorPickToggleButton.addEventListener("click", () => {
  isColorPickingMode = !isColorPickingMode;
  colorPickToggleButton.classList.toggle("active", isColorPickingMode);
  document.body.classList.toggle("color-picking-active", isColorPickingMode);
  console.log("Color Picking Mode:", isColorPickingMode ? "ON" : "OFF");

  // Clear selection when toggling mode off
  if (!isColorPickingMode) {
    clearSelection();
    if (colorPickerModal.classList.contains("visible")) {
      closeColorPicker(); // Also close picker if open
    }
  }
});

// --- NEW: Color Picker Drag Functions ---
function startColorPickerDrag(event) {
  // --- NEW: Prevent drag if target is a button inside the header ---
  if (event.target.closest("button")) {
    // console.log("Color Picker drag prevented: Target is a button.");
    return;
  }
  // --- END NEW ---

  if (isResizingColorPicker) return; // Don't drag if resizing

  isDraggingColorPicker = true;
  pickerInitialX = colorPickerModal.offsetLeft;
  pickerInitialY = colorPickerModal.offsetTop;
  const coords = getEventCoords(event);
  pickerStartX = coords.x;
  pickerStartY = coords.y;

  document.addEventListener("mousemove", dragColorPicker);
  document.addEventListener("mouseup", stopColorPickerDrag);
  document.addEventListener("touchmove", dragColorPicker, { passive: false });
  document.addEventListener("touchend", stopColorPickerDrag);

  colorPickerHeader.style.cursor = "grabbing";
  document.body.style.userSelect = "none";
  if (event.type === "touchstart") {
    event.preventDefault();
  }
}

function dragColorPicker(event) {
  if (!isDraggingColorPicker) return;
  const coords = getEventCoords(event);
  const dx = coords.x - pickerStartX;
  const dy = coords.y - pickerStartY;

  let newLeft = pickerInitialX + dx;
  let newTop = pickerInitialY + dy;

  // Basic boundary checks (optional, could add snapping later)
  const viewportWidth = canvasViewport.clientWidth;
  const viewportHeight = canvasViewport.clientHeight;
  const modalWidth = colorPickerModal.offsetWidth;
  const modalHeight = colorPickerModal.offsetHeight;

  newLeft = Math.max(0, Math.min(newLeft, viewportWidth - modalWidth));
  newTop = Math.max(0, Math.min(newTop, viewportHeight - modalHeight));

  colorPickerModal.style.left = `${newLeft}px`;
  colorPickerModal.style.top = `${newTop}px`;

  if (event.type === "touchmove") {
    event.preventDefault();
  }
}

function stopColorPickerDrag() {
  if (isDraggingColorPicker) {
    isDraggingColorPicker = false;
    document.removeEventListener("mousemove", dragColorPicker);
    document.removeEventListener("mouseup", stopColorPickerDrag);
    document.removeEventListener("touchmove", dragColorPicker);
    document.removeEventListener("touchend", stopColorPickerDrag);
    colorPickerHeader.style.cursor = "move";
    document.body.style.userSelect = "";
  }
}

// --- NEW: Color Picker Resize Functions ---
function startColorPickerResize(event) {
  // --- NEW: Prevent resize if target is not the handle itself (optional but safer) ---
  if (event.target !== colorPickerResizeHandle) {
    // console.log("Color Picker resize prevented: Target not resize handle.");
    return;
  }
  // --- END NEW ---

  if (isDraggingColorPicker) return; // Don't resize if dragging

  isResizingColorPicker = true;
  const coords = getEventCoords(event);
  cpResizeStartX = coords.x;
  cpResizeStartY = coords.y;
  cpResizeInitialWidth = colorPickerModal.offsetWidth;
  cpResizeInitialHeight = colorPickerModal.offsetHeight;

  document.addEventListener("mousemove", resizeColorPicker);
  document.addEventListener("mouseup", stopColorPickerResize);
  document.addEventListener("touchmove", resizeColorPicker, { passive: false });
  document.addEventListener("touchend", stopColorPickerResize);

  document.body.style.cursor = "nwse-resize";
  document.body.style.userSelect = "none";
  if (event.type === "touchstart") {
    event.preventDefault();
  }
}

function resizeColorPicker(event) {
  if (!isResizingColorPicker) return;
  const coords = getEventCoords(event);
  const dx = coords.x - cpResizeStartX;
  const dy = coords.y - cpResizeStartY;

  const minWidth =
    parseInt(getComputedStyle(colorPickerModal).minWidth, 10) || 250;
  const minHeight =
    parseInt(getComputedStyle(colorPickerModal).minHeight, 10) || 300;
  const currentLeft = colorPickerModal.offsetLeft;
  const currentTop = colorPickerModal.offsetTop;
  const viewportWidth = canvasViewport.clientWidth;
  const viewportHeight = canvasViewport.clientHeight;

  let newWidth = cpResizeInitialWidth + dx;
  let newHeight = cpResizeInitialHeight + dy;

  // Enforce minimum dimensions
  newWidth = Math.max(minWidth, newWidth);
  newHeight = Math.max(minHeight, newHeight);

  // Enforce maximum dimensions (prevent resizing beyond viewport edges)
  newWidth = Math.min(newWidth, viewportWidth - currentLeft);
  newHeight = Math.min(newHeight, viewportHeight - currentTop);

  colorPickerModal.style.width = `${newWidth}px`;
  colorPickerModal.style.height = `${newHeight}px`;

  if (event.type === "touchmove") {
    event.preventDefault();
  }
}

function stopColorPickerResize() {
  if (isResizingColorPicker) {
    isResizingColorPicker = false;
    document.removeEventListener("mousemove", resizeColorPicker);
    document.removeEventListener("mouseup", stopColorPickerResize);
    document.removeEventListener("touchmove", resizeColorPicker);
    document.removeEventListener("touchend", stopColorPickerResize);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }
}

// --- NEW: Add Color Picker Drag/Resize Listeners ---
colorPickerHeader.addEventListener("mousedown", startColorPickerDrag);
colorPickerHeader.addEventListener("touchstart", startColorPickerDrag, {
  passive: false,
});
colorPickerResizeHandle.addEventListener("mousedown", startColorPickerResize);
colorPickerResizeHandle.addEventListener("touchstart", startColorPickerResize, {
  passive: false,
});

// --- NEW: Color Pick Toggle Button Listener ---
// ... existing listener ...

// --- Initial Load --- (Restoring definition)
function initializeApp() {
  console.log("Initializing app...");
  loadState(); // Load state first

  // Initial rendering of the palette
  updatePaletteView();

  // --- NEW: Center Palette Conditionally ---
  if (!stateLoadedSuccessfully) {
    console.log("No saved position state found, centering palette.");
    // Ensure the grid has dimensions after updatePaletteView
    const viewportWidth = canvasViewport.clientWidth;
    const viewportHeight = canvasViewport.clientHeight;
    const gridWidth = paletteGrid.offsetWidth;
    const gridHeight = paletteGrid.offsetHeight;

    if (
      viewportWidth > 0 &&
      viewportHeight > 0 &&
      gridWidth > 0 &&
      gridHeight > 0
    ) {
      // Calculate centered offsets
      paletteOffsetX = (viewportWidth - gridWidth) / 2;
      paletteOffsetY = (viewportHeight - gridHeight) / 2;
      scale = 1; // Ensure default scale

      // Apply the transform
      updateTransform();

      // Update zoom controls to reflect default scale
      zoomSlider.value = 100;
      zoomNumber.value = 100;
    } else {
      console.warn(
        "Could not center palette: Viewport or Grid dimensions are zero.",
      );
    }
  } else {
    console.log("Saved position state found, using loaded position.");
    // Ensure transform is applied with loaded state values (in case loadState didn't call it)
    updateTransform();
  }
  // --- END NEW ---

  // Setup event listeners for controls etc.
  setupEventListeners(); // Assuming listeners are grouped here

  console.log("App initialized.");
}

// --- Call Initialization ---
initializeApp();

// --- Helper function for multi-apply logic (to avoid duplication) ---
function applyMultiSelectChanges() {
  let newH = null; // NEW: Hue value
  let newS = null;
  let newL = null;
  let appliedChange = false; // Track if any change is possible

  // --- NEW: Parse H if enabled ---
  if (!pickerHueNumber.disabled) {
    newH = parseInt(pickerHueNumber.value, 10);
    if (isNaN(newH) || newH < 0 || newH > 360) {
      // Validate 0-360
      alert("Invalid Hue value (must be 0-360).");
      return false; // Indicate failure
    }
    appliedChange = true;
  }
  // --- END NEW ---

  // Parse S if enabled
  if (!pickerSatNumber.disabled) {
    newS = parseInt(pickerSatNumber.value, 10);
    if (isNaN(newS) || newS < 0 || newS > 100) {
      alert("Invalid Saturation value (must be 0-100).");
      return false;
    }
    appliedChange = true;
  }

  // Parse L if enabled
  if (!pickerLumNumber.disabled) {
    newL = parseInt(pickerLumNumber.value, 10);
    if (isNaN(newL) || newL < 0 || newL > 100) {
      alert("Invalid Luminance value (must be 0-100).");
      return false;
    }
    appliedChange = true;
  }

  if (!appliedChange) {
    console.log(
      "Apply clicked, but no editable values (H/S/L) were changed or enabled.",
    );
    return true; // Success (nothing to do)
  }

  // Apply the changes, preserving original values where necessary
  selectedCells.forEach((coord) => {
    const [rowIndex, colIndex] = coord;
    if (
      rowIndex < sourceGridData.length &&
      colIndex < sourceGridData[rowIndex].length
    ) {
      const originalHex = sourceGridData[rowIndex][colIndex];
      const originalHsl = hexToHsl(originalHex);
      if (originalHsl) {
        // Use parsed value if available (not null), otherwise use original
        const finalH = newH !== null ? newH : originalHsl.h; // Apply H if changed
        const finalS = newS !== null ? newS : originalHsl.s;
        const finalL = newL !== null ? newL : originalHsl.l;

        const finalHex = hslToHex(finalH, finalS, finalL); // Use finalH
        sourceGridData[rowIndex][colIndex] = finalHex;
      } else {
        console.warn(
          `Could not process original color for cell [${rowIndex}, ${colIndex}] during multi-apply.`,
        );
      }
    }
  });

  // Update Log Message
  let logParts = [];
  if (newH !== null) logParts.push(`H:${newH}`);
  if (newS !== null) logParts.push(`S:${newS}`);
  if (newL !== null) logParts.push(`L:${newL}`);
  console.log(
    `Applied changes to ${selectedCells.length} cells. ${logParts.join(", ")}`,
  );

  return true; // Indicate success
}
// --- END Helper function ---

// --- Helper function to apply visual selection styles ---
function applySelectionStyles(coords) {
  const cellDiv = paletteGrid.querySelector(
    `.cell-content[data-row-index="${coords[0]}"][data-cell-index="${coords[1]}"]`,
  );
  if (cellDiv) {
    cellDiv.classList.add("selected");
  }
}

// --- Helper function to calculate minimum angular difference between two hues ---
function getHueDifference(h1, h2) {
  const diff = Math.abs(h1 - h2);
  return Math.min(diff, 360 - diff);
}

// --- NEW: Canvas Interaction Manager ---
const CanvasInteractionManager = {
  // --- State ---
  isPanning: false,
  offsetX: 50, // Initial offset X matches CSS or default
  offsetY: 50, // Initial offset Y matches CSS or default
  scale: 1.0, // Initial scale

  // Panning internal state
  panStartX: 0,
  panStartY: 0,
  // Click vs Drag internal state
  pointerDownX: 0,
  pointerDownY: 0,
  hasPointerMoved: false,
  dragThreshold: 5, // Pixels to differentiate click from drag

  // Constants
  minScale: 0.1, // Moved from global
  maxScale: 5.0, // Moved from global

  // DOM References (set during init)
  viewportElement: null,
  containerElement: null, // The element being transformed (palette-container)

  // Initialization
  init(viewportId, containerId) {
    this.viewportElement = document.getElementById(viewportId);
    this.containerElement = document.getElementById(containerId);
    if (!this.viewportElement || !this.containerElement) {
      console.error(
        "CanvasInteractionManager init failed: Canvas or Container Element not found.",
      );
      return false;
    }
    this.addEventListeners();
    this.updateTransform(); // Apply initial transform based on initial state
    console.log("CanvasInteractionManager initialized.");
    return true;
  },

  // Method to load state (called externally after manager init)
  loadState(state) {
    let positionLoaded = false;
    if (
      state &&
      typeof state.paletteOffsetX === "number" &&
      typeof state.paletteOffsetY === "number"
    ) {
      this.offsetX = state.paletteOffsetX;
      this.offsetY = state.paletteOffsetY;
      positionLoaded = true;
    } else {
      // Reset to default if state is missing position
      this.offsetX = 50;
      this.offsetY = 50;
    }

    if (
      state &&
      typeof state.scale === "number" &&
      state.scale >= this.minScale &&
      state.scale <= this.maxScale
    ) {
      this.scale = state.scale;
    } else {
      this.scale = 1.0; // Reset scale if invalid/missing
    }
    this.updateTransform(); // Apply loaded/default transform
    console.log(
      `Canvas state loaded: offset=(${this.offsetX}, ${this.offsetY}), scale=${this.scale}`,
    );
    return positionLoaded; // Return true only if position data was explicitly loaded
  },

  // --- Event Handling ---
  addEventListeners() {
    if (!this.viewportElement) return;
    // Use .bind(this) to maintain correct 'this' context inside handlers
    this.viewportElement.addEventListener(
      "mousedown",
      this.handlePointerDown.bind(this),
    );
    this.viewportElement.addEventListener(
      "mousemove",
      this.handlePointerMove.bind(this),
    );
    this.viewportElement.addEventListener(
      "mouseup",
      this.handlePointerUp.bind(this),
    );
    this.viewportElement.addEventListener(
      "mouseleave",
      this.handlePointerLeave.bind(this),
    );

    this.viewportElement.addEventListener(
      "touchstart",
      this.handlePointerDown.bind(this),
      { passive: false },
    );
    this.viewportElement.addEventListener(
      "touchmove",
      this.handlePointerMove.bind(this),
      { passive: false },
    );
    this.viewportElement.addEventListener(
      "touchend",
      this.handlePointerUp.bind(this),
    );
    this.viewportElement.addEventListener(
      "touchcancel",
      this.handlePointerUp.bind(this),
    );
  },

  handlePointerDown(event) {
    // Ignore if event originates from interactive elements (modals, swatches in pick mode)
    const targetIsSwatch =
      event.target.classList.contains("cell-content") &&
      event.target.classList.contains("swatch");
    if (
      event.target.closest("#popout-editor") ||
      event.target.closest("#color-picker-modal") ||
      (isTouchDevice && isColorPickingMode && targetIsSwatch)
    ) {
      return;
    }

    event.preventDefault(); // Prevent text selection, default touch actions
    this.isPanning = true;
    const coords = this.getEventCoords(event);
    this.panStartX = coords.x;
    this.panStartY = coords.y;
    this.pointerDownX = coords.x; // Record initial down position for move check
    this.pointerDownY = coords.y;
    this.hasPointerMoved = false; // Reset move flag for this interaction

    this.viewportElement.classList.add("grabbing");
  },

  handlePointerMove(event) {
    if (!this.isPanning) return;
    event.preventDefault();

    const coords = this.getEventCoords(event);
    const currentX = coords.x;
    const currentY = coords.y;

    // Check movement threshold if not already marked as moved
    if (!this.hasPointerMoved) {
      const dxAbs = Math.abs(currentX - this.pointerDownX);
      const dyAbs = Math.abs(currentY - this.pointerDownY);
      if (dxAbs > this.dragThreshold || dyAbs > this.dragThreshold) {
        this.hasPointerMoved = true;
      }
    }

    // Calculate delta from the *last* move event position
    const dx = currentX - this.panStartX;
    const dy = currentY - this.panStartY;

    this.offsetX += dx;
    this.offsetY += dy;

    this.updateTransform();

    // Update start position for the *next* move calculation
    this.panStartX = currentX;
    this.panStartY = currentY;
  },

  handlePointerUp(event) {
    if (!this.isPanning) return;
    this.isPanning = false;
    this.viewportElement.classList.remove("grabbing");

    // Reset the moved flag slightly later so click/touchend handlers on cells
    // can check the value reflecting the just-ended interaction.
    setTimeout(() => {
      // No need to reset hasPointerMoved here, reset on next pointerDown
      // This ensures click handlers read the correct state for the completed action
    }, 0); // Minimal delay might suffice, or remove delay
  },

  handlePointerLeave(event) {
    // If mouse leaves viewport while panning, end the pan
    if (this.isPanning) {
      this.handlePointerUp(event);
    }
  },

  // --- Zooming ---
  setZoomLevel(newScalePercent, focalPoint = null) {
    // focalPoint relative to viewport
    const newScale = Math.max(
      this.minScale,
      Math.min(this.maxScale, newScalePercent / 100),
    );
    if (newScale === this.scale) return; // No change

    let focalX, focalY;
    const rect = this.viewportElement.getBoundingClientRect();

    // If focalPoint is NOT provided (like from the slider/number input calls),
    // it defaults to the viewport center.
    if (
      focalPoint &&
      typeof focalPoint.x === "number" &&
      typeof focalPoint.y === "number"
    ) {
      // This part would be used if we implemented mouse wheel zoom relative to cursor
      focalX = focalPoint.x - rect.left;
      focalY = focalPoint.y - rect.top;
    } else {
      // *** THIS IS THE DEFAULT CASE for slider/number input ***
      focalX = rect.width / 2;
      focalY = rect.height / 2;
      // console.log(`Zooming with default focal point: Center (${focalX}, ${focalY})`); // Optional debug log
    }

    // This math calculates the new offsetX and offsetY required to keep
    // the point (focalX, focalY) in the same screen position after applying the new scale.
    const pointX = (focalX - this.offsetX) / this.scale; // Point on the palette under the focal point (before zoom)
    const pointY = (focalY - this.offsetY) / this.scale;
    this.scale = newScale; // Apply new scale
    // Calculate new offsets to keep the point stationary
    this.offsetX = focalX - pointX * this.scale;
    this.offsetY = focalY - pointY * this.scale;

    this.updateTransform(); // Apply the new transform
  },

  // --- Transform ---
  updateTransform() {
    if (!this.containerElement) return;
    const transformValue = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.scale})`;
    this.containerElement.style.transform = transformValue;
  },

  // --- Centering ---
  centerContent(useScale = 1.0) {
    if (!this.viewportElement || !this.containerElement || !paletteGrid)
      return false; // Need paletteGrid too

    const viewportWidth = this.viewportElement.clientWidth;
    const viewportHeight = this.viewportElement.clientHeight;
    const contentWidth = paletteGrid.offsetWidth; // Assumes paletteGrid is the content
    const contentHeight = paletteGrid.offsetHeight;

    if (
      viewportWidth > 0 &&
      viewportHeight > 0 &&
      contentWidth > 0 &&
      contentHeight > 0
    ) {
      this.scale = Math.max(this.minScale, Math.min(this.maxScale, useScale));

      // Calculate offsets for the *scaled* content dimensions
      this.offsetX = (viewportWidth - contentWidth * this.scale) / 2;
      this.offsetY = (viewportHeight - contentHeight * this.scale) / 2;

      console.log(
        `Centering content: vp(${viewportWidth},${viewportHeight}), content(${contentWidth},${contentHeight}), scale(${this.scale}), offset(${this.offsetX},${this.offsetY})`,
      );
      this.updateTransform();
      return true;
    } else {
      console.warn(
        "Could not center content: Viewport or Content dimensions are zero.",
      );
      return false;
    }
  },

  // --- Getters ---
  didPointerMove() {
    // Returns true if the pointer moved significantly during the *last completed* pan/drag
    return this.hasPointerMoved;
  },

  // --- Utility ---
  getEventCoords(event) {
    // Handles both mouse and touch events to get clientX/clientY
    if (event.touches && event.touches.length > 0) {
      return { x: event.touches[0].clientX, y: event.touches[0].clientY };
    } else if (event.changedTouches && event.changedTouches.length > 0) {
      // Use changedTouches for touchend/touchcancel
      return {
        x: event.changedTouches[0].clientX,
        y: event.changedTouches[0].clientY,
      };
    } else {
      // Mouse event
      return { x: event.clientX, y: event.clientY };
    }
  },
};
// --- END Canvas Interaction Manager ---

// --- Global instance ---
let canvasManager = null;

// --- State Loading and Initialization Update ---
function loadState() {
  let loadedStateData = null;
  try {
    const savedStateString = localStorage.getItem(localStorageKey);
    if (savedStateString) {
      loadedStateData = JSON.parse(savedStateString);
      console.log("Loading saved state.");

      // --- Load NON-CANVAS State ---
      if (loadedStateData.sourceGridData && /* validation */ true) {
        sourceGridData = loadedStateData.sourceGridData.map((row) => [...row]);
        // Update popout if needed
      }
      isInterpolationEnabled =
        typeof loadedStateData.isInterpolationEnabled === "boolean"
          ? loadedStateData.isInterpolationEnabled
          : false;
      interpolationSteps =
        typeof loadedStateData.interpolationSteps === "number"
          ? loadedStateData.interpolationSteps
          : 1;
      saturationOffset =
        typeof loadedStateData.saturationOffset === "number"
          ? loadedStateData.saturationOffset
          : 0;
      currentUiScale =
        typeof loadedStateData.uiScale === "number"
          ? loadedStateData.uiScale
          : 100;
      // Load popout/picker state...

      // Update UI elements for non-canvas state
      interpolationToggle.checked = isInterpolationEnabled;
      interpolationStepsSlider.value = interpolationSteps;
      // ... etc ...
      uiScaleNumber.value = currentUiScale;
      applyUiScale(currentUiScale); // Apply loaded UI scale immediately
    } else {
      console.log("No saved state found.");
    }
  } catch (error) {
    console.error("Error loading state:", error);
    localStorage.removeItem(localStorageKey);
    loadedStateData = null; // Ensure no corrupted data is used
  }
  return loadedStateData; // Return the loaded data (or null)
}

function initializeApp() {
  console.log("Initializing app...");

  const loadedStateData = loadState(); // Load non-canvas state first

  // Initial rendering of the palette (uses loaded/default sourceGridData)
  updatePaletteView();

  // --- Initialize Canvas Manager ---
  // Use Object.create for a simple object approach, or `new ClassName()` if converted to class
  // Check if CanvasInteractionManager is defined before using it
  if (typeof CanvasInteractionManager !== "undefined") {
    canvasManager = Object.create(CanvasInteractionManager);
    const managerInitialized = canvasManager.init(
      "canvas-viewport",
      "palette-container",
    );

    if (!managerInitialized) {
      console.error(
        "App initialization failed: Canvas Manager could not initialize.",
      );
      // Potentially show an error message to the user
      return;
    }
  } else {
    console.warn(
      "CanvasInteractionManager not yet defined, initializing without canvas manager",
    );
    canvasManager = null;
  }

  // Load canvas-specific state into the manager
  const positionStateLoaded = canvasManager.loadState(loadedStateData);

  // Update zoom controls based on the state loaded into the manager
  zoomSlider.value = Math.round(canvasManager.scale * 100);
  zoomNumber.value = Math.round(canvasManager.scale * 100);

  // Center Palette Conditionally (if manager exists and position wasn't loaded)
  if (!positionStateLoaded) {
    console.log("No saved position state found or loaded, centering palette.");
    const centered = canvasManager.centerContent(1.0); // Center at 100% scale
    if (centered) {
      // Update zoom controls if centered successfully
      zoomSlider.value = 100;
      zoomNumber.value = 100;
    }
  } else {
    console.log("Saved position state found and loaded.");
  }

  // Setup other event listeners (buttons, controls etc.)
  setupEventListeners();

  console.log("App initialized.");
}

// --- Update Event Listeners and Functions Using Canvas State ---

// Zoom Controls
zoomSlider.addEventListener("input", () => {
  const newZoomPercent = parseInt(zoomSlider.value, 10);
  zoomNumber.value = newZoomPercent;
  clearTimeout(zoomTimeout);
  zoomTimeout = setTimeout(() => {
    if (canvasManager) canvasManager.setZoomLevel(newZoomPercent); // Use Manager
  }, zoomDebounceDelay);
});
zoomNumber.addEventListener("change", () => {
  const newZoomPercent = parseInt(zoomNumber.value, 10);
  const minVal = parseInt(zoomSlider.min, 10);
  const maxVal = parseInt(zoomSlider.max, 10);
  const clampedPercent = Math.max(minVal, Math.min(maxVal, newZoomPercent));
  if (clampedPercent !== newZoomPercent) {
    zoomNumber.value = clampedPercent;
  }
  zoomSlider.value = clampedPercent;
  if (canvasManager) canvasManager.setZoomLevel(clampedPercent); // Use Manager
});

// Swatch Click Listener (inside createPalette)
// ...
cellContentDiv.addEventListener("click", (event) => {
  // Check manager state BEFORE checking touchEventHandled
  if ((canvasManager && canvasManager.didPointerMove()) || touchEventHandled) {
    touchEventHandled = false; // Reset touch flag if click is ignored
    return;
  }
  // ... rest of click logic ...
});
// ...

// Swatch TouchEnd Listener (inside createPalette)
// ...
if (isTouchDevice) {
  cellContentDiv.addEventListener(
    "touchend",
    (event) => {
      // Check manager state
      if (canvasManager && canvasManager.didPointerMove()) {
        touchEventHandled = false; // Ensure flag is reset if ignored
        return;
      }
      // ... rest of touchend logic ...
      touchEventHandled = true;
      event.preventDefault();
    },
    { passive: false },
  );
}
// ...

// State Saving
function saveState() {
  try {
    if (!canvasManager) {
      // Guard against saving before manager is ready
      console.error("Cannot save state: Canvas manager not initialized.");
      return;
    }
    const state = {
      // Non-canvas state
      sourceGridData,
      isInterpolationEnabled,
      interpolationSteps,
      saturationOffset,
      uiScale: currentUiScale,
      popoutEditorState: {
        /* ... */
      },
      colorPickerState: {
        /* ... */
      },
      // Canvas state from manager
      paletteOffsetX: canvasManager.offsetX,
      paletteOffsetY: canvasManager.offsetY,
      scale: canvasManager.scale,
    };
    localStorage.setItem(localStorageKey, JSON.stringify(state));
    console.log("Application state saved.");
    // Feedback...
  } catch (error) {
    console.error("Error saving state:", error);
    // Alert...
  }
}

// --- Remove Obsolete Global Functions ---
// Remove functions like startPan, panMove, endPan, applyZoom, updateTransform if they were global

// Ensure initialization is called
initializeApp();
